---
title: Основные сведения о производительности для смешанной реальности
description: Дополнительные разделы и сведения об оптимизации производительности для смешанной реальности приложений Windows
author: Troy-Ferrell
ms.author: trferrel
ms.date: 3/26/2019
ms.topic: article
keywords: Смешанный реальность, смешанная реальность, виртуальной реальности, виртуальной Реальности, MR, производительности, оптимизации, ЦП, GPU Windows
ms.openlocfilehash: ce59f9023c21dc7c981a2bb97d9fbd0c57622dbf
ms.sourcegitcommit: 384b0087899cd835a3a965f75c6f6c607c9edd1b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/12/2019
ms.locfileid: "59603288"
---
# <a name="understanding-performance-for-mixed-reality"></a><span data-ttu-id="533f2-104">Основные сведения о производительности для смешанной реальности</span><span class="sxs-lookup"><span data-stu-id="533f2-104">Understanding performance for mixed reality</span></span>

<span data-ttu-id="533f2-105">Эта статья содержит вводную информацию рационализации значимость производительности для приложения смешанной реальности.</span><span class="sxs-lookup"><span data-stu-id="533f2-105">This article is an introduction into rationalizing the significance of performance for your Mixed Reality app.</span></span>  <span data-ttu-id="533f2-106">Взаимодействие с пользователем может снижаться значительно, если приложение не запускается частотой кадров оптимальной.</span><span class="sxs-lookup"><span data-stu-id="533f2-106">User experience can be greatly degraded if your application does not run at optimal frame rate.</span></span> <span data-ttu-id="533f2-107">Голограммы, будут отображаться нестабильной головной отслеживания среды будут неточны, что приводит к снижению удобство работы пользователей.</span><span class="sxs-lookup"><span data-stu-id="533f2-107">Holograms will appear unstable and head tracking of the environment will be inaccurate leading to an poor experience for the user.</span></span> <span data-ttu-id="533f2-108">Действительно производительности следует рассматривать как компонентом первого класса для смешанной реальности разработки и не стабилизации, конец цикла задач.</span><span class="sxs-lookup"><span data-stu-id="533f2-108">Indeed, performance must be considered as a first class feature for Mixed Reality development and not a stabilization, end of cycle task.</span></span>

<span data-ttu-id="533f2-109">Для просмотра ниже перечислены значения частоты кадров производительность для каждой целевой платформы.</span><span class="sxs-lookup"><span data-stu-id="533f2-109">For review, the performant framerate values for each target platform are listed below.</span></span>

| <span data-ttu-id="533f2-110">Платформа</span><span class="sxs-lookup"><span data-stu-id="533f2-110">Platform</span></span> | <span data-ttu-id="533f2-111">Частота кадров целевого</span><span class="sxs-lookup"><span data-stu-id="533f2-111">Target Frame Rate</span></span> |
|----------|-------------------|
| [<span data-ttu-id="533f2-112">HoloLens</span><span class="sxs-lookup"><span data-stu-id="533f2-112">HoloLens</span></span>](hololens-hardware-details.md) | <span data-ttu-id="533f2-113">60 КАДРОВ/С</span><span class="sxs-lookup"><span data-stu-id="533f2-113">60 FPS</span></span> |
| [<span data-ttu-id="533f2-114">ПК Windows Mixed Reality Ultra</span><span class="sxs-lookup"><span data-stu-id="533f2-114">Windows Mixed Reality Ultra PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="533f2-115">90 КАДРОВ/С</span><span class="sxs-lookup"><span data-stu-id="533f2-115">90 FPS</span></span> |
| [<span data-ttu-id="533f2-116">Смешанный реальности ПК Windows</span><span class="sxs-lookup"><span data-stu-id="533f2-116">Windows Mixed Reality PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="533f2-117">60 КАДРОВ/С</span><span class="sxs-lookup"><span data-stu-id="533f2-117">60 FPS</span></span> |

<span data-ttu-id="533f2-118">Ниже платформа предоставляет общую структуру рекомендации и понимают к попадание на целевом частоты кадров.</span><span class="sxs-lookup"><span data-stu-id="533f2-118">The framework below gives a general outline for best practices and understandings towards hitting target frame rates.</span></span> <span data-ttu-id="533f2-119">Чтобы сразу приступить к работе дальнейшей в подробности, рекомендуется прочитать статью [рекомендации по производительности для статьи Unity](performance-recommendations-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="533f2-119">To dive further into details, consider reading the [performance recommendations for Unity article](performance-recommendations-for-unity.md).</span></span> <span data-ttu-id="533f2-120">В частности этот связанной статье описывается, как измерить частоту кадров в Unity Windows Mixed Reality приложения, а также действия, выполняемые в среде Unity для повышения производительности.</span><span class="sxs-lookup"><span data-stu-id="533f2-120">In particular, this related article will discuss how to measure framerate in your Unity Windows Mixed Reality app as well as steps to take in the Unity environment to improve performance.</span></span>

## <a name="understanding-performance-bottlenecks"></a><span data-ttu-id="533f2-121">Узких мест производительности</span><span class="sxs-lookup"><span data-stu-id="533f2-121">Understanding performance bottlenecks</span></span>

<span data-ttu-id="533f2-122">Если приложение имеет неэффективно частоты кадров, первым делом для анализа и понять, где приложение с большим объемом вычислений.</span><span class="sxs-lookup"><span data-stu-id="533f2-122">If your app has an underperforming framerate, the first step is to analyze and understand where your application is computationally intensive.</span></span> <span data-ttu-id="533f2-123">Есть два процессора первичный, отвечающие за работу для подготовки к просмотру в сцену: ЦП и GPU.</span><span class="sxs-lookup"><span data-stu-id="533f2-123">There are two primary processors responsible for the work to render your scene: the CPU and the GPU.</span></span> <span data-ttu-id="533f2-124">Каждый из этих двух компонентов обрабатывать различные операции и этапы приложения смешанной реальности.</span><span class="sxs-lookup"><span data-stu-id="533f2-124">Each of these two components handle different operations and stages of your Mixed Reality app.</span></span> <span data-ttu-id="533f2-125">Существуют три ключевых местах, где могут возникнуть узкие места.</span><span class="sxs-lookup"><span data-stu-id="533f2-125">There are three key places where bottlenecks may occur.</span></span> 

1. <span data-ttu-id="533f2-126">**Поток приложения - ЦП** -этот поток отвечает за логику приложения.</span><span class="sxs-lookup"><span data-stu-id="533f2-126">**App Thread - CPU** - This thread is responsible for your app logic.</span></span> <span data-ttu-id="533f2-127">Это включает в себя обработку входных данных, анимации, физики и другие приложения логики или состояния</span><span class="sxs-lookup"><span data-stu-id="533f2-127">This includes processing input, animations, physics, and other app logic/state</span></span>
2. <span data-ttu-id="533f2-128">**Поток - отрисовки ресурсов ЦП и GPU** -этот поток отвечает на передачу вызовов draw в GPU.</span><span class="sxs-lookup"><span data-stu-id="533f2-128">**Render Thread - CPU to GPU** - This thread is responsible for submitting your draw calls to the GPU.</span></span> <span data-ttu-id="533f2-129">Когда приложение хочет отобразить объект, например куба или модели, этот поток отправляет запрос в GPU, имеющий архитектурой, оптимизированный для подготовки отчетов, для выполнения этих операций.</span><span class="sxs-lookup"><span data-stu-id="533f2-129">When your app wants to render an object such as a cube or model, this thread sends a request to the GPU, which has an architecture optimized for rendering, to perform these operations.</span></span>
3. <span data-ttu-id="533f2-130">**GPU** - 
    этот обработчик обычно обрабатывает графического конвейера приложения для преобразования трехмерного данных (моделей, текстур и т.д) в пикселях и в конечном счете создания двухмерное изображение для отправки на экране устройства.</span><span class="sxs-lookup"><span data-stu-id="533f2-130">**GPU** - 
 This processor most commonly handles the graphics pipeline of your application to transform 3D data (models, textures, etc) into pixels and ultimately produce a 2D image to submit to your device's screen.</span></span>

![Время существования кадра](images/lifetime-of-a-frame.png)

<span data-ttu-id="533f2-132">Как правило HoloLens приложения будут ограниченные GPU.</span><span class="sxs-lookup"><span data-stu-id="533f2-132">Generally, HoloLens applications will be GPU bounded.</span></span> <span data-ttu-id="533f2-133">Тем не менее это не выполняются в каждое приложение, и поэтому рекомендуется использовать средства и методики ниже, чтобы перейти к естественных для вашего конкретного приложения.</span><span class="sxs-lookup"><span data-stu-id="533f2-133">However, this does not hold true in every application and thus it is recommended to use the tools & techniques below to get to ground-truth for your particular app.</span></span>

## <a name="how-to-analyze-your-application"></a><span data-ttu-id="533f2-134">Как для анализа работы приложения</span><span class="sxs-lookup"><span data-stu-id="533f2-134">How to analyze your application</span></span>

<span data-ttu-id="533f2-135">Существует множество средств, которые позволяют вам как разработчику понять профиль производительности приложения смешанной реальности.</span><span class="sxs-lookup"><span data-stu-id="533f2-135">There are many tools that allow you as a developer to understand the performance profile of your Mixed Reality application.</span></span> <span data-ttu-id="533f2-136">Это позволит вам как целевой объект, где у вас есть узкие места и как они manifesting самостоятельно выполнять их отладку.</span><span class="sxs-lookup"><span data-stu-id="533f2-136">These will enable you to both target where you have bottlenecks and how they are manifesting themselves to debug them.</span></span>

<span data-ttu-id="533f2-137">Это список популярной и многофункциональной, позволяющих получить глубокое данные профилирования для приложения.</span><span class="sxs-lookup"><span data-stu-id="533f2-137">This is a list of popular and powerful tools to gain deep profiling information for your application.</span></span>
- [<span data-ttu-id="533f2-138">Intel Graphics Performance Analyzers</span><span class="sxs-lookup"><span data-stu-id="533f2-138">Intel Graphics Performance Analyzers</span></span>](https://software.intel.com/gpa)
- [<span data-ttu-id="533f2-139">Отладчики графики Visual Studio</span><span class="sxs-lookup"><span data-stu-id="533f2-139">Visual Studio Graphics Debuggers</span></span>](https://docs.microsoft.com/visualstudio/debugger/graphics/visual-studio-graphics-diagnostics?view=vs-2017)
- [<span data-ttu-id="533f2-140">Unity Profiler</span><span class="sxs-lookup"><span data-stu-id="533f2-140">Unity Profiler</span></span>](https://docs.unity3d.com/Manual/Profiler.html)
- [<span data-ttu-id="533f2-141">Отладчик Unity кадра</span><span class="sxs-lookup"><span data-stu-id="533f2-141">Unity Frame Debugger</span></span>](https://docs.unity3d.com/Manual/FrameDebugger.html)

### <a name="how-to-profile-in-any-environment"></a><span data-ttu-id="533f2-142">Профилирование в любой среде</span><span class="sxs-lookup"><span data-stu-id="533f2-142">How to profile in any environment</span></span>

<span data-ttu-id="533f2-143">Нет простой тест, чтобы быстро определить, если вас наверняка будут ограниченные GPU или ЦП, ограниченных в приложении.</span><span class="sxs-lookup"><span data-stu-id="533f2-143">There is a simple test to quickly determine if you are likely GPU bounded or CPU bounded in your application.</span></span> <span data-ttu-id="533f2-144">При уменьшении разрешение вывод целевого объекта отрисовки, существует меньше точек для вычисления, и таким образом, меньше работы GPU необходимо выполнить, чтобы отобразить изображение.</span><span class="sxs-lookup"><span data-stu-id="533f2-144">If you decrease the resolution of the render target output, there are less pixels to calculate and thus, less work the GPU needs to perform to render an image.</span></span> <span data-ttu-id="533f2-145">Окна просмотра, масштабирование (динамическое разрешение масштабирование) является способ визуализации изображения, меньше чем целевой объект отрисовки, а затем можно отобразить устройства вывода.</span><span class="sxs-lookup"><span data-stu-id="533f2-145">Viewport scaling (dynamic resolution scaling) is the practice of rendering your image to a smaller render target then your output device can display.</span></span> <span data-ttu-id="533f2-146">Устройство будет вверх выборку из меньший набор пикселей для отображения окончательного образа.</span><span class="sxs-lookup"><span data-stu-id="533f2-146">The device will up-sample from the smaller set of pixels to display your final image.</span></span>

<span data-ttu-id="533f2-147">После уменьшения разрешения для подготовки к просмотру, если:</span><span class="sxs-lookup"><span data-stu-id="533f2-147">After decreasing rendering resolution, if:</span></span>
1) <span data-ttu-id="533f2-148">Частота кадров приложения **увеличивает**, то скорее **ограниченного GPU**</span><span class="sxs-lookup"><span data-stu-id="533f2-148">Application framerate **increases**, then you are likely **GPU Bounded**</span></span>
1) <span data-ttu-id="533f2-149">Частота кадров приложения **неизменным**, то скорее **ограниченного ЦП**</span><span class="sxs-lookup"><span data-stu-id="533f2-149">Application framerate **unchanged**, then you are likely **CPU Bounded**</span></span>

>[!NOTE]
><span data-ttu-id="533f2-150">Среда Unity предоставляет возможность легко изменять разрешения целевых отрисовки приложения во время выполнения посредством *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* свойство.</span><span class="sxs-lookup"><span data-stu-id="533f2-150">Unity provides the ability to easily modify the render target resolution of your application at runtime through the *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property.</span></span> <span data-ttu-id="533f2-151">Итоговый образ, представленные на устройстве имеет фиксированным разрешением.</span><span class="sxs-lookup"><span data-stu-id="533f2-151">The final image presented on device has a fixed resolution.</span></span> <span data-ttu-id="533f2-152">Платформа делает выборку низкого разрешения, выходные данные для создания образа выше разрешения для отрисовки на отображение.</span><span class="sxs-lookup"><span data-stu-id="533f2-152">The platform will sample the lower resolution output to build a higher resolution image for rendering on displays.</span></span> 
>
>```CS
>UnityEngine.XR.XRSettings.renderScale = 0.7f;
>```

## <a name="how-to-improve-your-application"></a><span data-ttu-id="533f2-153">Как улучшить приложение</span><span class="sxs-lookup"><span data-stu-id="533f2-153">How to improve your application</span></span>

### <a name="cpu-performance-recommendations"></a><span data-ttu-id="533f2-154">Рекомендации по производительности ЦП</span><span class="sxs-lookup"><span data-stu-id="533f2-154">CPU performance recommendations</span></span>

<span data-ttu-id="533f2-155">Как правило большую часть работы в приложении смешанной реальности на ЦП включает в себя выполнение «моделирование» сцены и расширенное уникальные приложения логики обработки.</span><span class="sxs-lookup"><span data-stu-id="533f2-155">Generally, most work in a mixed reality application on the CPU involves performing the "simulation" of the scene and processing extensive unique application logic.</span></span> <span data-ttu-id="533f2-156">Таким образом следующее обычно предназначены для оптимизации.</span><span class="sxs-lookup"><span data-stu-id="533f2-156">Thus, the following areas are usually targeted for optimization.</span></span>

- <span data-ttu-id="533f2-157">Анимации</span><span class="sxs-lookup"><span data-stu-id="533f2-157">Animations</span></span>
- <span data-ttu-id="533f2-158">Упростите Физика</span><span class="sxs-lookup"><span data-stu-id="533f2-158">Simplify Physics</span></span>
- <span data-ttu-id="533f2-159">Выделение памяти</span><span class="sxs-lookup"><span data-stu-id="533f2-159">Memory allocations</span></span>
- <span data-ttu-id="533f2-160">Сложные алгоритмы (например)</span><span class="sxs-lookup"><span data-stu-id="533f2-160">Complex algorithms (i.e</span></span> <span data-ttu-id="533f2-161">обратной кинематики, пути поиска)</span><span class="sxs-lookup"><span data-stu-id="533f2-161">inverse kinematics, path-finding)</span></span>

### <a name="gpu-performance-recommendations"></a><span data-ttu-id="533f2-162">Рекомендации по производительности GPU</span><span class="sxs-lookup"><span data-stu-id="533f2-162">GPU performance recommendations</span></span>

#### <a name="understanding-bandwidth-vs-fill-rate"></a><span data-ttu-id="533f2-163">Коэффициент заполнения vs основные сведения о пропускной способности</span><span class="sxs-lookup"><span data-stu-id="533f2-163">Understanding bandwidth vs fill rate</span></span>
<span data-ttu-id="533f2-164">При отрисовке определенного кадра на GPU, приложение обычно является либо ограничивается скорость пропускной способности или заливкой памяти.</span><span class="sxs-lookup"><span data-stu-id="533f2-164">When rendering a frame on the GPU, an application is generally either bounded by memory bandwidth or fill rate.</span></span>

- <span data-ttu-id="533f2-165">**Пропускная способность памяти** — это скорость операций чтения и записи GPU можно выполнять из памяти</span><span class="sxs-lookup"><span data-stu-id="533f2-165">**Memory bandwidth** is the rate of reads and writes the GPU can perform from memory</span></span>
    - <span data-ttu-id="533f2-166">Чтобы определить ограничения пропускной способности, снизить качество текстуры и проверьте, если частота кадров улучшается.</span><span class="sxs-lookup"><span data-stu-id="533f2-166">To identify bandwidth limitations, reduce texture quality and check if framerate improved.</span></span>
    - <span data-ttu-id="533f2-167">В Unity, это можно сделать, изменив **качества текстуры** в **изменить** > **параметры проекта**  >   **[ Параметры качества](https://docs.unity3d.com/Manual/class-QualitySettings.html)**.</span><span class="sxs-lookup"><span data-stu-id="533f2-167">In Unity, this can be done by changing **Texture Quality** in **Edit** > **Project Settings** > **[Quality Settings](https://docs.unity3d.com/Manual/class-QualitySettings.html)**.</span></span>
- <span data-ttu-id="533f2-168">**Скоростью заполнения** ссылается на пропускную способность, готовый для просмотра пикселей, которые можно рисовать в секунду с GPU.</span><span class="sxs-lookup"><span data-stu-id="533f2-168">**Fill rate** refers to the throughput of rendered pixels that can be drawn per second by the GPU.</span></span>
    - <span data-ttu-id="533f2-169">Для определения заливки ограничение скорости, уменьшите разрешение экрана и проверьте, если частота кадров улучшается.</span><span class="sxs-lookup"><span data-stu-id="533f2-169">To identify fill rate limitations, decrease the display resolution and check if framerate improved.</span></span> 
    - <span data-ttu-id="533f2-170">В Unity, это можно сделать с помощью *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* свойство</span><span class="sxs-lookup"><span data-stu-id="533f2-170">In Unity, this can be done via the  *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property</span></span>

<span data-ttu-id="533f2-171">Пропускная способность памяти обычно включает в себя оптимизацию либо</span><span class="sxs-lookup"><span data-stu-id="533f2-171">Memory bandwidth generally involves optimizations to either</span></span>
1) <span data-ttu-id="533f2-172">уменьшить разрешение текстуры</span><span class="sxs-lookup"><span data-stu-id="533f2-172">decrease texture resolutions</span></span>
2) <span data-ttu-id="533f2-173">использовать меньше текстур (например)</span><span class="sxs-lookup"><span data-stu-id="533f2-173">utilize less textures (i.e</span></span> <span data-ttu-id="533f2-174">нормали, отражающий, д)</span><span class="sxs-lookup"><span data-stu-id="533f2-174">normals, specular, etc)</span></span>

<span data-ttu-id="533f2-175">Коэффициент заполнения в основном ориентировано на сокращение количества операций, которые должны вычисляться для окончательного готовый для просмотра пикселя.</span><span class="sxs-lookup"><span data-stu-id="533f2-175">Fill rate is primarily focused on reducing the number of operations that need to be computed for a final rendered pixel.</span></span> <span data-ttu-id="533f2-176">В качестве примера часто делятся на уменьшение</span><span class="sxs-lookup"><span data-stu-id="533f2-176">Examples of this commonly fall into reducing</span></span>
1) <span data-ttu-id="533f2-177">количество объектов для рендеринга и обработки</span><span class="sxs-lookup"><span data-stu-id="533f2-177">number of objects to render/process</span></span>
2) <span data-ttu-id="533f2-178">Количество операций в шейдера</span><span class="sxs-lookup"><span data-stu-id="533f2-178">number of operations per shader</span></span>
3) <span data-ttu-id="533f2-179">количество этапов GPU окончательный результат (геометрических объектов, постобработка эффекты и т. д)</span><span class="sxs-lookup"><span data-stu-id="533f2-179">number of GPU stages to final result (geometry shaders, post-processing effects, etc)</span></span>
4) <span data-ttu-id="533f2-180">число пикселей для отрисовки (т. е.</span><span class="sxs-lookup"><span data-stu-id="533f2-180">number of pixels to render (i.e</span></span> <span data-ttu-id="533f2-181">разрешение экрана)</span><span class="sxs-lookup"><span data-stu-id="533f2-181">display resolution)</span></span>

#### <a name="reduce-poly-count"></a><span data-ttu-id="533f2-182">Уменьшение числа poly</span><span class="sxs-lookup"><span data-stu-id="533f2-182">Reduce poly count</span></span>
<span data-ttu-id="533f2-183">Выше многоугольника подсчитывает результат в дополнительные операции для графического Процессора и уменьшению числа многоугольники в сцене сократит количество времени для визуализации этого геометрического объекта.</span><span class="sxs-lookup"><span data-stu-id="533f2-183">Higher polygon counts result in more operations for the GPU and reducing the number of polygons in your scene will reduce the amount of time to render that geometry.</span></span> <span data-ttu-id="533f2-184">Также в заливки геометрии, по-прежнему могут потреблять задействованы другие факторы, но количество многоугольников является базовой метрики, чтобы определить, насколько велики затраты сцены будет для подготовки к просмотру.</span><span class="sxs-lookup"><span data-stu-id="533f2-184">There are other factors involved as well in shading the geometry that can still be expensive but polygon count is the base metric to determine how expensive a scene will be to render.</span></span>

#### <a name="limit-overdraw"></a><span data-ttu-id="533f2-185">Ограничение может быть нарисован поверх</span><span class="sxs-lookup"><span data-stu-id="533f2-185">Limit overdraw</span></span>

<span data-ttu-id="533f2-186">Высокий перерисовывать происходит, когда несколько объектов представления, но не выводятся на экран, как они скрыты по другой, обычно более подробно, occluding объекта.</span><span class="sxs-lookup"><span data-stu-id="533f2-186">High overdraw occurs when multiple objects are rendered but not outputted to the screen as they are hidden by another, generally closer, occluding object.</span></span> <span data-ttu-id="533f2-187">Представьте себе, просмотрев стены, имеющего несколько комнаты и geometry, за ней.</span><span class="sxs-lookup"><span data-stu-id="533f2-187">Imagine looking at a wall that had multiple rooms and geometry behind it.</span></span> <span data-ttu-id="533f2-188">Все геометрии должны быть обработаны для подготовки к просмотру, но только непрозрачный стены действительно требуется отображены как его occludes вида все содержимое.</span><span class="sxs-lookup"><span data-stu-id="533f2-188">All of the geometry would be processed for rendering but only the opaque wall really needs to be rendered as it occludes the view of all other content.</span></span> <span data-ttu-id="533f2-189">Это приводит к потере операции, которые не требуются для текущего представления.</span><span class="sxs-lookup"><span data-stu-id="533f2-189">This results in wasteful operations that are not needed for the current view.</span></span>

#### <a name="shaders"></a><span data-ttu-id="533f2-190">Шейдеры</span><span class="sxs-lookup"><span data-stu-id="533f2-190">Shaders</span></span>

<span data-ttu-id="533f2-191">Шейдеры — небольшой программы, которые выполняются в GPU и обычно определить два важных шага при подготовке к просмотру:</span><span class="sxs-lookup"><span data-stu-id="533f2-191">Shaders are small programs that run on the GPU and generally determine two important steps in rendering:</span></span>
1) <span data-ttu-id="533f2-192">какие вершины должно отображаться на экране, и где они находятся в пространстве экрана (например)</span><span class="sxs-lookup"><span data-stu-id="533f2-192">which object's vertices should be drawn on the screen and where they are in screen space (i.e</span></span> <span data-ttu-id="533f2-193">Вершинный построитель текстуры)</span><span class="sxs-lookup"><span data-stu-id="533f2-193">the Vertex shader)</span></span>
    - <span data-ttu-id="533f2-194">Вершинный построитель текстуры обычно выполняется на вершину для каждого GameObject</span><span class="sxs-lookup"><span data-stu-id="533f2-194">The Vertex shader is generally executed per vertex for every GameObject</span></span>
2) <span data-ttu-id="533f2-195">что следует цвета этих пикселей (например)</span><span class="sxs-lookup"><span data-stu-id="533f2-195">what to color those pixels (i.e</span></span> <span data-ttu-id="533f2-196">шейдер пикселей)</span><span class="sxs-lookup"><span data-stu-id="533f2-196">the Pixel shader)</span></span>
    - <span data-ttu-id="533f2-197">Построитель текстуры выполняется на пиксель для текстуры к просмотру устройство</span><span class="sxs-lookup"><span data-stu-id="533f2-197">The Pixel shader is executed per pixel for the texture being rendered for device present</span></span>

<span data-ttu-id="533f2-198">Обычно шейдеры выполняют множество преобразований и освещения вычисления.</span><span class="sxs-lookup"><span data-stu-id="533f2-198">Typically shaders perform many transformations and lighting calculations.</span></span> <span data-ttu-id="533f2-199">Несмотря на то, что модели сложных освещения, теней и других операций можно сформировать фантастические результаты, они также поставляются с ценой.</span><span class="sxs-lookup"><span data-stu-id="533f2-199">Although complex lighting models, shadows, and other operations can generate fantastic results, they also come with a price.</span></span> <span data-ttu-id="533f2-200">Сокращение количества операций, вычисляемых в шейдеров может значительно снизить общей работы, которую нужно выполнить в каждом кадре графического Процессора.</span><span class="sxs-lookup"><span data-stu-id="533f2-200">Reducing the number of operations computed in shaders can greatly reduce the overall work needed to be done by a GPU per frame.</span></span>

##### <a name="shader-coding-recommendations"></a><span data-ttu-id="533f2-201">Шейдер кодирования рекомендации</span><span class="sxs-lookup"><span data-stu-id="533f2-201">Shader coding recommendations</span></span>

- <span data-ttu-id="533f2-202">Использовать билинейная фильтрация, когда это возможно</span><span class="sxs-lookup"><span data-stu-id="533f2-202">Use bilinear filtering whenever possible</span></span>
- <span data-ttu-id="533f2-203">Изменить порядок выражений, используемых для выполнения умножения и сложения, в то же время MAD встроенные функции</span><span class="sxs-lookup"><span data-stu-id="533f2-203">Rearrange expressions to use MAD intrinsics in order to do a multiply and an add at the same time</span></span>
- <span data-ttu-id="533f2-204">Рассчитывают максимально на ЦП и передайте в качестве константы к материалам</span><span class="sxs-lookup"><span data-stu-id="533f2-204">Precalculate as much as possible on the CPU and pass as constants to the material</span></span>
- <span data-ttu-id="533f2-205">**Приоритет перенос операций из построителя текстуры в шейдер вершин**</span><span class="sxs-lookup"><span data-stu-id="533f2-205">**Favor moving operations from the pixel shader to the vertex shader**</span></span>
    - <span data-ttu-id="533f2-206">Обычно число вершин << # пикселей (например)</span><span class="sxs-lookup"><span data-stu-id="533f2-206">Generally the # of vertices << # of pixels (i.e</span></span> <span data-ttu-id="533f2-207">720 p == 921 600 пикселей, 1080 p == 2,073,600 пикселей и т. д)</span><span class="sxs-lookup"><span data-stu-id="533f2-207">720p == 921,600 pixels, 1080p == 2,073,600 pixels, etc)</span></span>

#### <a name="remove-gpu-stages"></a><span data-ttu-id="533f2-208">Удалить этапы графического Процессора</span><span class="sxs-lookup"><span data-stu-id="533f2-208">Remove GPU stages</span></span>
<span data-ttu-id="533f2-209">Постобработка эффекты могут обходиться очень дорого и обычно препятствовать коэффициент заполнения приложения.</span><span class="sxs-lookup"><span data-stu-id="533f2-209">Post-processing effects can be very expensive and generally inhibit the fill rate of your application.</span></span> <span data-ttu-id="533f2-210">Сюда также входят методы сглаживания, такие как MSAA.</span><span class="sxs-lookup"><span data-stu-id="533f2-210">This also includes anti-aliasing techniques such as MSAA.</span></span> <span data-ttu-id="533f2-211">На HoloLens рекомендуется полностью избежать этих методов.</span><span class="sxs-lookup"><span data-stu-id="533f2-211">On HoloLens, it is recommended to avoid these techniques entirely.</span></span> <span data-ttu-id="533f2-212">Кроме того следует избегать этапов дополнительных шейдера геометрии, оболочка и вычислительных шейдеров по возможности.</span><span class="sxs-lookup"><span data-stu-id="533f2-212">Furthermore, additional shader stages such as geometry, hull, and compute shaders should be avoided when possible.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="533f2-213">Рекомендации по объему памяти</span><span class="sxs-lookup"><span data-stu-id="533f2-213">Memory recommendations</span></span>
<span data-ttu-id="533f2-214">Операции выделения и освобождения слишком большой объем памяти, могут иметь неблагоприятное воздействие на holographic приводит к несогласованности производительности, зафиксированной кадров и других неблагоприятное поведение приложения.</span><span class="sxs-lookup"><span data-stu-id="533f2-214">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="533f2-215">Это особенно важно понять рекомендации по использованию памяти, при разработке в Unity, так как управление памятью осуществляется сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="533f2-215">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="533f2-216">Использование пулов объектов</span><span class="sxs-lookup"><span data-stu-id="533f2-216">Object pooling</span></span>

<span data-ttu-id="533f2-217">Использование пулов объектов — популярный способ для сокращения затрат непрерывное выделение и освобождение объектов.</span><span class="sxs-lookup"><span data-stu-id="533f2-217">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="533f2-218">Это делается путем выделения большого пула идентичные объекты и повторное использование экземпляров неактивных, доступные из этого пула, а не постоянно порождении и уничтожение объектов со временем.</span><span class="sxs-lookup"><span data-stu-id="533f2-218">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="533f2-219">Пулы объектов отлично подходят для повторно готовый к применению компонентов, которые имеют время существования переменной во время приложения.</span><span class="sxs-lookup"><span data-stu-id="533f2-219">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

## <a name="see-also"></a><span data-ttu-id="533f2-220">См. также</span><span class="sxs-lookup"><span data-stu-id="533f2-220">See also</span></span>
- [<span data-ttu-id="533f2-221">Рекомендации по производительности для Unity</span><span class="sxs-lookup"><span data-stu-id="533f2-221">Performance recommendations for Unity</span></span>](performance-recommendations-for-unity.md)
- [<span data-ttu-id="533f2-222">Рекомендуемые параметры для Unity</span><span class="sxs-lookup"><span data-stu-id="533f2-222">Recommended settings for Unity</span></span>](recommended-settings-for-unity.md)
