---
title: Основные сведения о производительности смешанной реальности
description: Дополнительные разделы и сведения о оптимизации производительности приложений Windows Mixed Reality
author: Troy-Ferrell
ms.author: trferrel
ms.date: 3/26/2019
ms.topic: article
keywords: Windows Mixed Reality, Смешанная реальность, виртуальная реальность, VR, MR, производительность, оптимизация, ЦП, GPU
ms.openlocfilehash: ce59f9023c21dc7c981a2bb97d9fbd0c57622dbf
ms.sourcegitcommit: 915d3cc63a5571ba22ac4608589f3eca8da1bc81
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/24/2019
ms.locfileid: "63548845"
---
# <a name="understanding-performance-for-mixed-reality"></a>Основные сведения о производительности смешанной реальности

Эта статья содержит общие сведения о рационализацию производительности приложения смешанной реальности.  Работа пользователей может быть значительно снижена, если приложение не работает с оптимальной частотой кадров. Голограммы будут отображаться нестабильно, а отслеживание головного окружения будет неточным, что приведет к неудачной работе пользователя. Действительно, производительность должна рассматриваться как первая функция класса для разработки смешанной реальности, а не стабилизации, задача конца цикла.

Для проверки, ниже перечислены значения для выполнения частотных кадров для каждой целевой платформы.

| Платформа | Частота целевых кадров |
|----------|-------------------|
| [HoloLens](hololens-hardware-details.md) | 60 КАДРОВ/С |
| [Портативные компьютеры Windows Mixed Reality](immersive-headset-hardware-details.md) | 90 КАДРОВ/С |
| [Компьютеры Windows Mixed Reality](immersive-headset-hardware-details.md) | 60 КАДРОВ/С |

Приведенная ниже платформа предоставляет общий обзор рекомендаций и понятий, направленных на достижение целевой частоты кадров. Чтобы подробно изучить подробности, ознакомьтесь со статьей [рекомендации по производительности для Unity](performance-recommendations-for-unity.md). В частности, эта статья посвящена измерению частоты кадров в приложении Windows Mixed Reality в Unity, а также действиям, выполняемым в среде Unity для повышения производительности.

## <a name="understanding-performance-bottlenecks"></a>Основные сведения о узких местах производительности

Если приложение имеет небольшую частоту кадров, первый шаг состоит в анализе и понимании того, где приложение получает ресурсоемкие вычисления. Существует два основных процессора, ответственных за работу с визуализацией сцены: ЦП и GPU. Каждый из этих двух компонентов обрабатывает различные операции и этапы приложения смешанной реальности. Существует три основных места, где могут возникнуть узкие места. 

1. **Поток приложения — ЦП** . Этот поток отвечает за логику приложения. Это включает обработку входных данных, анимацию, физику и другую логику или состояние приложения.
2. **Прорисовка потока — ЦП в GPU** — этот поток отвечает за отправку вызовов рисования в GPU. Когда приложение хочет отобразить объект, например куб или модель, этот поток отправляет в GPU запрос, который имеет оптимизированную для отрисовки архитектуру для выполнения этих операций.
3. **GPU** - 
    Этот процессор чаще всего обрабатывает графический конвейер приложения для преобразования трехмерных данных (моделей, текстур и т. д.) в Пиксели и, в конечном итоге, создания 2D-изображения для отправки на экран устройства.

![Время существования кадра](images/lifetime-of-a-frame.png)

Как правило, приложения HoloLens будут ограничены GPU. Тем не менее, это не имеет значения true в каждом приложении, поэтому рекомендуется использовать средства & приведенных ниже способов, чтобы приступить к истинности конкретного приложения.

## <a name="how-to-analyze-your-application"></a>Анализ приложения

Существует множество средств, позволяющих разработчику понять профиль производительности приложения смешанной реальности. Это позволит использовать обе цели, на которых имеются узкие места, и как они являются манифестами для их отладки.

Это список популярных и мощных средств для получения подробных сведений о профилировании для приложения.
- [Анализаторы производительности графики Intel](https://software.intel.com/gpa)
- [Отладчики графики Visual Studio](https://docs.microsoft.com/visualstudio/debugger/graphics/visual-studio-graphics-diagnostics?view=vs-2017)
- [Профилировщик Unity](https://docs.unity3d.com/Manual/Profiler.html)
- [Отладчик фреймов Unity](https://docs.unity3d.com/Manual/FrameDebugger.html)

### <a name="how-to-profile-in-any-environment"></a>Профилирование в любой среде

Существует простой тест для быстрого определения вероятности ограниченного использования GPU или ЦП, ограниченного в приложении. Если вы уменьшите разрешение выходных данных целевого объекта рендеринга, то Вычислите и таким образом меньшее количество пикселей, чтобы GPU выполнялось для отрисовки изображения. Масштабирование окна просмотра (динамическое масштабирование разрешения) — это практика отрисовки изображения на меньший целевой объект отрисовки, после чего устройство вывода может быть отображено. Устройство выберет выборку из меньшего набора пикселей, чтобы отобразить окончательный образ.

После уменьшения разрешения отрисовки, если:
1) **Увеличение**частоты кадров приложения, скорее всего, **ограниченный GPU**
1) Частота кадров приложения не изменилась, скорее всего, **ЦП ограничен**

>[!NOTE]
>Unity предоставляет возможность легко изменять разрешение целевого объекта отрисовки приложения во время выполнения с помощью свойства *[ксрсеттингс. рендервиевпортскале](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* . Конечный образ, представленный на устройстве, имеет фиксированное разрешение. Платформа будет выполнять выборку выходных данных с низким разрешением для создания изображения более высокого разрешения для отображения на экране. 
>
>```CS
>UnityEngine.XR.XRSettings.renderScale = 0.7f;
>```

## <a name="how-to-improve-your-application"></a>Как улучшить приложение

### <a name="cpu-performance-recommendations"></a>Рекомендации по производительности ЦП

Как правило, большинство работы в приложении смешанной реальности на ЦП предполагает выполнение "моделирования" сцены и обработку обширной уникальной логики приложения. Поэтому следующие области обычно предназначены для оптимизации.

- Анимации
- Упрощение Физикы
- Выделение памяти
- Сложные алгоритмы (т. е. Обратная кинематика, поиск по пути)

### <a name="gpu-performance-recommendations"></a>Рекомендации по производительности GPU

#### <a name="understanding-bandwidth-vs-fill-rate"></a>Общие сведения о пропускной способности и скорости заполнения
При отрисовке кадра на GPU приложение обычно либо ограничено пропускной способностью памяти, либо скоростью заполнения.

- **Пропускная способность памяти** — это частота операций чтения и записи, которую GPU может выполнять из памяти.
    - Чтобы определить ограничения пропускной способности, уменьшите качество текстуры и проверьте, увеличилась ли частота кадров.
    - В Unity это можно сделать, изменив **качество текстуры** в окне **изменение** > параметров**проекта** > параметры **[качества](https://docs.unity3d.com/Manual/class-QualitySettings.html)** .
- **Скорость заливки** обозначает пропускную способность отображаемых пикселов, которые могут быть отображены в секунду графическим процессором.
    - Чтобы определить ограничения скорости заполнения, уменьшите разрешение экрана и проверьте, увеличилась ли частота кадров. 
    - В Unity это можно сделать с помощью свойства *[ксрсеттингс. рендервиевпортскале.](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)*

Пропускная способность памяти обычно включает оптимизацию для
1) уменьшение разрешений текстуры
2) Используйте меньше текстур (например, нормали, блики и т. д.)

Скорость заполнения в основном сосредоточена на уменьшении количества операций, которые необходимо вычислить для окончательного визуализированного пикселя. Примеры, как правило, попадают в сокращение
1) число объектов для отрисовки или обработки
2) число операций на шейдер
3) число стадий GPU до окончательного результата (геометрические шейдеры, эффекты последующей обработки и т. д.)
4) число пикселей для отрисовки (например, разрешение экрана)

#### <a name="reduce-poly-count"></a>Сокращение числа поли
Чем больше число многоугольников, тем больше операций для GPU и сокращение количества многоугольников в сцене сокращает время, необходимое для визуализации этой геометрии. Существуют и другие факторы, связанные с заливкой геометрии, который по-прежнему может быть дорогостоящим, но количество многоугольников — это базовая метрика, позволяющая определить частоту визуализации сцены.

#### <a name="limit-overdraw"></a>Ограничить перерисовку

Высокая перерисовка происходит, когда несколько объектов визуализируются, но не выводятся на экран, так как они скрыты другим, как правило, ближе к окклудинг объекту. Представьте себе, что вы просматриваете стену с несколькими комнатами и геометрическим объектом. Все геометрические данные будут обрабатываться для отрисовки, но только непрозрачная стенка действительно должна быть визуализирована, так как она окклудес представление всего другого содержимого. Это приводит к операциям непроизводительна, которые не требуются для текущего представления.

#### <a name="shaders"></a>Шейдеры

Шейдер — это небольшие программы, которые работают на GPU и обычно определяют два важных шага при подготовке к просмотру:
1) какие вершины объекта должны отображаться на экране и где они находятся в пространстве экрана (т. е. Шейдер вершин)
    - Обычно шейдер вершин выполняется на вершину для каждого GameObject
2) цвет этих пикселов (например, шейдер пикселей)
    - Построитель текстуры выполняется на пиксель для визуализации текстуры, представленной для устройства

Обычно шейдеры выполняют много преобразований и вычислений освещения. Хотя сложные модели освещения, тени и другие операции могут создавать отличные результаты, они также поставляются с ценой. Уменьшение числа операций, вычисленных в шейдере, может значительно снизить общую работу, необходимую для графического процессора на кадр.

##### <a name="shader-coding-recommendations"></a>Рекомендации по кодированию шейдера

- Использовать фильтрацию билинейной везде, где это возможно
- Переупорядочение выражений для использования встроенных функций MAD для умножения и добавления в одно и то же время
- Предварительно вычислить как можно больше ресурсов ЦП и передать его в качестве констант в материал
- **Предпочитать операции перемещения из шейдера пикселей к шейдеру вершин**
    - Обычно число вершин < < количество пикселей (т. е. 720p = = 921 600 пикселей, 1080p = = 2 073 600 пикселей и т. д.)

#### <a name="remove-gpu-stages"></a>Удалить этапы GPU
Результаты последующей обработки могут быть очень ресурсоемкими и, как правило, отменяют скорость заполнения приложения. Сюда также входят методики сглаживания, такие как MSAA. В HoloLens рекомендуется избегать использования этих методов полностью. Более того, когда это возможно, следует избегать дополнительных этапов шейдера, таких как геометрические объекты, поверхности и шейдеры вычислений.

## <a name="memory-recommendations"></a>Рекомендации по использованию памяти
Чрезмерное выделение памяти & операциях изъятия может оказать негативное влияние на работу с holographic, что приведет к нестабильной производительности, замороженным кадрам и другим негативным последствиям. Особенно важно понимать требования к памяти при разработке в Unity, так как управление памятью управляется сборщиком мусора.

#### <a name="object-pooling"></a>Объединение объектов в пул

Использование пулов объектов — популярная методика снижения затрат на непрерывное выделение памяти & освобождением объектов. Это делается путем выделения большого пула идентичных объектов и повторного использования неактивных, доступных экземпляров из этого пула вместо постоянного создания и уничтожения объектов с течением времени. Пулы объектов отлично подходят для повторного создания компонентов, которые имеют переменное время существования во время выполнения приложения.

## <a name="see-also"></a>См. также
- [Рекомендации по производительности для Unity](performance-recommendations-for-unity.md)
- [Рекомендуемые параметры для Unity](recommended-settings-for-unity.md)
