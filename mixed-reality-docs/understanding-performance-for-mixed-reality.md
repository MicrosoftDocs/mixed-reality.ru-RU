---
title: Основные сведения о производительности смешанной реальности
description: Дополнительные разделы и сведения о оптимизации производительности приложений Windows Mixed Reality
author: Troy-Ferrell
ms.author: trferrel
ms.date: 3/26/2019
ms.topic: article
keywords: Windows Mixed Reality, Смешанная реальность, виртуальная реальность, VR, MR, производительность, оптимизация, ЦП, GPU
ms.openlocfilehash: ce59f9023c21dc7c981a2bb97d9fbd0c57622dbf
ms.sourcegitcommit: 915d3cc63a5571ba22ac4608589f3eca8da1bc81
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/24/2019
ms.locfileid: "63548845"
---
# <a name="understanding-performance-for-mixed-reality"></a><span data-ttu-id="175f2-104">Основные сведения о производительности смешанной реальности</span><span class="sxs-lookup"><span data-stu-id="175f2-104">Understanding performance for mixed reality</span></span>

<span data-ttu-id="175f2-105">Эта статья содержит общие сведения о рационализацию производительности приложения смешанной реальности.</span><span class="sxs-lookup"><span data-stu-id="175f2-105">This article is an introduction into rationalizing the significance of performance for your Mixed Reality app.</span></span>  <span data-ttu-id="175f2-106">Работа пользователей может быть значительно снижена, если приложение не работает с оптимальной частотой кадров.</span><span class="sxs-lookup"><span data-stu-id="175f2-106">User experience can be greatly degraded if your application does not run at optimal frame rate.</span></span> <span data-ttu-id="175f2-107">Голограммы будут отображаться нестабильно, а отслеживание головного окружения будет неточным, что приведет к неудачной работе пользователя.</span><span class="sxs-lookup"><span data-stu-id="175f2-107">Holograms will appear unstable and head tracking of the environment will be inaccurate leading to an poor experience for the user.</span></span> <span data-ttu-id="175f2-108">Действительно, производительность должна рассматриваться как первая функция класса для разработки смешанной реальности, а не стабилизации, задача конца цикла.</span><span class="sxs-lookup"><span data-stu-id="175f2-108">Indeed, performance must be considered as a first class feature for Mixed Reality development and not a stabilization, end of cycle task.</span></span>

<span data-ttu-id="175f2-109">Для проверки, ниже перечислены значения для выполнения частотных кадров для каждой целевой платформы.</span><span class="sxs-lookup"><span data-stu-id="175f2-109">For review, the performant framerate values for each target platform are listed below.</span></span>

| <span data-ttu-id="175f2-110">Платформа</span><span class="sxs-lookup"><span data-stu-id="175f2-110">Platform</span></span> | <span data-ttu-id="175f2-111">Частота целевых кадров</span><span class="sxs-lookup"><span data-stu-id="175f2-111">Target Frame Rate</span></span> |
|----------|-------------------|
| [<span data-ttu-id="175f2-112">HoloLens</span><span class="sxs-lookup"><span data-stu-id="175f2-112">HoloLens</span></span>](hololens-hardware-details.md) | <span data-ttu-id="175f2-113">60 КАДРОВ/С</span><span class="sxs-lookup"><span data-stu-id="175f2-113">60 FPS</span></span> |
| [<span data-ttu-id="175f2-114">Портативные компьютеры Windows Mixed Reality</span><span class="sxs-lookup"><span data-stu-id="175f2-114">Windows Mixed Reality Ultra PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="175f2-115">90 КАДРОВ/С</span><span class="sxs-lookup"><span data-stu-id="175f2-115">90 FPS</span></span> |
| [<span data-ttu-id="175f2-116">Компьютеры Windows Mixed Reality</span><span class="sxs-lookup"><span data-stu-id="175f2-116">Windows Mixed Reality PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="175f2-117">60 КАДРОВ/С</span><span class="sxs-lookup"><span data-stu-id="175f2-117">60 FPS</span></span> |

<span data-ttu-id="175f2-118">Приведенная ниже платформа предоставляет общий обзор рекомендаций и понятий, направленных на достижение целевой частоты кадров.</span><span class="sxs-lookup"><span data-stu-id="175f2-118">The framework below gives a general outline for best practices and understandings towards hitting target frame rates.</span></span> <span data-ttu-id="175f2-119">Чтобы подробно изучить подробности, ознакомьтесь со статьей [рекомендации по производительности для Unity](performance-recommendations-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="175f2-119">To dive further into details, consider reading the [performance recommendations for Unity article](performance-recommendations-for-unity.md).</span></span> <span data-ttu-id="175f2-120">В частности, эта статья посвящена измерению частоты кадров в приложении Windows Mixed Reality в Unity, а также действиям, выполняемым в среде Unity для повышения производительности.</span><span class="sxs-lookup"><span data-stu-id="175f2-120">In particular, this related article will discuss how to measure framerate in your Unity Windows Mixed Reality app as well as steps to take in the Unity environment to improve performance.</span></span>

## <a name="understanding-performance-bottlenecks"></a><span data-ttu-id="175f2-121">Основные сведения о узких местах производительности</span><span class="sxs-lookup"><span data-stu-id="175f2-121">Understanding performance bottlenecks</span></span>

<span data-ttu-id="175f2-122">Если приложение имеет небольшую частоту кадров, первый шаг состоит в анализе и понимании того, где приложение получает ресурсоемкие вычисления.</span><span class="sxs-lookup"><span data-stu-id="175f2-122">If your app has an underperforming framerate, the first step is to analyze and understand where your application is computationally intensive.</span></span> <span data-ttu-id="175f2-123">Существует два основных процессора, ответственных за работу с визуализацией сцены: ЦП и GPU.</span><span class="sxs-lookup"><span data-stu-id="175f2-123">There are two primary processors responsible for the work to render your scene: the CPU and the GPU.</span></span> <span data-ttu-id="175f2-124">Каждый из этих двух компонентов обрабатывает различные операции и этапы приложения смешанной реальности.</span><span class="sxs-lookup"><span data-stu-id="175f2-124">Each of these two components handle different operations and stages of your Mixed Reality app.</span></span> <span data-ttu-id="175f2-125">Существует три основных места, где могут возникнуть узкие места.</span><span class="sxs-lookup"><span data-stu-id="175f2-125">There are three key places where bottlenecks may occur.</span></span> 

1. <span data-ttu-id="175f2-126">**Поток приложения — ЦП** . Этот поток отвечает за логику приложения.</span><span class="sxs-lookup"><span data-stu-id="175f2-126">**App Thread - CPU** - This thread is responsible for your app logic.</span></span> <span data-ttu-id="175f2-127">Это включает обработку входных данных, анимацию, физику и другую логику или состояние приложения.</span><span class="sxs-lookup"><span data-stu-id="175f2-127">This includes processing input, animations, physics, and other app logic/state</span></span>
2. <span data-ttu-id="175f2-128">**Прорисовка потока — ЦП в GPU** — этот поток отвечает за отправку вызовов рисования в GPU.</span><span class="sxs-lookup"><span data-stu-id="175f2-128">**Render Thread - CPU to GPU** - This thread is responsible for submitting your draw calls to the GPU.</span></span> <span data-ttu-id="175f2-129">Когда приложение хочет отобразить объект, например куб или модель, этот поток отправляет в GPU запрос, который имеет оптимизированную для отрисовки архитектуру для выполнения этих операций.</span><span class="sxs-lookup"><span data-stu-id="175f2-129">When your app wants to render an object such as a cube or model, this thread sends a request to the GPU, which has an architecture optimized for rendering, to perform these operations.</span></span>
3. <span data-ttu-id="175f2-130">**GPU** - 
    Этот процессор чаще всего обрабатывает графический конвейер приложения для преобразования трехмерных данных (моделей, текстур и т. д.) в Пиксели и, в конечном итоге, создания 2D-изображения для отправки на экран устройства.</span><span class="sxs-lookup"><span data-stu-id="175f2-130">**GPU** - 
 This processor most commonly handles the graphics pipeline of your application to transform 3D data (models, textures, etc) into pixels and ultimately produce a 2D image to submit to your device's screen.</span></span>

![Время существования кадра](images/lifetime-of-a-frame.png)

<span data-ttu-id="175f2-132">Как правило, приложения HoloLens будут ограничены GPU.</span><span class="sxs-lookup"><span data-stu-id="175f2-132">Generally, HoloLens applications will be GPU bounded.</span></span> <span data-ttu-id="175f2-133">Тем не менее, это не имеет значения true в каждом приложении, поэтому рекомендуется использовать средства & приведенных ниже способов, чтобы приступить к истинности конкретного приложения.</span><span class="sxs-lookup"><span data-stu-id="175f2-133">However, this does not hold true in every application and thus it is recommended to use the tools & techniques below to get to ground-truth for your particular app.</span></span>

## <a name="how-to-analyze-your-application"></a><span data-ttu-id="175f2-134">Анализ приложения</span><span class="sxs-lookup"><span data-stu-id="175f2-134">How to analyze your application</span></span>

<span data-ttu-id="175f2-135">Существует множество средств, позволяющих разработчику понять профиль производительности приложения смешанной реальности.</span><span class="sxs-lookup"><span data-stu-id="175f2-135">There are many tools that allow you as a developer to understand the performance profile of your Mixed Reality application.</span></span> <span data-ttu-id="175f2-136">Это позволит использовать обе цели, на которых имеются узкие места, и как они являются манифестами для их отладки.</span><span class="sxs-lookup"><span data-stu-id="175f2-136">These will enable you to both target where you have bottlenecks and how they are manifesting themselves to debug them.</span></span>

<span data-ttu-id="175f2-137">Это список популярных и мощных средств для получения подробных сведений о профилировании для приложения.</span><span class="sxs-lookup"><span data-stu-id="175f2-137">This is a list of popular and powerful tools to gain deep profiling information for your application.</span></span>
- [<span data-ttu-id="175f2-138">Анализаторы производительности графики Intel</span><span class="sxs-lookup"><span data-stu-id="175f2-138">Intel Graphics Performance Analyzers</span></span>](https://software.intel.com/gpa)
- [<span data-ttu-id="175f2-139">Отладчики графики Visual Studio</span><span class="sxs-lookup"><span data-stu-id="175f2-139">Visual Studio Graphics Debuggers</span></span>](https://docs.microsoft.com/visualstudio/debugger/graphics/visual-studio-graphics-diagnostics?view=vs-2017)
- [<span data-ttu-id="175f2-140">Профилировщик Unity</span><span class="sxs-lookup"><span data-stu-id="175f2-140">Unity Profiler</span></span>](https://docs.unity3d.com/Manual/Profiler.html)
- [<span data-ttu-id="175f2-141">Отладчик фреймов Unity</span><span class="sxs-lookup"><span data-stu-id="175f2-141">Unity Frame Debugger</span></span>](https://docs.unity3d.com/Manual/FrameDebugger.html)

### <a name="how-to-profile-in-any-environment"></a><span data-ttu-id="175f2-142">Профилирование в любой среде</span><span class="sxs-lookup"><span data-stu-id="175f2-142">How to profile in any environment</span></span>

<span data-ttu-id="175f2-143">Существует простой тест для быстрого определения вероятности ограниченного использования GPU или ЦП, ограниченного в приложении.</span><span class="sxs-lookup"><span data-stu-id="175f2-143">There is a simple test to quickly determine if you are likely GPU bounded or CPU bounded in your application.</span></span> <span data-ttu-id="175f2-144">Если вы уменьшите разрешение выходных данных целевого объекта рендеринга, то Вычислите и таким образом меньшее количество пикселей, чтобы GPU выполнялось для отрисовки изображения.</span><span class="sxs-lookup"><span data-stu-id="175f2-144">If you decrease the resolution of the render target output, there are less pixels to calculate and thus, less work the GPU needs to perform to render an image.</span></span> <span data-ttu-id="175f2-145">Масштабирование окна просмотра (динамическое масштабирование разрешения) — это практика отрисовки изображения на меньший целевой объект отрисовки, после чего устройство вывода может быть отображено.</span><span class="sxs-lookup"><span data-stu-id="175f2-145">Viewport scaling (dynamic resolution scaling) is the practice of rendering your image to a smaller render target then your output device can display.</span></span> <span data-ttu-id="175f2-146">Устройство выберет выборку из меньшего набора пикселей, чтобы отобразить окончательный образ.</span><span class="sxs-lookup"><span data-stu-id="175f2-146">The device will up-sample from the smaller set of pixels to display your final image.</span></span>

<span data-ttu-id="175f2-147">После уменьшения разрешения отрисовки, если:</span><span class="sxs-lookup"><span data-stu-id="175f2-147">After decreasing rendering resolution, if:</span></span>
1) <span data-ttu-id="175f2-148">**Увеличение**частоты кадров приложения, скорее всего, **ограниченный GPU**</span><span class="sxs-lookup"><span data-stu-id="175f2-148">Application framerate **increases**, then you are likely **GPU Bounded**</span></span>
1) <span data-ttu-id="175f2-149">Частота кадров приложения не изменилась, скорее всего, **ЦП ограничен**</span><span class="sxs-lookup"><span data-stu-id="175f2-149">Application framerate **unchanged**, then you are likely **CPU Bounded**</span></span>

>[!NOTE]
><span data-ttu-id="175f2-150">Unity предоставляет возможность легко изменять разрешение целевого объекта отрисовки приложения во время выполнения с помощью свойства *[ксрсеттингс. рендервиевпортскале](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* .</span><span class="sxs-lookup"><span data-stu-id="175f2-150">Unity provides the ability to easily modify the render target resolution of your application at runtime through the *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property.</span></span> <span data-ttu-id="175f2-151">Конечный образ, представленный на устройстве, имеет фиксированное разрешение.</span><span class="sxs-lookup"><span data-stu-id="175f2-151">The final image presented on device has a fixed resolution.</span></span> <span data-ttu-id="175f2-152">Платформа будет выполнять выборку выходных данных с низким разрешением для создания изображения более высокого разрешения для отображения на экране.</span><span class="sxs-lookup"><span data-stu-id="175f2-152">The platform will sample the lower resolution output to build a higher resolution image for rendering on displays.</span></span> 
>
>```CS
>UnityEngine.XR.XRSettings.renderScale = 0.7f;
>```

## <a name="how-to-improve-your-application"></a><span data-ttu-id="175f2-153">Как улучшить приложение</span><span class="sxs-lookup"><span data-stu-id="175f2-153">How to improve your application</span></span>

### <a name="cpu-performance-recommendations"></a><span data-ttu-id="175f2-154">Рекомендации по производительности ЦП</span><span class="sxs-lookup"><span data-stu-id="175f2-154">CPU performance recommendations</span></span>

<span data-ttu-id="175f2-155">Как правило, большинство работы в приложении смешанной реальности на ЦП предполагает выполнение "моделирования" сцены и обработку обширной уникальной логики приложения.</span><span class="sxs-lookup"><span data-stu-id="175f2-155">Generally, most work in a mixed reality application on the CPU involves performing the "simulation" of the scene and processing extensive unique application logic.</span></span> <span data-ttu-id="175f2-156">Поэтому следующие области обычно предназначены для оптимизации.</span><span class="sxs-lookup"><span data-stu-id="175f2-156">Thus, the following areas are usually targeted for optimization.</span></span>

- <span data-ttu-id="175f2-157">Анимации</span><span class="sxs-lookup"><span data-stu-id="175f2-157">Animations</span></span>
- <span data-ttu-id="175f2-158">Упрощение Физикы</span><span class="sxs-lookup"><span data-stu-id="175f2-158">Simplify Physics</span></span>
- <span data-ttu-id="175f2-159">Выделение памяти</span><span class="sxs-lookup"><span data-stu-id="175f2-159">Memory allocations</span></span>
- <span data-ttu-id="175f2-160">Сложные алгоритмы (т. е.</span><span class="sxs-lookup"><span data-stu-id="175f2-160">Complex algorithms (i.e</span></span> <span data-ttu-id="175f2-161">Обратная кинематика, поиск по пути)</span><span class="sxs-lookup"><span data-stu-id="175f2-161">inverse kinematics, path-finding)</span></span>

### <a name="gpu-performance-recommendations"></a><span data-ttu-id="175f2-162">Рекомендации по производительности GPU</span><span class="sxs-lookup"><span data-stu-id="175f2-162">GPU performance recommendations</span></span>

#### <a name="understanding-bandwidth-vs-fill-rate"></a><span data-ttu-id="175f2-163">Общие сведения о пропускной способности и скорости заполнения</span><span class="sxs-lookup"><span data-stu-id="175f2-163">Understanding bandwidth vs fill rate</span></span>
<span data-ttu-id="175f2-164">При отрисовке кадра на GPU приложение обычно либо ограничено пропускной способностью памяти, либо скоростью заполнения.</span><span class="sxs-lookup"><span data-stu-id="175f2-164">When rendering a frame on the GPU, an application is generally either bounded by memory bandwidth or fill rate.</span></span>

- <span data-ttu-id="175f2-165">**Пропускная способность памяти** — это частота операций чтения и записи, которую GPU может выполнять из памяти.</span><span class="sxs-lookup"><span data-stu-id="175f2-165">**Memory bandwidth** is the rate of reads and writes the GPU can perform from memory</span></span>
    - <span data-ttu-id="175f2-166">Чтобы определить ограничения пропускной способности, уменьшите качество текстуры и проверьте, увеличилась ли частота кадров.</span><span class="sxs-lookup"><span data-stu-id="175f2-166">To identify bandwidth limitations, reduce texture quality and check if framerate improved.</span></span>
    - <span data-ttu-id="175f2-167">В Unity это можно сделать, изменив **качество текстуры** в окне **изменение** > параметров**проекта** > параметры **[качества](https://docs.unity3d.com/Manual/class-QualitySettings.html)** .</span><span class="sxs-lookup"><span data-stu-id="175f2-167">In Unity, this can be done by changing **Texture Quality** in **Edit** > **Project Settings** > **[Quality Settings](https://docs.unity3d.com/Manual/class-QualitySettings.html)**.</span></span>
- <span data-ttu-id="175f2-168">**Скорость заливки** обозначает пропускную способность отображаемых пикселов, которые могут быть отображены в секунду графическим процессором.</span><span class="sxs-lookup"><span data-stu-id="175f2-168">**Fill rate** refers to the throughput of rendered pixels that can be drawn per second by the GPU.</span></span>
    - <span data-ttu-id="175f2-169">Чтобы определить ограничения скорости заполнения, уменьшите разрешение экрана и проверьте, увеличилась ли частота кадров.</span><span class="sxs-lookup"><span data-stu-id="175f2-169">To identify fill rate limitations, decrease the display resolution and check if framerate improved.</span></span> 
    - <span data-ttu-id="175f2-170">В Unity это можно сделать с помощью свойства *[ксрсеттингс. рендервиевпортскале.](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)*</span><span class="sxs-lookup"><span data-stu-id="175f2-170">In Unity, this can be done via the  *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property</span></span>

<span data-ttu-id="175f2-171">Пропускная способность памяти обычно включает оптимизацию для</span><span class="sxs-lookup"><span data-stu-id="175f2-171">Memory bandwidth generally involves optimizations to either</span></span>
1) <span data-ttu-id="175f2-172">уменьшение разрешений текстуры</span><span class="sxs-lookup"><span data-stu-id="175f2-172">decrease texture resolutions</span></span>
2) <span data-ttu-id="175f2-173">Используйте меньше текстур (например,</span><span class="sxs-lookup"><span data-stu-id="175f2-173">utilize less textures (i.e</span></span> <span data-ttu-id="175f2-174">нормали, блики и т. д.)</span><span class="sxs-lookup"><span data-stu-id="175f2-174">normals, specular, etc)</span></span>

<span data-ttu-id="175f2-175">Скорость заполнения в основном сосредоточена на уменьшении количества операций, которые необходимо вычислить для окончательного визуализированного пикселя.</span><span class="sxs-lookup"><span data-stu-id="175f2-175">Fill rate is primarily focused on reducing the number of operations that need to be computed for a final rendered pixel.</span></span> <span data-ttu-id="175f2-176">Примеры, как правило, попадают в сокращение</span><span class="sxs-lookup"><span data-stu-id="175f2-176">Examples of this commonly fall into reducing</span></span>
1) <span data-ttu-id="175f2-177">число объектов для отрисовки или обработки</span><span class="sxs-lookup"><span data-stu-id="175f2-177">number of objects to render/process</span></span>
2) <span data-ttu-id="175f2-178">число операций на шейдер</span><span class="sxs-lookup"><span data-stu-id="175f2-178">number of operations per shader</span></span>
3) <span data-ttu-id="175f2-179">число стадий GPU до окончательного результата (геометрические шейдеры, эффекты последующей обработки и т. д.)</span><span class="sxs-lookup"><span data-stu-id="175f2-179">number of GPU stages to final result (geometry shaders, post-processing effects, etc)</span></span>
4) <span data-ttu-id="175f2-180">число пикселей для отрисовки (например,</span><span class="sxs-lookup"><span data-stu-id="175f2-180">number of pixels to render (i.e</span></span> <span data-ttu-id="175f2-181">разрешение экрана)</span><span class="sxs-lookup"><span data-stu-id="175f2-181">display resolution)</span></span>

#### <a name="reduce-poly-count"></a><span data-ttu-id="175f2-182">Сокращение числа поли</span><span class="sxs-lookup"><span data-stu-id="175f2-182">Reduce poly count</span></span>
<span data-ttu-id="175f2-183">Чем больше число многоугольников, тем больше операций для GPU и сокращение количества многоугольников в сцене сокращает время, необходимое для визуализации этой геометрии.</span><span class="sxs-lookup"><span data-stu-id="175f2-183">Higher polygon counts result in more operations for the GPU and reducing the number of polygons in your scene will reduce the amount of time to render that geometry.</span></span> <span data-ttu-id="175f2-184">Существуют и другие факторы, связанные с заливкой геометрии, который по-прежнему может быть дорогостоящим, но количество многоугольников — это базовая метрика, позволяющая определить частоту визуализации сцены.</span><span class="sxs-lookup"><span data-stu-id="175f2-184">There are other factors involved as well in shading the geometry that can still be expensive but polygon count is the base metric to determine how expensive a scene will be to render.</span></span>

#### <a name="limit-overdraw"></a><span data-ttu-id="175f2-185">Ограничить перерисовку</span><span class="sxs-lookup"><span data-stu-id="175f2-185">Limit overdraw</span></span>

<span data-ttu-id="175f2-186">Высокая перерисовка происходит, когда несколько объектов визуализируются, но не выводятся на экран, так как они скрыты другим, как правило, ближе к окклудинг объекту.</span><span class="sxs-lookup"><span data-stu-id="175f2-186">High overdraw occurs when multiple objects are rendered but not outputted to the screen as they are hidden by another, generally closer, occluding object.</span></span> <span data-ttu-id="175f2-187">Представьте себе, что вы просматриваете стену с несколькими комнатами и геометрическим объектом.</span><span class="sxs-lookup"><span data-stu-id="175f2-187">Imagine looking at a wall that had multiple rooms and geometry behind it.</span></span> <span data-ttu-id="175f2-188">Все геометрические данные будут обрабатываться для отрисовки, но только непрозрачная стенка действительно должна быть визуализирована, так как она окклудес представление всего другого содержимого.</span><span class="sxs-lookup"><span data-stu-id="175f2-188">All of the geometry would be processed for rendering but only the opaque wall really needs to be rendered as it occludes the view of all other content.</span></span> <span data-ttu-id="175f2-189">Это приводит к операциям непроизводительна, которые не требуются для текущего представления.</span><span class="sxs-lookup"><span data-stu-id="175f2-189">This results in wasteful operations that are not needed for the current view.</span></span>

#### <a name="shaders"></a><span data-ttu-id="175f2-190">Шейдеры</span><span class="sxs-lookup"><span data-stu-id="175f2-190">Shaders</span></span>

<span data-ttu-id="175f2-191">Шейдер — это небольшие программы, которые работают на GPU и обычно определяют два важных шага при подготовке к просмотру:</span><span class="sxs-lookup"><span data-stu-id="175f2-191">Shaders are small programs that run on the GPU and generally determine two important steps in rendering:</span></span>
1) <span data-ttu-id="175f2-192">какие вершины объекта должны отображаться на экране и где они находятся в пространстве экрана (т. е.</span><span class="sxs-lookup"><span data-stu-id="175f2-192">which object's vertices should be drawn on the screen and where they are in screen space (i.e</span></span> <span data-ttu-id="175f2-193">Шейдер вершин)</span><span class="sxs-lookup"><span data-stu-id="175f2-193">the Vertex shader)</span></span>
    - <span data-ttu-id="175f2-194">Обычно шейдер вершин выполняется на вершину для каждого GameObject</span><span class="sxs-lookup"><span data-stu-id="175f2-194">The Vertex shader is generally executed per vertex for every GameObject</span></span>
2) <span data-ttu-id="175f2-195">цвет этих пикселов (например,</span><span class="sxs-lookup"><span data-stu-id="175f2-195">what to color those pixels (i.e</span></span> <span data-ttu-id="175f2-196">шейдер пикселей)</span><span class="sxs-lookup"><span data-stu-id="175f2-196">the Pixel shader)</span></span>
    - <span data-ttu-id="175f2-197">Построитель текстуры выполняется на пиксель для визуализации текстуры, представленной для устройства</span><span class="sxs-lookup"><span data-stu-id="175f2-197">The Pixel shader is executed per pixel for the texture being rendered for device present</span></span>

<span data-ttu-id="175f2-198">Обычно шейдеры выполняют много преобразований и вычислений освещения.</span><span class="sxs-lookup"><span data-stu-id="175f2-198">Typically shaders perform many transformations and lighting calculations.</span></span> <span data-ttu-id="175f2-199">Хотя сложные модели освещения, тени и другие операции могут создавать отличные результаты, они также поставляются с ценой.</span><span class="sxs-lookup"><span data-stu-id="175f2-199">Although complex lighting models, shadows, and other operations can generate fantastic results, they also come with a price.</span></span> <span data-ttu-id="175f2-200">Уменьшение числа операций, вычисленных в шейдере, может значительно снизить общую работу, необходимую для графического процессора на кадр.</span><span class="sxs-lookup"><span data-stu-id="175f2-200">Reducing the number of operations computed in shaders can greatly reduce the overall work needed to be done by a GPU per frame.</span></span>

##### <a name="shader-coding-recommendations"></a><span data-ttu-id="175f2-201">Рекомендации по кодированию шейдера</span><span class="sxs-lookup"><span data-stu-id="175f2-201">Shader coding recommendations</span></span>

- <span data-ttu-id="175f2-202">Использовать фильтрацию билинейной везде, где это возможно</span><span class="sxs-lookup"><span data-stu-id="175f2-202">Use bilinear filtering whenever possible</span></span>
- <span data-ttu-id="175f2-203">Переупорядочение выражений для использования встроенных функций MAD для умножения и добавления в одно и то же время</span><span class="sxs-lookup"><span data-stu-id="175f2-203">Rearrange expressions to use MAD intrinsics in order to do a multiply and an add at the same time</span></span>
- <span data-ttu-id="175f2-204">Предварительно вычислить как можно больше ресурсов ЦП и передать его в качестве констант в материал</span><span class="sxs-lookup"><span data-stu-id="175f2-204">Precalculate as much as possible on the CPU and pass as constants to the material</span></span>
- <span data-ttu-id="175f2-205">**Предпочитать операции перемещения из шейдера пикселей к шейдеру вершин**</span><span class="sxs-lookup"><span data-stu-id="175f2-205">**Favor moving operations from the pixel shader to the vertex shader**</span></span>
    - <span data-ttu-id="175f2-206">Обычно число вершин < < количество пикселей (т. е.</span><span class="sxs-lookup"><span data-stu-id="175f2-206">Generally the # of vertices << # of pixels (i.e</span></span> <span data-ttu-id="175f2-207">720p = = 921 600 пикселей, 1080p = = 2 073 600 пикселей и т. д.)</span><span class="sxs-lookup"><span data-stu-id="175f2-207">720p == 921,600 pixels, 1080p == 2,073,600 pixels, etc)</span></span>

#### <a name="remove-gpu-stages"></a><span data-ttu-id="175f2-208">Удалить этапы GPU</span><span class="sxs-lookup"><span data-stu-id="175f2-208">Remove GPU stages</span></span>
<span data-ttu-id="175f2-209">Результаты последующей обработки могут быть очень ресурсоемкими и, как правило, отменяют скорость заполнения приложения.</span><span class="sxs-lookup"><span data-stu-id="175f2-209">Post-processing effects can be very expensive and generally inhibit the fill rate of your application.</span></span> <span data-ttu-id="175f2-210">Сюда также входят методики сглаживания, такие как MSAA.</span><span class="sxs-lookup"><span data-stu-id="175f2-210">This also includes anti-aliasing techniques such as MSAA.</span></span> <span data-ttu-id="175f2-211">В HoloLens рекомендуется избегать использования этих методов полностью.</span><span class="sxs-lookup"><span data-stu-id="175f2-211">On HoloLens, it is recommended to avoid these techniques entirely.</span></span> <span data-ttu-id="175f2-212">Более того, когда это возможно, следует избегать дополнительных этапов шейдера, таких как геометрические объекты, поверхности и шейдеры вычислений.</span><span class="sxs-lookup"><span data-stu-id="175f2-212">Furthermore, additional shader stages such as geometry, hull, and compute shaders should be avoided when possible.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="175f2-213">Рекомендации по использованию памяти</span><span class="sxs-lookup"><span data-stu-id="175f2-213">Memory recommendations</span></span>
<span data-ttu-id="175f2-214">Чрезмерное выделение памяти & операциях изъятия может оказать негативное влияние на работу с holographic, что приведет к нестабильной производительности, замороженным кадрам и другим негативным последствиям.</span><span class="sxs-lookup"><span data-stu-id="175f2-214">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="175f2-215">Особенно важно понимать требования к памяти при разработке в Unity, так как управление памятью управляется сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="175f2-215">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="175f2-216">Объединение объектов в пул</span><span class="sxs-lookup"><span data-stu-id="175f2-216">Object pooling</span></span>

<span data-ttu-id="175f2-217">Использование пулов объектов — популярная методика снижения затрат на непрерывное выделение памяти & освобождением объектов.</span><span class="sxs-lookup"><span data-stu-id="175f2-217">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="175f2-218">Это делается путем выделения большого пула идентичных объектов и повторного использования неактивных, доступных экземпляров из этого пула вместо постоянного создания и уничтожения объектов с течением времени.</span><span class="sxs-lookup"><span data-stu-id="175f2-218">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="175f2-219">Пулы объектов отлично подходят для повторного создания компонентов, которые имеют переменное время существования во время выполнения приложения.</span><span class="sxs-lookup"><span data-stu-id="175f2-219">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

## <a name="see-also"></a><span data-ttu-id="175f2-220">См. также</span><span class="sxs-lookup"><span data-stu-id="175f2-220">See also</span></span>
- [<span data-ttu-id="175f2-221">Рекомендации по производительности для Unity</span><span class="sxs-lookup"><span data-stu-id="175f2-221">Performance recommendations for Unity</span></span>](performance-recommendations-for-unity.md)
- [<span data-ttu-id="175f2-222">Рекомендуемые параметры для Unity</span><span class="sxs-lookup"><span data-stu-id="175f2-222">Recommended settings for Unity</span></span>](recommended-settings-for-unity.md)
