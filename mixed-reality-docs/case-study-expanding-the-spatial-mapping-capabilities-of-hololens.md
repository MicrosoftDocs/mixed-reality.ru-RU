---
title: Пример использования - расширением пространственных сопоставление возможностей HoloLens
description: При создании наши первого приложения для Microsoft HoloLens, мы были рады увидеть, насколько просто можно передать границы пространственное сопоставление на устройстве.
author: jevertt
ms.author: jevertt
ms.date: 03/21/2018
ms.topic: article
keywords: Пространственное сопоставление Windows Mixed Reality, HoloLens,
ms.openlocfilehash: 602b629afa5900ff34c28b3a3a32725af06590b7
ms.sourcegitcommit: 384b0087899cd835a3a965f75c6f6c607c9edd1b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/12/2019
ms.locfileid: "59602836"
---
# <a name="case-study---expanding-the-spatial-mapping-capabilities-of-hololens"></a>Пример использования - расширением пространственных сопоставление возможностей HoloLens

При создании наши первого приложения для Microsoft HoloLens, мы были рады увидеть, насколько просто можно передать границы пространственное сопоставление на устройстве. Джефф Evertt, инженер по в Microsoft Studios, объясняет, как это новая технология была разработана из потребность в больший контроль над размещение голограммы в реальной среде пользователя.

## <a name="watch-the-video"></a>Просмотрите видео

>[!VIDEO https://www.youtube.com/embed/iUmTi3_Ynus]

## <a name="beyond-spatial-mapping"></a>Помимо пространственное сопоставление

Хотя мы работали над [фрагментов](https://www.microsoft.com/p/fragments/9nblggh5ggm8) и [Young Conker](https://www.microsoft.com/p/young-conker/9nblggh5ggk1), два первой игры для HoloLens, мы обнаружили, что когда мы создавали процедурного размещение голограммы в физическом мире, нам нужно более высокого уровня понимания о среде пользователя. Каждая игра была потребностям конкретного размещения: Во фрагментах, например, мы хотели бы иметь возможность различать между различными поверхностями — например ближайшее снизу целое или таблице — для размещения подсказки в интересующих нас мест. Мы также хотели бы иметь возможность идентифицировать поверхности бездействию life-size holographic символов может, например диване или стула. В Conker Young нам нужно было Conker и его противников, чтобы иметь возможность использовать вызванное поверхности в комнате игрока в качестве платформы.

[Asobo Studios](http://www.asobostudio.com/index.html), наш партнер по разработке для этих игр сталкиваются решает эту проблему и создать это технология, которая расширяет возможности сопоставления пространственных HoloLens. Используя эту возможность, мы может анализ игрока комнаты и определение поверхности, например стены, таблицы, стульев и пол. Оно также дало нам возможность оптимизировать с набором ограничений для определения размещения holographic объектов.

## <a name="the-spatial-understanding-code"></a>Пространственные понимание кода

Мы заняло Asobo в исходный код и создали библиотеку, которая инкапсулирует этой технологии. Корпорация Майкрософт и Asobo теперь открытый исходный код этого кода и делает ее доступной на [MixedRealityToolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity/tree/htk_release/Assets/HoloToolkit/SpatialMapping) для использования в собственных проектах. Весь исходный код включается, позволяя настраивать его под свои нужды и поделиться с сообществом улучшений. Код для C++ средства поиска решения в оболочку в библиотеку DLL для универсальной платформы Windows и доступ к Unity с [prefab сборка, содержащихся в MixedRealityToolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity/tree/htk_release/Assets/HoloToolkit-Examples/SpatialUnderstanding).

Существует множество полезных запросов, входящей в состав примера Unity, вы сможете найти свободное место на стене, поместите объекты на ближайшее сверху целое или большие пробелы в условиях, определить, для символов средством обработки и множество других запросов пространственных основные сведения о.

Хотя решение пространственное сопоставление, предоставляемые HoloLens предназначен быть универсальными, в соответствии с потребностями весь спектр пространства состояний, пространственных основные сведения о модуле была создана для поддержки потребностей два игр. Таким образом его решение рассматриваются специфические идентификаторы процессов и набор предположения:
* **Фиксированного размера playspace**: Пользователь задает размер максимального playspace в вызове метода init.
* **Процесс однократную проверку**: Этот процесс требует дискретный определение playspace, сканирование этап, когда пользователь выходит вокруг. Функции запросов, не будут работать до, после проверки завершена.
* **Управляемая playspace «рисование» пользователем**: Во время фазы сканирования пользователь перемещает и ищет вокруг playspace эффективно закрашивание области, которые должны быть включены. Отзыв пользователя на этом этапе важно созданный сетки.
* **Улице домашней или офисной установки**: Функции запросов разрабатываются на основе плоскими поверхностями и стены под прямым углом. Это мягкое ограничение. Однако во время фазы сканирования анализа основной оси выполняется для оптимизации тесселяции сетки на основной и вспомогательной оси.

### <a name="room-scanning-process"></a>Процесс сканирования комнаты

При загрузке модуля пространственных понимание первое, что вы сделаете — сканирования сферы, так что все также можно использовать областей — например floor, ceiling и стен — идентифицируются и с меткой. В процессе сканирования оглядитесь комнате и «paint "области, которые должны быть включены во время проверки.

Сетки, которая происходит во время этого этапа является важной характеристикой визуальную обратную связь, которая дает пользователям понять, какие части комнаты выполняется сканирование. Библиотеки DLL для пространственных основные сведения о модуле внутреннее хранение playspace как сетка 8cm размера voxel кубов. Во время начальной части сканирования завершения анализа основного компонента для определения осей комнаты. Внутри он хранит пространства voxel, выровненным по этим осям. Сетка создается приблизительно каждую секунду путем извлечения isosurface voxel тома.

![Пространственные сопоставление сетки белого цвета и понимание playspace mesh зеленым цветом](images/spatial-mapping-500px.png)

Пространственные сопоставление сетки белого цвета и понимание playspace mesh зеленым цветом



Включаемый файл SpatialUnderstanding.cs управляет процессом сканирования этапа. Он вызывает следующие функции:
* **SpatialUnderstanding_Init**: Вызывается один раз в начале.
* **GeneratePlayspace_InitScan**: Указывает, что должно начинаться на этапе проверки.
* **GeneratePlayspace_UpdateScan_DynamicScan**: Вызывается каждого кадра, чтобы обновить процесс сканирования. Положение камеры и ориентацию переданный и используется для playspace рисования, описанный выше процесс.
* **GeneratePlayspace_RequestFinish**: Вызывается для завершения playspace. Области «закрасить» на этапе проверки будут использованы для определения и заблокировать playspace. Приложение может запросить статистику во время сканирования этапа, а также запроса пользовательского сетки для предоставления отзывов пользователей.
* **Import_UnderstandingMesh**: Во время сканирования, **SpatialUnderstandingCustomMesh** поведение модулем и помещаются в prefab понимание будет периодически опрашивает процессом пользовательского сетки. Кроме того это делается еще раз после завершения сканирования.

Сканирования потока, обусловленных **SpatialUnderstanding** вызовы поведение **InitScan**, затем **UpdateScan** каждого кадра. При разумным покрытия отчете статистики запроса, пользователь может airtap для вызова **RequestFinish** для указания на конец фазы сканирования. **UpdateScan** по-прежнему вызываться, пока он не возвращаемое значение указывает, что библиотека DLL завершило обработку.

## <a name="the-queries"></a>Запросы

Когда сканирование будет закончено, можно получить доступ к три различных типа запросов в интерфейсе:
* **Топология запросов**: Это быстрое выполнение запросов, которые основываются на топологии отсканированные комнаты.
* **Формирование запросов**: Они используют результаты запросов топологии для поиска по горизонтали поверхностях, расположенных хорошего соответствия среди пользовательских фигур, определенных вами.
* **Запросы на размещение объектов**: Это более сложные запросы, найти наилучшее расположение, на основе набора правил и ограничений для объекта.

Помимо трех запросов основной интерфейс точные точки для отслеживания, который может использоваться для извлечения с тегами типы поверхностей и пользовательских watertight место сетки может быть скопирован обратно.

### <a name="topology-queries"></a>Топология запросов

В этой библиотеке DLL диспетчера топологии обрабатывает пометки среды. Как упоминалось выше, большая часть данных хранится в surfels, в которой содержатся в томе voxel. Кроме того **PlaySpaceInfos** структура используется для хранения сведений о playspace, включая выравнивание по всему миру (Дополнительные сведения об этом ниже), floor и ceiling высоты.

Эвристики для определения floor, ceiling и стены. Например максимальный и минимальный горизонтальный поверхности с более чем 1 m2 контактную зону считается ближайшее снизу целое. Обратите внимание на то, что путь камеры во время сканирования также используется в этом процессе.

Подмножество запросов, предоставляемых диспетчера топологии предоставляются посредством библиотеки DLL. Ниже приведены запросы предоставляемого топологии.
* QueryTopology_FindPositionsOnWalls
* QueryTopology_FindLargePositionsOnWalls
* QueryTopology_FindLargestWall
* QueryTopology_FindPositionsOnFloor
* QueryTopology_FindLargestPositionsOnFloor
* QueryTopology_FindPositionsSittable

Каждый из запросов имеет набор параметров, зависящие от типа запроса. В следующем примере пользователь указывает минимальную высоту и ширину нужного тома, высота минимальное размещения выше ближайшее снизу целое и минимальный объем зазор перед тома. Все измерения, в метрах.




```
EXTERN_C __declspec(dllexport) int QueryTopology_FindPositionsOnWalls(
          _In_ float minHeightOfWallSpace,
          _In_ float minWidthOfWallSpace,
          _In_ float minHeightAboveFloor,
          _In_ float minFacingClearance,
          _In_ int locationCount,
          _Inout_ Dll_Interface::TopologyResult* locationData)
```

Каждый из запросов принимает предварительно выделить массив **TopologyResult** структуры. **LocationCount** параметр указывает длину переданный массив. Возвращаемое значение сообщает количество возвращаемых расположений. Это число больше никогда не передается в **locationCount** параметра.

**TopologyResult** содержит центральную позицию возвращаемого тома, разворота направления (т. е. обычные) и размеры найден пространства.




```
struct TopologyResult
     {
          DirectX::XMFLOAT3 position;
          DirectX::XMFLOAT3 normal;
          float width;
          float length;
     };
```

Обратите внимание, что в образце Unity, каждый из этих запросов связанного к кнопке панели виртуального пользовательского интерфейса. Пример жестких коды параметры для каждого из этих запросов, приемлемые значения. См. в разделе *SpaceVisualizer.cs* в образце кода Дополнительные примеры.

### <a name="shape-queries"></a>Запросы фигуры

Внутри библиотеки DLL, анализатор фигуры (**ShapeAnalyzer_W**) использует анализатор топологии для сравнения пользовательские фигуры, определенные пользователем. Пример Unity содержит предварительно определенный набор фигур, которые отображаются в меню запрос, на вкладке "Фигура".

Обратите внимание на то, что анализ фигуры работает на горизонтальной поверхностях только. Диване, например, определяется области неструктурированных рабочих мест и плоский вверху диване обратно. Запроса shape выполняет поиск двух областей определенного размера, высоту и аспект диапазона, с помощью двух областей выравнивается и подключен. С помощью API-интерфейсы терминология, рабочих диване мест и верхней границей в конец диване являются фигуры компонентов и выравнивание, требования ограниченность компонентов фигуры.

Пример запроса, определенные в образце Unity (**ShapeDefinition.cs**), «sittable» объектов, выглядит следующим образом:




```
shapeComponents = new List<ShapeComponent>()
     {
          new ShapeComponent(
               new List<ShapeComponentConstraint>()
               {
                    ShapeComponentConstraint.Create_SurfaceHeight_Between(0.2f, 0.6f),
                    ShapeComponentConstraint.Create_SurfaceCount_Min(1),
                    ShapeComponentConstraint.Create_SurfaceArea_Min(0.035f),
               }),
     };
     AddShape("Sittable", shapeComponents);
```

Каждый запрос фигуры определяется набор компонентов фигуры, каждая из которых набор ограниченность компонентов и ряд ограничений фигуры, которые перечислены зависимости между компонентами. Этот пример включает три ограничения в определении один компонент и нет ограничений фигуры между компонентами (так как существует только один компонент).

Напротив диване фигура имеет два компонента фигуры и четыре ограничения фигуры. Обратите внимание на то, что компоненты идентифицируются по их индекс в списке компонентов пользователя (0 и 1 в этом примере).




```
shapeConstraints = new List<ShapeConstraint>()
        {
              ShapeConstraint.Create_RectanglesSameLength(0, 1, 0.6f),
              ShapeConstraint.Create_RectanglesParallel(0, 1),
              ShapeConstraint.Create_RectanglesAligned(0, 1, 0.3f),
              ShapeConstraint.Create_AtBackOf(1, 0),
        };
```

Функции-оболочки предоставляются в модуле Unity для упрощенного создания пользовательской фигуры определений. Полный список ограничений компонента и фигуры можно найти в **SpatialUnderstandingDll.cs** в **ShapeComponentConstraint** и **ShapeConstraint** структуры.

![Синий прямоугольник выделяет результаты запроса shape кресло.](images/chair-shape-query-500px.png)

Синий прямоугольник выделяет результаты запроса shape кресло.



### <a name="object-placement-solver"></a>Поиск решения для размещения объекта

Объект размещения запросы могут использоваться для обозначения идеальный расположений в физических комнаты для размещения ваших объектов. Поиск будет найти наилучшее расположение, заданное объектом правила и ограничения. Кроме того, запросы объектов действовать, пока объект удаляется с **Solver_RemoveObject** или **Solver_RemoveAllObjects** вызовы, позволяя ограниченное размещение нескольких объектов.

Объект размещения запросы состоят из трех частей: тип размещения с параметрами, список правил и список ограничений. Чтобы выполнить запрос, используйте следующие API:




```
public static int Solver_PlaceObject(
                [In] string objectName,
                [In] IntPtr placementDefinition,    // ObjectPlacementDefinition
                [In] int placementRuleCount,
                [In] IntPtr placementRules,         // ObjectPlacementRule
                [In] int constraintCount,
                [In] IntPtr placementConstraints,   // ObjectPlacementConstraint
                [Out] IntPtr placementResult)
```
Эта функция принимает имя объекта, определение размещения и список правил и ограничений. C# Оболочки предоставляют конструкции, вспомогательные функции для упрощения создания правила и ограничения. Определение размещения содержит тип запроса — то есть одно из следующих:




```
public enum PlacementType
                {
                    Place_OnFloor,
                    Place_OnWall,
                    Place_OnCeiling,
                    Place_OnShape,
                    Place_OnEdge,
                    Place_OnFloorAndCeiling,
                    Place_RandomInAir,
                    Place_InMidAir,
                    Place_UnderFurnitureEdge,
                };
```

Каждый из типов размещения имеет набор параметров, уникальный в тип. **ObjectPlacementDefinition** структура содержит набор статических вспомогательных функций для создания этих определений. Например чтобы найти место для размещения объекта в процессе установки, можно использовать следующую функцию: 


```
public static ObjectPlacementDefinition Create_OnFloor(Vector3 halfDims)
```

Помимо размещения типа могут предоставить набор правил и ограничений. Правила не может быть нарушено. Возможное размещение расположения, которые удовлетворяют типа и правила, затем оптимизируются с набором ограничений для выбора расположения оптимальное размещение. Каждый из правила и ограничения могут создаваться предоставленный создания статических функций. Ниже приведен пример правила и ограничения создания такой функции.




```
public static ObjectPlacementRule Create_AwayFromPosition(
                    Vector3 position, float minDistance)
               public static ObjectPlacementConstraint Create_NearPoint(
                    Vector3 position, float minDistance = 0.0f, float maxDistance = 0.0f)
```

Ниже запроса размещения объектов требуется поместить половину измерения куба на края поверхности, от других ранее разместить объекты и рядом с центром комнаты.




```
List<ObjectPlacementRule> rules = 
          new List<ObjectPlacementRule>() {
               ObjectPlacementRule.Create_AwayFromOtherObjects(1.0f),
          };

     List<ObjectPlacementConstraint> constraints = 
          new List<ObjectPlacementConstraint> {
               ObjectPlacementConstraint.Create_NearCenter(),
          };

     Solver_PlaceObject(
          “MyCustomObject”,
          new ObjectPlacementDefinition.Create_OnEdge(
          new Vector3(0.25f, 0.25f, 0.25f), 
          new Vector3(0.25f, 0.25f, 0.25f)),
          rules.Count,
          UnderstandingDLL.PinObject(rules.ToArray()),
          constraints.Count,
          UnderstandingDLL.PinObject(constraints.ToArray()),
          UnderstandingDLL.GetStaticObjectPlacementResultPtr());
```

В случае успешного выполнения **ObjectPlacementResult** возвращается структура, содержащая позицию, измерения и ориентацию. Кроме того размещение добавляется внутренний список размещенных объектов для библиотеки DLL. Размещение последующие запросы будут учитывать этот объект. **LevelSolver.cs** файл в образце Unity содержит дополнительные примеры запросов.

![Синие — результат из трех запросов Floor на месте с правилами «немедленно из позиции камеры».](images/away-from-camera-position-500px.png)

Синие — результат из трех запросов Floor на месте с правилами «немедленно из позиции камеры».


**Советы:**
* Решения для расположения размещения нескольких объектов, необходимые для уровня или приложение сценария, следует сначала разрешить незаменимым и больших объектов, чтобы максимально увеличить вероятность того, что можно найти пробел.
* Важен порядок размещения. Если не удается найти объект размещения, попробуйте менее ограниченного конфигураций. Набор настроек резервирования важно для поддержки функциональности в конфигурациях с много места.

### <a name="ray-casting"></a>Рэй приведения

Помимо трех запросов основной интерфейсом Рэй приведения может использоваться для извлечения с тегами поверхности типов и пользовательских watertight playspace сетки можно скопировать out после комнате сканирования и завершает работу, метки внутренне создаются для поверхности, например FLOOR, ceiling и стены. **PlayspaceRaycast** функция принимает луч и возвращает значение, если луч конфликтует с известных поверхность и если да, сведения, которые отображаются в виде **RaycastResult**. 


```
struct RaycastResult
     {
          enum SurfaceTypes
          {
               Invalid, // No intersection
               Other,
               Floor,
               FloorLike,         // Not part of the floor topology, 
                                  //     but close to the floor and looks like the floor
               Platform,          // Horizontal platform between the ground and 
                                  //     the ceiling
               Ceiling,
               WallExternal,
               WallLike,          // Not part of the external wall surface, 
                                  //     but vertical surface that looks like a 
                                  //    wall structure
               };
               SurfaceTypes SurfaceType;
               float SurfaceArea;   // Zero if unknown 
                                        //  (i.e. if not part of the topology analysis)
               DirectX::XMFLOAT3 IntersectPoint;
               DirectX::XMFLOAT3 IntersectNormal;
     };
```

На внутреннем уровне raycast вычисляется с представлением playspace voxel вычисляемый 8cm, в кубе. Каждый voxel содержит набор поверхности элементами и данными обработанные топологии (также известный как surfels). Сравниваются surfels, содержащихся в ячейке пересекаемых voxel, наиболее подходящий, используемый для поиска сведений о топологии. Эти данные топологии содержит такой параметр возвращается в виде **SurfaceTypes** перечисления, а также контактную зону поверхности пересекаемых.

В этом примере Unity курсора приводит луча каждого кадра. Во-первых от Unity colliders; Во-вторых от модуля общее представление о мире представления; и наконец, для элементов пользовательского интерфейса. В этом приложении пользовательского интерфейса получает приоритет, а затем результат понимание и, наконец, Unity colliders. **SurfaceType** сообщается как текст рядом с курсором.

![Результат Raycast reporting пересечение с ближайшее снизу целое.](images/raycast-result-500px.jpg)

Результат Raycast reporting пересечение с ближайшее снизу целое.


## <a name="get-the-code"></a>Получите код

Открыть исходный код доступен в [MixedRealityToolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity). Сообщите нам об этом [форумы разработчиков HoloLens](https://forums.hololens.com/) при использовании кода в проекте. Мы очень хотим узнать, что делать с ним!

## <a name="about-the-author"></a>Об авторе

<table style="border:0;width:800px">
<tr>
<td style="border:0"> <img alt="Jeff Evertt, Software Engineering Lead at Microsoft" width="200" height="205" src="images/jeff-evertt-200px.jpg" /></td><td style="border:0"> <b>Джефф Evertt</b> является руководителем разработки программного обеспечения, кто участвовал в разработке HoloLens с первых дней из руковожу к разработке приложений. До HoloLens он работал на Kinect для Xbox и в отрасли игры на различных платформах и игр. Джефф полон энтузиазма по поводу robotics, графики и вещи с помощью мигающие, которые необходимо выполнить звукового сигнала. Он увлекается изучали новые и работа в программном обеспечении и оборудовании и особенно в место, где пересекаются.</td>
</tr>
</table>



## <a name="see-also"></a>См. также
* [Пространственное сопоставление](spatial-mapping.md)
* [Пространственное сопоставление конструктора](spatial-mapping-design.md)
* [Визуализация сканирования комнаты](room-scan-visualization.md)
* [MixedRealityToolkit-Unity](https://github.com/Microsoft/MixedRealityToolkit-Unity)
* [Asobo Studio: Уроки из оказался разработки HoloLens](http://www.gamesindustry.biz/articles/2016-05-12-asobo-lessons-from-the-frontline-of-ar-development)
