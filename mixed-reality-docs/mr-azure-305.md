---
title: Г-н и 305 Azure — функции и хранилища
description: Выполните этот курс, чтобы узнать, как реализовать приложение смешанной реальности хранилища Azure и функций.
author: drneil
ms.author: jemccull
ms.date: 07/04/2018
ms.topic: article
keywords: Azure, смешанной реальности, academy, unity, учебник, api, функции, хранилища, hololens, создающий эффект присутствия, виртуальной реальности
ms.openlocfilehash: a828c7f0ac3016462f5c7e874545bf50a2db6771
ms.sourcegitcommit: 384b0087899cd835a3a965f75c6f6c607c9edd1b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/12/2019
ms.locfileid: "59598299"
---
>[!NOTE]
>Учебники Academy реальности Mixed были разработаны с HoloLens (1-го поколения) и смешанной реальности Иммерсивную в виду.  Таким образом мы думаем, что это важно, чтобы эти учебники на месте для разработчиков, которые по-прежнему необходимы сведения при разработке приложений для этих устройств.  Эти руководства будут **_не_** дополняться последние наборы инструментов или взаимодействия, используемых для HoloLens 2.  Они будут сохранены, чтобы продолжить работу на поддерживаемых устройствах. Будет существовать новую серию учебников, которые будут опубликованы в будущем, демонстрируют способ разработки для HoloLens 2.  Это уведомление будет обновляться со ссылкой на эти руководства, когда они учитываются.

<br> 

# <a name="mr-and-azure-305-functions-and-storage"></a>Г-н и Azure 305: Функции и хранилища

![конечный продукт-запуск](images/AzureLabs-Lab5-00.png)

В рамках этого курса вы узнаете, как создать и использовать функции Azure и хранить данные с ресурса службы хранилища Azure, в приложении смешанной реальности.

*Функции Azure* является служба, которая позволяет разработчикам запускать небольшие фрагменты кода, «», в функциях Azure. Это позволяет делегировать работу в облаке, а не локального приложения, который может иметь множество преимуществ. *Функции Azure* поддерживает несколько языков разработки, в том числе C\#, F\#, Node.js, Java и PHP. Дополнительные сведения см. в статье ["функции Azure" статьи](https://docs.microsoft.com/azure/azure-functions/functions-overview).

*Служба хранилища Azure* — это облачная служба Microsoft, которая позволяет разработчикам хранить данные с страхования, что он будет высокодоступных, безопасной, устойчивой, масштабируемой и избыточных. Это означает, что Майкрософт будет обрабатывать все техническое обслуживание и критические проблемы для вас. Дополнительные сведения см. в статье [статье хранилища Azure](https://docs.microsoft.com/azure/storage/common/storage-introduction).

После выполнения этого курса, у вас будет приложение иммерсивных гарнитуры смешанной реальности, которое сможет выполнить следующие:

1.  Разрешает пользователю помощи вокруг сцены.
2.  Активируйте, запускающая объектов, когда пользователь gazes в трехмерной «button».
3.  Порожденный объекты выбирается с помощью функции Azure.
4.  Так как каждый объект порождается, приложение сохранит тип объекта в *файлов Azure*, который находится в *хранилища Azure*.
5.  После загрузки второй раз, *файлов Azure* данные будут получены и использован для воспроизведения порождающих действия из предыдущего экземпляра приложения.

В приложении зависит от пользователя о том, как интегрировать результаты проектированию. Этот курс призван научить позволяют интегрировать службу Azure с проектом Unity. Это задания для использования знания, полученные в результате этот курс поможет вам улучшить ваши приложения для смешанной реальности.

## <a name="device-support"></a>Поддержка устройств

<table>
<tr>
<th>Курс</th><th style="width:150px"> <a href="hololens-hardware-details.md">HoloLens</a></th><th style="width:150px"> <a href="immersive-headset-hardware-details.md">Иммерсивную</a></th>
</tr><tr>
<td>Г-н и Azure 305: Функции и хранилища</td><td style="text-align: center;"> ✔️</td><td style="text-align: center;"> ✔️</td>
</tr>
</table>

> [!NOTE]
> Хотя этот курс основное внимание уделяется Windows Mixed Reality иммерсивную (VR), можно также применить полученные знания в этом курсе для Microsoft HoloLens. При выполнении, а также курс, вы увидите заметки обо всех изменениях, может потребоваться использовать для поддержки HoloLens.

## <a name="prerequisites"></a>Предварительные требования

> [!NOTE]
> Этот учебник предназначен для разработчиков, имеющих минимальный опыт с помощью Unity и C#. Также имейте в виду, что предварительные требования и инструкции в этом документе представляют новые были протестированы и проверены на момент написания статьи (мая 2018 г.). Вы можете свободно использовать последнюю программное обеспечение, как указано в [установить средства](install-the-tools.md) статьи, то, что следует не полагать, что информация в этом курсе будет точным соответствием что можно найти в новой версии по сравнению приведенных ниже .

Рекомендуется следующее оборудование и программное обеспечение для этого курса:

- На Компьютере, разработки [совместимы с Windows Mixed Reality](https://support.microsoft.com/help/4039260/windows-10-mixed-reality-pc-hardware-guidelines) для иммерсивных разработки Гарнитура (VR)
- [Windows 10 Fall Creators Update (или более поздней версии) с включенным режимом разработчика](install-the-tools.md#installation-checklist)
- [Последний пакет SDK Windows 10](install-the-tools.md#installation-checklist)
- [Unity 2017.4](install-the-tools.md#installation-checklist)
- [Visual Studio 2017](install-the-tools.md#installation-checklist)
- Объект [иммерсивных (VR) гарнитуры смешанной реальности Windows](immersive-headset-hardware-details.md) или [Microsoft HoloLens](hololens-hardware-details.md) с включенным режимом разработчика
- Подписка на учетную запись Azure для создания ресурсов Azure
- Доступ к Интернету для Azure установки и извлечения данных

## <a name="before-you-start"></a>Прежде чем начать

Чтобы избежать возникновения проблем сборки этого проекта, настоятельно рекомендуется создать проект, упомянутые в этом руководстве в корень или рядом с корневой папки (пути к папкам long может привести к проблемам во время сборки).

## <a name="chapter-1---the-azure-portal"></a>Глава 1 - портала Azure

Чтобы использовать **службы хранилища Azure**, вам потребуется создать и настроить **учетной записи хранения** на портале Azure.

1.  Войдите в [портала Azure](https://portal.azure.com).

    > [!NOTE]
    > Если у вас еще нет учетной записи Azure, необходимо будет создать его. Если вы следуете этим руководством, аудитории или лаборатории ситуации, попросите преподавателем или из прокторов для сведения о настройке новой учетной записи.

2.  После входа в систему щелкните **New** в левом верхнем углу, а поиск *учетной записи хранения*и нажмите кнопку **ввод**.

    ![Поиск хранилища Azure](images/AzureLabs-Lab5-01.png)

    > [!NOTE]
    > Слово **New** может были заменены **создать ресурс**, в новых порталов.

3.  Новая страница будет предоставить описание *учетной записи хранения Azure* службы. В нижней левой части этого запроса, выберите **создать** кнопку, чтобы создать ассоциацию с этой службой.

    ![Создание службы](images/AzureLabs-Lab5-02.png)

4.  Когда вы перейдете на **создать**:

    1.  Вставить *имя* для вашей учетной записи, помните, это поле принимает только цифры и строчные буквы.

    2.  Для *модели развертывания*выберите **Resource manager**.

    3.  Для *тип учетной записи*выберите **хранилища (общего назначения версии 1)**.

    4.  Определить *расположение* для группы ресурсов (Если вы создаете новую группу ресурсов). Расположение оптимально подойдет в регионе, в котором приложение будет работать. Некоторые ресурсы Azure доступны только в определенных регионах.

    5.  Для *репликации* выберите **Read-access геоизбыточного хранилища (RA-GRS)**.

    6.  Для *производительности*выберите **стандартный**.

    7.  Оставьте *требуется безопасное перемещение* как **отключено**.

    8.  Выберите *подписки*.

    9. Выберите *группы ресурсов* или создайте новую. Группа ресурсов предоставляет способ отслеживания, контроля доступа, Подготовка и управление выставлением счетов для набора средств Azure. Рекомендуется хранить все службы Azure, связанные с один проект (например, такие как многому) в разделе общей группы ресурсов). 

        > Если вы хотите получить дополнительные сведения о группах ресурсов Azure, пожалуйста, [откройте статью группы ресурсов](https://docs.microsoft.com/azure/azure-resource-manager/resource-group-portal).

    10. Также необходимо будет подтвердить, что мы рассмотрели, положения и условия, применяемые к этой службе.

    11. Щелкните **Создать**.

        ![сведения о службе ввода](images/AzureLabs-Lab5-03.png)

5.  Когда вы перейдете на **создать**, вы получите ожидания службы должен быть создан, это может занять около минуты.

6.  Уведомление будет отображаться на портале, после создания экземпляра службы.

    ![новое уведомление на портале azure](images/AzureLabs-Lab5-04.png)

7.  Щелкните уведомлений для просмотра в новом экземпляре службы.

    ![Перейти к ресурсу](images/AzureLabs-Lab5-05.png)

8.  Нажмите кнопку **перейти к ресурсу** кнопки в уведомлении для просмотра в новом экземпляре службы. Вы перейдете на новый *учетной записи хранения* экземпляра службы.

    ![Ключи доступа](images/AzureLabs-Lab5-06.png)

9.  Нажмите кнопку *ключи доступа*, чтобы показать конечные точки для этой облачной службы. Используйте *Блокнот* или аналогичную Скопируйте один из ключей для последующего использования. Кроме того, *строку подключения* значение, так как оно будет использоваться в *служб AzureServices* класс, который будет создан позже.

    ![Скопируйте строку подключения](images/AzureLabs-Lab5-07.png)

## <a name="chapter-2---setting-up-an-azure-function"></a>Глава 2 - Настройка функции Azure

Теперь создадим **Azure** **функция** в службе Azure.

Можно использовать **функции Azure** делать практически все, что это делается с помощью классической функции в коде, разница, что эта функция может осуществляться любым приложением, имеет учетные данные для доступа к учетной записи Azure.

Чтобы создать функцию Azure:

1.  Из вашего *портал Azure*, щелкните **New** в левом верхнем углу, а поиск *приложения-функции*и нажмите кнопку **ввод**.

    ![Создание приложения-функции](images/AzureLabs-Lab5-08.png)

    > [!NOTE]
    > Слово **New** может были заменены **создать ресурс**, в новых порталов.

2.  Новая страница будет предоставить описание *приложение-функцию Azure* службы. В нижней левой части этого запроса, выберите **создать** кнопку, чтобы создать ассоциацию с этой службой.

    ![сведения о приложении функции](images/AzureLabs-Lab5-09.png)

3.  Когда вы перейдете на **создать**:

    1.  Укажите *имя_приложения*. Только буквы и цифры могут быть использованы (допускается либо верхний или нижний регистр).

    2.  Выберите предпочтительный *подписки*.

    3. Выберите *группы ресурсов* или создайте новую. Группа ресурсов предоставляет способ отслеживания, контроля доступа, Подготовка и управление выставлением счетов для набора средств Azure. Рекомендуется хранить все службы Azure, связанные с один проект (например, такие как многому) в разделе общей группы ресурсов). 

        > Если вы хотите получить дополнительные сведения о группах ресурсов Azure, пожалуйста, [откройте статью группы ресурсов](https://docs.microsoft.com/azure/azure-resource-manager/resource-group-portal).

    4.  Для этого упражнения выберите *Windows* присвоили **ОС**.

    5.  Выберите *план потребления* для **план размещения**.

    6.  Определить *расположение* для группы ресурсов (Если вы создаете новую группу ресурсов). Расположение оптимально подойдет в регионе, в котором приложение будет работать. Некоторые ресурсы Azure доступны только в определенных регионах. Для обеспечения оптимальной производительности выберите тот же регион, что учетная запись хранения.

    7.  Для *хранения*выберите **использовать существующий**, и затем с помощью раскрывающегося списка, найти ранее созданного хранилища.

    8.  Оставьте *Application Insights* отключено для этого упражнения.

        ![сведения о приложении входная функция](images/AzureLabs-Lab5-10.png)

4.  Нажмите кнопку **Создать**.

5.  Когда вы перейдете на **создать**, вы получите ожидания службы должен быть создан, это может занять около минуты.

6.  Уведомление будет отображаться на портале, после создания экземпляра службы.

    ![новые уведомления с портала azure](images/AzureLabs-Lab5-11.png)

7.  Щелкните уведомлений для просмотра в новом экземпляре службы. 

    ![Перейдите к ресурсу приложения-функции](images/AzureLabs-Lab5-12.png)

8.  Нажмите кнопку **перейти к ресурсу** кнопки в уведомлении для просмотра в новом экземпляре службы. Вы перейдете на новый *приложения-функции* экземпляра службы.

9.  На *приложения-функции* панели мониторинга, наведите указатель мыши *функции*, определенным в пределах панели в левой части и нажмите кнопку **+ (плюс)** символов.

    ![Создание функции](images/AzureLabs-Lab5-13.png)

10. На следующей странице убедитесь **веб-перехватчик + API** выбран и для *выберите язык,* выберите **CSharp**, поскольку оно будет использоваться язык, используемый в этом руководстве. Наконец, щелкните **создайте эту функцию** кнопки.

    ![Выберите web ловушка csharp](images/AzureLabs-Lab5-14.png)

11. Должна открыться в код страницы (run.csx), если нет, щелкните только что созданной функции в списке функций на панели слева.

    ![Откройте новую функцию](images/AzureLabs-Lab5-15.png)

12. Скопируйте следующий код в функцию. Эта функция просто возвращает случайное целое число от 0 до 2 при вызове. Не беспокоиться о существующий код, вы можете вставить его поверх.

    ```csharp
        using System.Net;
        using System.Threading.Tasks;

        public static int Run(CustomObject req, TraceWriter log)
        {
            Random rnd = new Random();
            int randomInt = rnd.Next(0, 3);
            return randomInt;
        }

        public class CustomObject
        {
            public String name {get; set;}
        }
    ```

13. Выберите **Сохранить**.

14. Результат должен выглядеть как на следующем рисунке.

15. Щелкните **получить URL-адрес функции** и запишите *конечной точки* отображается. Необходимо вставить его в *служб AzureServices* класс, который вы создадите далее в этом курсе.

    ![Получение конечной точки функции](images/AzureLabs-Lab5-16.png)

    ![Получение конечной точки функции](images/AzureLabs-Lab5-16-5.png)

## <a name="chapter-3---setting-up-the-unity-project"></a>Глава 3 - Настройка проекта Unity

Следующие запущена типичный набор для разработки с помощью смешанной реальности и, таким образом, — это хороший шаблон для других проектов.

Настроить и проверить ваш иммерсивных гарнитуры смешанной реальности.

> [!NOTE]
> Вы будете **не** требуются контроллеры движения курс с демороликами. Если вам требуется поддерживает настройку иммерсивных гарнитура, [посетите смешанной реальности, Настройка статье](https://support.microsoft.com/en-au/help/4043101/windows-10-set-up-windows-mixed-reality).

1.  Откройте Unity и нажмите кнопку **New**.

    ![Создание нового проекта unity](images/AzureLabs-Lab5-17.png)

2.  Теперь необходимо будет указать имя проекта Unity. Вставить **MR_Azure_Functions**. Убедитесь, что тип проекта присваивается **3D**. Задайте *расположение* в другое место, наиболее подходящего для вас (Помните, что лучше, чем ближе к корневые каталоги). Щелкните **создать проект**.

    ![Назовите новый проект unity](images/AzureLabs-Lab5-18.png)

3.  С помощью Unity откройте, стоит проверки по умолчанию **редактор сценариев** присваивается **Visual Studio**. Перейдите к **изменить* > *предпочтения** и затем в окне «Новый» перейдите к **внешние средства**. Изменение **внешнего редактора скриптов** для **Visual Studio 2017**. Закрыть **предпочтения** окна.

    ![набор visual studio в качестве редактора скриптов](images/AzureLabs-Lab5-19.png)

4.  Перейдите к **файл > Параметры сборки** и переключитесь на платформе, которое **универсальной платформы Windows**, щелкнув **переключения платформы** кнопки.

    ![переключить платформу для универсальной платформы Windows](images/AzureLabs-Lab5-20.png)

5.  Перейдите к **файл > Параметры сборки** и убедитесь, что:

    1. **Целевое устройство** присваивается **любого устройства**.

        > Microsoft HoloLens, задайте **целевое устройство** для *HoloLens*.

    2. **Тип сборки** присваивается **D3D**

    3. **Пакет SDK для** присваивается **самую новую установленную**

    4. **Версия Visual Studio** присваивается **самую новую установленную**

    5. **Сборка и запуск** присваивается **локального компьютера**

    6. Сохраните сцены и добавить его к сборке.

        1.  Это сделать, выбрав **добавьте откройте сцены**. Сохранение окно будет отображаться.

            ![Добавление открытых сцен](images/AzureLabs-Lab5-21.png)

        2.  Создайте новую папку и все будущие, сцены, затем выберите **новую папку** кнопку, чтобы создать новую папку, назовите его **сцены**.

            ![Создайте папку сцены](images/AzureLabs-Lab5-22.png)

        3.  Откройте только что созданный **сцены** папку, а затем в **имя файла:** текстовое поле, тип **FunctionsScene**, нажмите клавишу **Сохранить**.

            ![Сохраните сцену функции](images/AzureLabs-Lab5-23.png)

6.  Для остальных параметров, в **параметры построения**, следует оставить значение по умолчанию сейчас.

    ![Сохраните сцену функции](images/AzureLabs-Lab5-24.png)

7.  В *параметры построения* щелкните **параметры проигрывателя** кнопки, откроется панель связанных в пространстве где *инспектор* находится.

    ![Параметры проигрывателя в инспекторе](images/AzureLabs-Lab5-25.png)

8.  В этой панели необходимо проверить некоторые настройки:

    1.  В **другие параметры** вкладке:

        1.  **Сценарии версии среды выполнения** должно быть **экспериментальный** (.NET 4.6 эквивалент), что вызовет необходимость перезапуска редактора.
        2.  **Создание сценариев серверной части** должно быть **.NET**
        3.  **Уровень совместимости API** должно быть **.NET 4.6**

    2.  В рамках **параметров публикации** в списке **возможности**, проверьте:
        
        -  **internetClient**

            ![набор возможностей](images/AzureLabs-Lab5-26.png)

    3.  Далее панели в **XR параметры** (под **параметров публикации**), деления **поддерживается виртуальной реальности**, убедитесь, что **Windows Mixed Reality Пакет SDK** добавляется.

        ![задать параметры XR](images/AzureLabs-Lab5-27.png)

9.  Вернитесь в *параметры построения* *Unity C# проекты* больше не отображается серым, установите флажок рядом с это.

    ![проекты c# делений](images/AzureLabs-Lab5-28.png)

10.  Закройте окно Параметры построения.

11. Сохраните сцену и проекта (**ФАЙЛ > Сохранить СЦЕНУ / FILE > Сохранить ПРОЕКТ**).

## <a name="chapter-4---setup-main-camera"></a>Глава 4 – Настройка главной камеры

> [!IMPORTANT]
> Если вы хотите пропустить *Настройка Unity* компоненты этого курса и по-прежнему непосредственно в код, вы можете [загрузить этот .unitypackage](https://github.com/Microsoft/HolographicAcademy/raw/Azure-MixedReality-Labs/Azure%20Mixed%20Reality%20Labs/MR%20and%20Azure%20305%20-%20Functions%20and%20storage/Azure-MR-305.unitypackage)и импортировать его в проект в качестве [Custom Пакет](https://docs.unity3d.com/Manual/AssetPackages.html). Оно также будет содержать библиотеки DLL из следующей главе. После импорта, по-прежнему из [Глава 7](#chapter-7---create-the-azureservices-class). 

1.  В *панели иерархии*, вы найдете объект с именем **Main Camera**, этот объект представляет вашей точки зрения «head» приложения «в».

2.  С помощью панели мониторинга Unity перед глазами, выберите **GameObject камеры Main**. Можно будет заметить, что *панели Инспектора* (обычно находится в правой части панели мониторинга) будут отображаться различные компоненты, *GameObject*, с помощью *преобразования* в верхней, за которым следует *камеры*и некоторые другие компоненты. Необходимо будет сбросить преобразование объекта Main Camera, поэтому расположено верно.

3.  Чтобы сделать это, выберите **шестеренки** значок рядом с камеры *преобразования* компонент и выберите **сбросить**.

    ![Сброс преобразования](images/AzureLabs-Lab5-29.png)

4.  Затем обновите **преобразования** компонента, чтобы выглядеть следующим образом:

    |         |    ПРЕОБРАЗОВАНИЕ - ПОЗИЦИИ   |       |
    | :-----: | :-----------------------: | :----:|
    | **X**   | **Y**                     | **Z** |
    | 0       | 1                         | 0     |    

    |       | ПРЕОБРАЗОВАНИЕ - ПОВОРОТА |       |
    | :---: | :------------------: | :----:|
    | **X** | **Y**                | **Z** |
    | 0     | 0                    | 0     |

    |       | ПРЕОБРАЗОВАНИЕ - МАСШТАБИРОВАНИЯ |       |
    | :---: | :---------------: | :---: |
    | **X** | **Y**             | **Z** |
    | 1     | 1                 | 1     |

    ![Преобразование набора камеры](images/AzureLabs-Lab5-30.png)

## <a name="chapter-5---setting-up-the-unity-scene"></a>Глава 5 - Настройка сцене Unity

1.  Щелкните правой кнопкой мыши пустую часть области *панели иерархии*в разделе **трехмерный объект**, добавьте **плоскости**.

    ![создать новый плоскость](images/AzureLabs-Lab5-31.png)

2.  С помощью **плоскости** объекта выбран, измените следующие параметры в *панели Инспектора*:

    |       | ПРЕОБРАЗОВАНИЕ - ПОЗИЦИИ |       |
    | :---: | :------------------: | :---: |
    | **X** | **Y**                | **Z** |
    | 0     | 0                    | 4     |

    |       | ПРЕОБРАЗОВАНИЕ - МАСШТАБИРОВАНИЯ |       |
    | :---: | :---------------: | :---: |
    | **X** | **Y**             | **Z** |
    | 10    | 1                 | 10    |

    ![задать положение плоскости и масштабирования](images/AzureLabs-Lab5-32.png)

    ![представление сцену плоскость](images/AzureLabs-Lab5-33.png)

3.  Щелкните правой кнопкой мыши пустую часть области *панели иерархии*в разделе **трехмерный объект**, добавьте **куба**.

    1.  Переименуйте куб, чтобы **GazeButton** (куба, выбранного, нажмите клавишу «F2»).

    2.  Измените следующие параметры в *панели Инспектора*:

        |       | ПРЕОБРАЗОВАНИЕ - ПОЗИЦИИ |       |
        | :---: | :------------------: |:-----:|
        | **X** | **Y**                | **Z** |
        | 0     | 3                    | 5     |


        ![набор взглядом кнопки преобразования](images/AzureLabs-Lab5-34.png)

        ![При помощи кнопки представлении сцены](images/AzureLabs-Lab5-35.png)

    3.  Щелкните **тега** кнопку раскрывающегося списка и щелкните **добавить тег** открыть *теги & область слои*.

        ![Добавление нового тега](images/AzureLabs-Lab5-36.png)

        ![Выберите плюс](images/AzureLabs-Lab5-37.png)

    4.  Выберите **+ (плюс)** кнопки, а затем в *новое имя тега* введите **GazeButton**и нажмите клавишу **Сохранить**.

        ![имя нового тега](images/AzureLabs-Lab5-38.png)

    5.  Щелкните **GazeButton** объекта в *панели иерархии*и в *панели Инспектора*, назначьте только что созданный **GazeButton** тега.

        ![назначить взглядом кнопку новый тег](images/AzureLabs-Lab5-39.png)

4.  Щелкните правой кнопкой мыши **GazeButton** объекта, в *панели иерархии*и добавьте **пустой объект GameObject** (который будет добавлен в качестве *дочерних* объект).

5.  Выберите новый объект и присвойте ему **ShapeSpawnPoint**.

    1.  Измените следующие параметры в *панели Инспектора*:

        |       | ПРЕОБРАЗОВАНИЕ - ПОЗИЦИИ |       |
        | :---: | :------------------: |:----: |
        | **X** |**Y**                 | **Z** |
        | 0     | -1                   | 0     |

        ![Преобразование точки spawn фигуры обновления](images/AzureLabs-Lab5-40.png)

        ![представлении сцены точки spawn фигуры](images/AzureLabs-Lab5-41.png)

6.  Затем вы создадите **трехмерного текста** объект, отзыв о состоянии службы Azure.

    Щелкните правой кнопкой мыши **GazeButton** в иерархии панели снова и добавьте **трехмерный объект > трехмерного текста** объекта в виде *дочерних*.

    ![Создайте новый объект трехмерного текста](images/AzureLabs-Lab5-42.png)

7.  Переименуйте **трехмерного текста** объект **AzureStatusText**.

8.  Изменение **AzureStatusText** объекта преобразования следующим образом:

    |       | ПРЕОБРАЗОВАНИЕ - ПОЗИЦИИ |       |
    | :---: | :------------------: | :---: |
    | **X** | **Y**                | **Z** |
    | 0     | 0                    | -0.6  |

    |       | ПРЕОБРАЗОВАНИЕ - МАСШТАБИРОВАНИЯ |       |
    | :---: | :---------------: | :---: |
    | **X** | **Y**             | **Z** |
    | 0.1   | 0.1               | 0.1   |


    > [!NOTE]
    > Не волнуйтесь, если он отображается в off centre, как это будет исправлено при ниже текст Mesh компонент обновляется.

9.  Изменение **Mesh текст** компонента в соответствии с ниже:

    ![Компонент сетки набора текста](images/AzureLabs-Lab5-43.png)

    > [!TIP]
    > Выбранный цвет здесь является Hex цветом: **000000FF**, однако вы можете выбрать собственные, просто убедитесь, он доступен для чтения.

10. Структуры вашей иерархии панели теперь должна выглядеть так:

    ![текст mesh в представлении сцены](images/AzureLabs-Lab5-43b.png)

10. Сцена теперь должен выглядеть следующим образом:

    ![текст mesh в представлении сцены](images/AzureLabs-Lab5-44.png)


## <a name="chapter-6---import-azure-storage-for-unity"></a>Глава 6 - Импорт хранилища Azure для Unity

Вы будете использовать службу хранилища Azure для Unity (который сам использует пакет SDK для Azure .net). Дополнительные сведения см. в [хранилища Azure для Unity статьи](https://docs.microsoft.com/sandbox/gamedev/unity/azure-storage-unity).

В Unity, который требует подключаемых модулей, чтобы повторно настроить после импорта в настоящее время имеется известная проблема. Эти шаги (4 – 7 в этом разделе), не будет обязательным после устранения ошибки.

Чтобы импортировать пакет SDK в свой проект, убедитесь, что вы скачали последнюю версию [«.unitypackage» из GitHub](https://aka.ms/azstorage-unitysdk). Затем сделайте следующее:

1.  Добавить **.unitypackage** файла к Unity с помощью **ресурсы > Импорт пакета > пользовательского пакета** пункт меню.

2.  В **Импорт пакета Unity** поле, отобразятся, вы сможете выбрать все данные **подключаемый модуль* > * хранилища **. Снимите флажок, все остальное, так как он не требуется для этого курса.

    ![Импорт пакета](images/AzureLabs-Lab5-45.png)

3.  Нажмите кнопку **импорта** кнопку, чтобы добавить элементы в проект.

4.  Перейдите к *хранения* папке *подключаемые модули*, в представлении проекта и выберите следующие подключаемые модули *только*:

    -   Microsoft.Data.Edm
    -   Microsoft.Data.OData
    -   Microsoft.WindowsAzure.Storage
    -   Newtonsoft.Json
    -   System.Spatial

        ![Снимите флажок для любой платформы](images/AzureLabs-Lab5-46.png)

5.  С помощью *этих конкретных подключаемых модулей* выбран, **снимите** *Any платформы* и **снимите флажок** *WSAPlayer* Нажмите кнопку **применить**.

    ![Применение платформы библиотек DLL](images/AzureLabs-Lab5-47.png)

    > [!NOTE]
    > Мы отмечаем эти определенного подключаемые модули можно использовать только в редакторе Unity. Это, так как существуют различные версии одной подключаемые модули в папку WSA, которая будет использоваться после проект будет экспортирован из Unity.

6.  В *хранения* папку подключаемый модуль, выберите только:

    -   Microsoft.Data.Services.Client

        ![не обрабатывать набор библиотек DLL](images/AzureLabs-Lab5-48.png)

7.  Проверьте **процесса не** поле в разделе *параметры платформы* и нажмите кнопку **применить**.

    ![применить без обработки](images/AzureLabs-Lab5-49.png)

    > [!NOTE]
    > Мы отмечаем этот подключаемый модуль «Не процесс» из-за сложности обработки этот подключаемый модуль средство исправления сборки Unity. Подключаемый модуль по-прежнему будет работать, несмотря на то, что он не обрабатывается.

## <a name="chapter-7---create-the-azureservices-class"></a>Глава 7 - создание класса служб AzureServices

Вы собираетесь создать первый класс — *служб AzureServices* класса.

*Служб AzureServices* класс будет отвечать за:

-   Хранение учетных данных учетной записи Azure.

-   Вызов Azure приложения-функции.

-   Отправки и скачивания файла данных в облачном хранилище Azure.

Для создания данного класса:

1.  Щелкните правой кнопкой мыши в *активов* папка «проект», **Создать > Папка**. Назовите папку **сценариев**.

    ![Создание новой папки](images/AzureLabs-Lab5-50.png)

    ![вызов папку - сценарии](images/AzureLabs-Lab5-51.png)

2.  Дважды щелкните папку, только что создали, чтобы открыть его.

3.  Щелкните правой кнопкой мыши внутри папки **Создать > C# сценарий**. Вызовите сценарий *служб AzureServices*.

4.  Дважды щелкните новый *служб AzureServices* класса, чтобы открыть его с *Visual Studio*.

5.  Добавьте следующие пространства имен в верхнюю часть *служб AzureServices*:

    ```csharp
        using System;
        using System.Threading.Tasks;
        using UnityEngine;
        using Microsoft.WindowsAzure.Storage;
        using Microsoft.WindowsAzure.Storage.File;
        using System.IO;
        using System.Net;
    ```

6.  Добавьте следующие поля инспектор внутри *служб AzureServices* класса:

    ```csharp
        /// <summary>
        /// Provides Singleton-like behavior to this class.
        /// </summary>
        public static AzureServices instance;

        /// <summary>
        /// Reference Target for AzureStatusText Text Mesh object
        /// </summary>
        public TextMesh azureStatusText;
    ```

7.  Затем добавьте следующие переменные-члены внутри *служб AzureServices* класса:

    ```csharp
        /// <summary>
        /// Holds the Azure Function endpoint - Insert your Azure Function
        /// Connection String here.
        /// </summary>

        private readonly string azureFunctionEndpoint = "--Insert here you AzureFunction Endpoint--";

        /// <summary>
        /// Holds the Storage Connection String - Insert your Azure Storage
        /// Connection String here.
        /// </summary>
        private readonly string storageConnectionString = "--Insert here you AzureStorage Connection String--";

        /// <summary>
        /// Name of the Cloud Share - Hosts directories.
        /// </summary>
        private const string fileShare = "fileshare";

        /// <summary>
        /// Name of a Directory within the Share
        /// </summary>
        private const string storageDirectory = "storagedirectory";

        /// <summary>
        /// The Cloud File
        /// </summary>
        private CloudFile shapeIndexCloudFile;

        /// <summary>
        /// The Linked Storage Account
        /// </summary>
        private CloudStorageAccount storageAccount;

        /// <summary>
        /// The Cloud Client
        /// </summary>
        private CloudFileClient fileClient;

        /// <summary>
        /// The Cloud Share - Hosts Directories
        /// </summary>
        private CloudFileShare share;

        /// <summary>
        /// The Directory in the share that will host the Cloud file
        /// </summary>
        private CloudFileDirectory dir;
    ```

    > [!IMPORTANT]
    > Убедитесь, что вы замените *конечной точки* и *строку подключения* значения значениями из хранилища Azure, найти на портале Azure

8.  Код для *Awake()* и *Start()* методы теперь должен быть добавлен. Эти методы будут вызываться при инициализации класса.

    ```csharp
        private void Awake()
        {
            instance = this;
        }

        // Use this for initialization
        private void Start()
        {
            // Set the Status text to loading, whilst attempting connection to Azure.
            azureStatusText.text = "Loading...";
        }

        /// <summary>
        /// Call to the Azure Function App to request a Shape.
        /// </summary>
        public async void CallAzureFunctionForNextShape()
        {

        }
    ```

    > [!IMPORTANT]
    > Мы заполнит код *CallAzureFunctionForNextShape()* в [будущих глава](#chapter-10---completing-the-AzureServices-class).

9.  Удалить *Update()* метод, так как этот класс не будет его использовать.

10. Сохранить изменения в Visual Studio и затем вернитесь к Unity.

11. Щелкните и перетащите *служб AzureServices* класса из папки скриптов для объекта Main Camera в *панели иерархии*.

12. Выберите Main Camera, а затем взять **AzureStatusText** дочерний объект из под **GazeButton** объекта и поместите его в **AzureStatusText** цель ссылки в поле *инспектор*, чтобы указать ссылку на *служб AzureServices* скрипта.

    ![assign azure status text reference target](images/AzureLabs-Lab5-52.png)

## <a name="chapter-8---create-the-shapefactory-class"></a>Глава 8 - создать класс ShapeFactory

Далее сценарий для создания, *ShapeFactory* класса. Роли этого класса является создание новой фигуры, при запросе и сохранять в журнале фигур, созданных в *списка журнала фигуры*. Каждый раз при создании фигуры *списка журнала фигуры* обновляется в *AzureService* класса, а затем сохраняются в вашей *хранилища Azure*. При запуске приложения, если найден сохраненного файла в вашей *хранилища Azure*, *списка журнала фигуры* извлекается и воспроизводимой с **трехмерного текста** предоставления объекта является ли создаваемый фигуры из хранилища или новые.

Для создания этого класса:

1.  Перейдите к **сценариев** папку, созданную ранее.

2.  Щелкните правой кнопкой мыши внутри папки **Создать > C# сценарий**. Вызовите сценарий *ShapeFactory*.

3.  Дважды щелкните новый *ShapeFactory* скрипт, чтобы открыть его с *Visual Studio*.

4.  Убедитесь, *ShapeFactory* класс включает следующие пространства имен:

    ```csharp
        using System.Collections.Generic;
        using UnityEngine;
    ```

5.  Добавьте переменные, указанные ниже *ShapeFactory* класса и замените *Start()* и *Awake()* функции со значениями ниже:

    ```csharp
        /// <summary>
        /// Provide this class Singleton-like behaviour
        /// </summary>
        [HideInInspector]
        public static ShapeFactory instance;

        /// <summary>
        /// Provides an Inspector exposed reference to ShapeSpawnPoint
        /// </summary>
        [SerializeField]
        public Transform spawnPoint;

        /// <summary>
        /// Shape History Index
        /// </summary>
        [HideInInspector]
        public List<int> shapeHistoryList;

        /// <summary>
        /// Shapes Enum for selecting required shape
        /// </summary>
        private enum Shapes { Cube, Sphere, Cylinder }

        private void Awake()
        {
            instance = this;
        }

        private void Start()
        {
            shapeHistoryList = new List<int>();
        }
    ```

6.  *CreateShape() позволяет* метод создает простые фигуры, основываясь на предоставленном *целое число* параметра. Логический параметр, используемые для указания, является ли созданных фигуры из хранилище или новый. Поместите следующий код в ваш *ShapeFactory* класс ниже предыдущих методов:

    ```csharp
        /// <summary>
        /// Use the Shape Enum to spawn a new Primitive object in the scene
        /// </summary>
        /// <param name="shape">Enumerator Number for Shape</param>
        /// <param name="storageShape">Provides whether this is new or old</param>
        internal void CreateShape(int shape, bool storageSpace)
        {
            Shapes primitive = (Shapes)shape;
            GameObject newObject = null;
            string shapeText = storageSpace == true ? "Storage: " : "New: ";

            AzureServices.instance.azureStatusText.text = string.Format("{0}{1}", shapeText, primitive.ToString());

            switch (primitive)
            {
                case Shapes.Cube:
                newObject = GameObject.CreatePrimitive(PrimitiveType.Cube);
                break;

                case Shapes.Sphere:
                newObject = GameObject.CreatePrimitive(PrimitiveType.Sphere);
                break;

                case Shapes.Cylinder:
                newObject = GameObject.CreatePrimitive(PrimitiveType.Cylinder);
                break;
            }

            if (newObject != null)
            {
                newObject.transform.position = spawnPoint.position;

                newObject.transform.localScale = new Vector3(0.5f, 0.5f, 0.5f);

                newObject.AddComponent<Rigidbody>().useGravity = true;

                newObject.GetComponent<Renderer>().material.color = UnityEngine.Random.ColorHSV(0f, 1f, 1f, 1f, 0.5f, 1f);
            }
        }
    ```

7.  Не забудьте сохранить изменения в Visual Studio перед возвратом к Unity.

8.  Обратно в редакторе Unity, щелкните и перетащите *ShapeFactory* класса из **сценарии** папку **Main Camera** объекта в *панели иерархии*.

9. С Main Camera выбран можно заметить, *ShapeFactory* компонента скрипта отсутствует *Spawn точки* ссылки. Чтобы устранить ее, перетащите **ShapeSpawnPoint** объекта из *панели иерархии* для **Spawn точки** цель ссылки.

    ![цель ссылки фабрики набора фигуры](images/AzureLabs-Lab5-53.png)

## <a name="chapter-9---create-the-gaze-class"></a>Глава 9 — создать класс взглядом

— Последний скрипт, чтобы создать *помощи* класса.

Этот класс отвечает за создание **Raycast** , будет проецироваться вперед от Main Camera, для обнаружения какой объект, который просматривает пользователь. В этом случае Raycast будет необходимо определить, если пользователь просматривает **GazeButton** объект в сцене и активировать поведение.

Для создания данного класса:

1.  Перейдите к **сценариев** папку, созданную ранее.

2.  Щелкните правой кнопкой мыши в панели «проект» **Создать > C# сценарий**. Вызовите сценарий *помощи*.

3.  Дважды щелкните новый *помощи* скрипт, чтобы открыть его с *Visual Studio.*

4.  Убедитесь, что в верхней части скрипта включается следующее пространство имен:

    ```csharp
        using UnityEngine;
    ```

5.  Затем добавьте следующие переменные внутри *помощи* класса:

    ```csharp
        /// <summary>
        /// Provides Singleton-like behavior to this class.
        /// </summary>
        public static Gaze instance;

        /// <summary>
        /// The Tag which the Gaze will use to interact with objects. Can also be set in editor.
        /// </summary>
        public string InteractibleTag = "GazeButton";

        /// <summary>
        /// The layer which will be detected by the Gaze ('~0' equals everything).
        /// </summary>
        public LayerMask LayerMask = ~0;

        /// <summary>
        /// The Max Distance the gaze should travel, if it has not hit anything.
        /// </summary>
        public float GazeMaxDistance = 300;

        /// <summary>
        /// The size of the cursor, which will be created.
        /// </summary>
        public Vector3 CursorSize = new Vector3(0.05f, 0.05f, 0.05f);

        /// <summary>
        /// The color of the cursor - can be set in editor.
        /// </summary>
        public Color CursorColour = Color.HSVToRGB(0.0223f, 0.7922f, 1.000f);

        /// <summary>
        /// Provides when the gaze is ready to start working (based upon whether
        /// Azure connects successfully).
        /// </summary>
        internal bool GazeEnabled = false;

        /// <summary>
        /// The currently focused object.
        /// </summary>
        internal GameObject FocusedObject { get; private set; }

        /// <summary>
        /// The object which was last focused on.
        /// </summary>
        internal GameObject _oldFocusedObject { get; private set; }

        /// <summary>
        /// The info taken from the last hit.
        /// </summary>
        internal RaycastHit HitInfo { get; private set; }

        /// <summary>
        /// The cursor object.
        /// </summary>
        internal GameObject Cursor { get; private set; }

        /// <summary>
        /// Provides whether the raycast has hit something.
        /// </summary>
        internal bool Hit { get; private set; }

        /// <summary>
        /// This will store the position which the ray last hit.
        /// </summary>
        internal Vector3 Position { get; private set; }

        /// <summary>
        /// This will store the normal, of the ray from its last hit.
        /// </summary>
        internal Vector3 Normal { get; private set; }

        /// <summary>
        /// The start point of the gaze ray cast.
        /// </summary>
        private Vector3 _gazeOrigin;

        /// <summary>
        /// The direction in which the gaze should be.
        /// </summary>
        private Vector3 _gazeDirection;
    ```

> [!IMPORTANT]
> Некоторые из этих переменных будут иметь возможность редактировать в *редактор*.

6.  Код для *Awake()* и *Start()* методы теперь должен быть добавлен.

    ```csharp
        /// <summary>
        /// The method used after initialization of the scene, though before Start().
        /// </summary>
        private void Awake()
        {
            // Set this class to behave similar to singleton
            instance = this;
        }

        /// <summary>
        /// Start method used upon initialization.
        /// </summary>
        private void Start()
        {
            FocusedObject = null;
            Cursor = CreateCursor();
        }
    ```

7.  Добавьте следующий код, который создает объект курсора в начале, вместе с *Update()* метод, который будет выполнен метод Raycast, кроме того, где установлен GazeEnabled логическое значение:

    ```csharp
        /// <summary>
        /// Method to create a cursor object.
        /// </summary>
        /// <returns></returns>
        private GameObject CreateCursor()
        {
            GameObject newCursor = GameObject.CreatePrimitive(PrimitiveType.Sphere);
            newCursor.SetActive(false);

            // Remove the collider, so it doesn't block raycast.
            Destroy(newCursor.GetComponent<SphereCollider>());
            newCursor.transform.localScale = CursorSize;

            newCursor.GetComponent<MeshRenderer>().material = new Material(Shader.Find("Diffuse"))
            {
                color = CursorColour
            };

            newCursor.name = "Cursor";

            newCursor.SetActive(true);

            return newCursor;
        }

        /// <summary>
        /// Called every frame
        /// </summary>
        private void Update()
        {
            if(GazeEnabled == true)
            {
                _gazeOrigin = Camera.main.transform.position;

                _gazeDirection = Camera.main.transform.forward;

                UpdateRaycast();
            }
        }
    ```

8. Далее добавьте *UpdateRaycast()* метод, который будет проект Raycast и обнаружить попаданий целевой объект.

    ```csharp
        private void UpdateRaycast()
        {
            // Set the old focused gameobject.
            _oldFocusedObject = FocusedObject;

            RaycastHit hitInfo;

            // Initialise Raycasting.
            Hit = Physics.Raycast(_gazeOrigin,
                _gazeDirection,
                out hitInfo,
                GazeMaxDistance, LayerMask);

            HitInfo = hitInfo;

            // Check whether raycast has hit.
            if (Hit == true)
            {
                Position = hitInfo.point;

                Normal = hitInfo.normal;

                // Check whether the hit has a collider.
                if (hitInfo.collider != null)
                {
                    // Set the focused object with what the user just looked at.
                    FocusedObject = hitInfo.collider.gameObject;
                }
                else
                {
                    // Object looked on is not valid, set focused gameobject to null.
                    FocusedObject = null;
                }
            }
            else
            {
                // No object looked upon, set focused gameobject to null.
                FocusedObject = null;

                // Provide default position for cursor.
                Position = _gazeOrigin + (_gazeDirection * GazeMaxDistance);

                // Provide a default normal.
                Normal = _gazeDirection;
            }

            // Lerp the cursor to the given position, which helps to stabilize the gaze.
            Cursor.transform.position = Vector3.Lerp(Cursor.transform.position, Position, 0.6f);

            // Check whether the previous focused object is this same 
            //    object. If so, reset the focused object.
            if (FocusedObject != _oldFocusedObject)
            {
                ResetFocusedObject();

                if (FocusedObject != null)
                {
                if (FocusedObject.CompareTag(InteractibleTag.ToString()))
                {
                        // Set the Focused object to green - success!
                        FocusedObject.GetComponent<Renderer>().material.color = Color.green;

                        // Start the Azure Function, to provide the next shape!
                        AzureServices.instance.CallAzureFunctionForNextShape();
                    }
                }
            }
        }
    ```

9. Наконец, добавьте *ResetFocusedObject()* метод, который будет составляться GazeButton объектов текущего цвета, указывающее, является ли он создает новую фигуру или нет.

    ```csharp
        /// <summary>
        /// Reset the old focused object, stop the gaze timer, and send data if it
        /// is greater than one.
        /// </summary>
        private void ResetFocusedObject()
        {
            // Ensure the old focused object is not null.
            if (_oldFocusedObject != null)
            {
                if (_oldFocusedObject.CompareTag(InteractibleTag.ToString()))
                {
                    // Set the old focused object to red - its original state.
                    _oldFocusedObject.GetComponent<Renderer>().material.color = Color.red;
                }
            }
        }
    ```

10.  Сохраните изменения в Visual Studio перед возвратом к Unity.

11.  Щелкните и перетащите *помощи* класс из папки скриптов для **Main Camera** объекта в *панели иерархии*.

## <a name="chapter-10---completing-the-azureservices-class"></a>Глава 10 — завершение работы класса служб AzureServices

С помощью других сценариев на месте, он теперь имеется возможность *полный* *служб AzureServices* класса. Это будет осуществляться через:

1.  Добавление нового метода с именем *CreateCloudIdentityAsync()*, чтобы задать переменные проверки подлинности, необходимые для взаимодействия с Azure.

    > Этот метод также проверяет наличие ранее сохраненный файл, содержащий список фигуры.
    >
    > **Если файл найден**, она происходит отключение пользователя *помощи*и запустить создание фигуры, согласно шаблону фигур, в том случае, как хранящиеся в **файла хранилища Azure**. Пользователь может видеть, как **Mesh текст** предоставит отображения «Хранилище» или «New», в зависимости от начала координат фигуры.
    >
    > **Если не найден файл**, это позволит *помощи*, позволяя пользователям для создания фигур, рассматривая **GazeButton** объект в сцене.

    ```csharp
        /// <summary>
        /// Create the references necessary to log into Azure
        /// </summary>
        private async void CreateCloudIdentityAsync()
        {
            // Retrieve storage account information from connection string
            storageAccount = CloudStorageAccount.Parse(storageConnectionString);

            // Create a file client for interacting with the file service.
            fileClient = storageAccount.CreateCloudFileClient();

            // Create a share for organizing files and directories within the storage account.
            share = fileClient.GetShareReference(fileShare);

            await share.CreateIfNotExistsAsync();

            // Get a reference to the root directory of the share.
            CloudFileDirectory root = share.GetRootDirectoryReference();

            // Create a directory under the root directory
            dir = root.GetDirectoryReference(storageDirectory);

            await dir.CreateIfNotExistsAsync();

            //Check if the there is a stored text file containing the list
            shapeIndexCloudFile = dir.GetFileReference("TextShapeFile");

            if (!await shapeIndexCloudFile.ExistsAsync())
            {
                // File not found, enable gaze for shapes creation
                Gaze.instance.GazeEnabled = true;

                azureStatusText.text = "No Shape\nFile!";
            }
            else
            {
                // The file has been found, disable gaze and get the list from the file
                Gaze.instance.GazeEnabled = false;

                azureStatusText.text = "Shape File\nFound!";

                await ReplicateListFromAzureAsync();
            }
        }
    ```

2.  В следующем фрагменте кода является изнутри *Start()* метод; в случае, если будет выполнен вызов *CreateCloudIdentityAsync()* метод. Вы можете скопировать текущий *Start()* метод, с помощью ниже:

    ```csharp
        private void Start()
        {
            // Disable TLS cert checks only while in Unity Editor (until Unity adds support for TLS)
    #if UNITY_EDITOR
            ServicePointManager.ServerCertificateValidationCallback = delegate { return true; };
    #endif

            // Set the Status text to loading, whilst attempting connection to Azure.
            azureStatusText.text = "Loading...";

            //Creating the references necessary to log into Azure and check if the Storage Directory is empty
            CreateCloudIdentityAsync();
        }
    ```

3.  Введите код для метода *CallAzureFunctionForNextShape()*. Вы будет использовать ранее созданный *приложение-функцию Azure* для запроса индекса фигуры. После его получения, этот метод будет отправлять в фигуру, чтобы *ShapeFactory* класс, чтобы создать новую фигуру в сцену. Используйте приведенный ниже код для завершения тело *CallAzureFunctionForNextShape()*.

    ```csharp
        /// <summary>
        /// Call to the Azure Function App to request a Shape.
        /// </summary>
        public async void CallAzureFunctionForNextShape()
        {
            int azureRandomInt = 0;

            // Call Azure function
            HttpWebRequest webRequest = WebRequest.CreateHttp(azureFunctionEndpoint);

            WebResponse response = await webRequest.GetResponseAsync();

            // Read response as string
            using (Stream stream = response.GetResponseStream())
            {
                StreamReader reader = new StreamReader(stream);

                String responseString = reader.ReadToEnd();

                //parse result as integer
                Int32.TryParse(responseString, out azureRandomInt);
            }

            //add random int from Azure to the ShapeIndexList
            ShapeFactory.instance.shapeHistoryList.Add(azureRandomInt);

            ShapeFactory.instance.CreateShape(azureRandomInt, false);

            //Save to Azure storage
            await UploadListToAzureAsync();
        }
    ```

4.  Добавьте метод для создания строки, объединяя целых чисел, хранимых в журнале фигуры и помещения их в вашей *хранилища файлов Azure*.

    ```csharp
        /// <summary>
        /// Upload the locally stored List to Azure
        /// </summary>
        private async Task UploadListToAzureAsync()
        {
            // Uploading a local file to the directory created above
            string listToString = string.Join(",", ShapeFactory.instance.shapeHistoryList.ToArray());

            await shapeIndexCloudFile.UploadTextAsync(listToString);
        }
    ```

5.  Добавьте метод для извлечения текста, хранящегося в файле, расположенном в вашей *хранилища файлов Azure* и *десериализации* его в список.

6.  После завершения этого процесса, метод повторно включает взглядом, таким образом, пользователь может добавлять дополнительные фигуры в сцену.

    ```csharp
        ///<summary>
        /// Get the List stored in Azure and use the data retrieved to replicate 
        /// a Shape creation pattern
        ///</summary>
        private async Task ReplicateListFromAzureAsync()
        {
            string azureTextFileContent = await shapeIndexCloudFile.DownloadTextAsync();

            string[] shapes = azureTextFileContent.Split(new char[] { ',' });

            foreach (string shape in shapes)
            {
                int i;

                Int32.TryParse(shape.ToString(), out i);

                ShapeFactory.instance.shapeHistoryList.Add(i);

                ShapeFactory.instance.CreateShape(i, true);

                await Task.Delay(500);
            }

            Gaze.instance.GazeEnabled = true;

            azureStatusText.text = "Load Complete!";
        }
    ```

7.  Сохраните изменения в Visual Studio перед возвратом к Unity.

## <a name="chapter-11---build-the-uwp-solution"></a>Глава 11 - выполнить сборку решения универсальной платформы Windows

Чтобы начать процесс построения:

1.  Перейдите к **файл > Параметры сборки**.

    ![Построение приложения](images/AzureLabs-Lab5-54.png)

2.  Щелкните **Сборка**. Unity приведет к запуску *проводнике* окно, где необходимо создать, а затем выберите папку, чтобы создать приложение в. Создайте эту папку и назовите его *приложения*. Затем с помощью *приложения* папку, нажмите клавишу **Выбор папки**.

3.  Unity начнется построение проекта для *приложения* папки.

4.  Один раз Unity завершил построение (может занять некоторое время), он будет открыт *проводнике* окне в местоположении, построения (проверьте панели задач, так как он может не всегда отображаются над windows, но уведомит вас о Добавление нового окно).

## <a name="chapter-12---deploying-your-application"></a>Глава 12 - развертывания приложения

Для развертывания приложения:

1.  Перейдите к *приложения* папку, которая была создана в [последняя глава](#chapter-11---build-the-uwp-solution). Вы увидите файл с именем вашего приложения, с расширением «.sln», который следует дважды щелкнуть, таким образом, чтобы открыть его в *Visual Studio*.

2.  В **платформа решения**выберите **x86, локальный компьютер**.

3.  В **конфигурации решения** выберите **Отладка**.

    > Для Microsoft HoloLens, может быть проще устанавливать равным *удаленный компьютер*, таким образом, не связанном устройстве на компьютер. Однако необходимо будет выполнить следующее:
    > - Знать **IP-адрес** из HoloLens, которую можно найти в *параметры > сеть и Интернет > Wi-Fi > Дополнительно*; IPv4 — это адрес, следует использовать. 
    > - Убедитесь, **режим разработчика** — **на**; найдено в *параметры > обновление и безопасность > для разработчиков*.

    ![Развертывание решения](images/AzureLabs-Lab5-55.png)

4.  Перейдите к **построения** меню и щелкните **развернуть решение** для загрузки неопубликованных приложений на компьютер.

5.  Приложения должны появиться в списке установленных приложений, все готово для запуска и протестировано!

## <a name="your-finished-azure-functions-and-storage-application"></a>По завершении функций Azure и приложение службы хранилища

Поздравляем, вы создали приложение смешанной реальности, которое использует службы "функции Azure" и службы хранилища Azure. Приложения будут иметь возможность рисования на сохраненных данных и укажите действие на основе этих данных.

![конечный продукт-end](images/AzureLabs-Lab5-00.png)

## <a name="bonus-exercises"></a>Упражнения премии

### <a name="exercise-1"></a>Упражнение 1

Создание второй spawn, точки и записи, которая порождает точки, для которого был создан объект. Когда вы загружаете файл данных, воспроизведение фигуры порожденных из расположения, в которых они изначально были созданы.

### <a name="exercise-2"></a>Упражнение 2

Создайте способ перезапустить приложение, вместо того чтобы повторно открыть его каждый раз. **Загрузка сцены** -подходящее место для запуска. После этого создайте очистки списка хранимых в *хранилища Azure*, так что можно легко восстановить ее из приложения. 
