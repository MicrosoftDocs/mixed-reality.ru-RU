---
title: Г-н и Azure 308 - уведомлений между устройствами
description: Выполните этот курс, чтобы узнать, как реализовать приложение смешанной реальности центров уведомлений Azure, функции Azure и хранилища Azure и таблиц.
author: drneil
ms.author: jemccull
ms.date: 07/04/2018
ms.topic: article
keywords: Azure, смешанной реальности, academy, unity, учебник, api, уведомления, функции, таблицы, центры уведомлений, hololens, создающий эффект присутствия, vr
ms.openlocfilehash: 3b6e930acd81c7d6e3addc107ec0da605d38cad1
ms.sourcegitcommit: 06ac2200d10b50fb5bcc413ce2a839e0ab6d6ed1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/09/2019
ms.locfileid: "67694605"
---
>[!NOTE]
>Учебники Academy реальности Mixed были разработаны с HoloLens (1-го поколения) и смешанной реальности Иммерсивную в виду.  Таким образом мы думаем, что это важно, чтобы эти учебники на месте для разработчиков, которые по-прежнему необходимы сведения при разработке приложений для этих устройств.  Эти руководства будут **_не_** дополняться последние наборы инструментов или взаимодействия, используемых для HoloLens 2.  Они будут сохранены, чтобы продолжить работу на поддерживаемых устройствах. Будет существовать новую серию учебников, которые будут опубликованы в будущем, демонстрируют способ разработки для HoloLens 2.  Это уведомление будет обновляться со ссылкой на эти руководства, когда они учитываются.

<br>

# <a name="mr-and-azure-308-cross-device-notifications"></a>Г-н и Azure 308: Уведомлений между устройствами

![конечный продукт-запуск](images/AzureLabs-Lab8-00.png)

В рамках этого курса вы узнаете, как добавить возможности центров уведомлений в приложение смешанной реальности, с помощью центров уведомлений Azure, таблицы Azure и функций Azure.

**Центры уведомлений Azure** — это служба Майкрософт, которую разработчики могут отправлять целевые персонализированные push-уведомления на любую платформу, все на базе облака. Это эффективно позволяют разработчикам взаимодействовать с конечными пользователями, или даже обмена данными между различными приложениями, в зависимости от сценария. Дополнительные сведения см. в статье **центров уведомлений Azure** [страницы](https://docs.microsoft.com/azure/notification-hubs/notification-hubs-push-notification-overview).

**Функции Azure** является служба, которая позволяет разработчикам запускать небольшие фрагменты кода, «», в функциях Azure. Это позволяет делегировать работу в облаке, а не локального приложения, который может иметь множество преимуществ. **Функции Azure** поддерживает несколько языков разработки, в том числе C\#, F\#, Node.js, Java и PHP. Дополнительные сведения см. в статье **"функции Azure"** [страницы](https://docs.microsoft.com/azure/azure-functions/functions-overview).

**Таблицы Azure** является облачной службой Майкрософт, которая позволяет разработчикам хранить данные структурированных отличные от SQL в облаке, сделаете его доступным в любом месте. Служба может похвастаться бессхемной конструкцией, позволяя развитие таблиц, при необходимости и таким образом обладает большой гибкостью. Дополнительные сведения см. в статье **таблицы Azure** [страницы](https://docs.microsoft.com/azure/cosmos-db/table-storage-overview)

После выполнения этого курса, у вас будет приложении иммерсивных гарнитуры смешанной реальности и это приложение для настольных ПК, которое сможет выполнить следующие:

1. Приложения для настольных ПК, позволит пользователю для перемещения объекта в двумерном пространстве (X и Y), с помощью мыши.

2. Перемещение объектов в приложении ПК будут отправляться в облако с помощью JSON, который может быть в виде строки, содержащая идентификатор объекта, тип и преобразование информации (координаты X и Y). 

3. Приложение смешанной реальности, которое имеет идентичные сцены в классическое приложение, будет получать уведомлений о перемещение объектов из службы концентраторов уведомлений (который был обновлен в приложении для настольных ПК). 

4. При получении уведомления, который будет содержать идентификатор объекта, тип и информацию о преобразовании, смешанной реальности применит полученные сведения свой собственный сцену.

В приложении зависит от пользователя о том, как интегрировать результаты проектированию. Этот курс призван научить позволяют интегрировать службу Azure с проектом Unity. Это задание может использовать знание, что вы получите из этого курса можно улучшить приложение смешанной реальности. Этот курс — это автономное руководство, которые не предусматривают любых других смешанной реальности лабораторий, напрямую.

## <a name="device-support"></a>Поддержка устройств

<table>
<tr>
<th>Курс</th><th style="width:150px"> <a href="hololens-hardware-details.md">HoloLens</a></th><th style="width:150px"> <a href="immersive-headset-hardware-details.md">Иммерсивные гарнитуры</a></th>
</tr><tr>
<td> Г-н и Azure 308: Уведомлений между устройствами</td><td style="text-align: center;"> ✔️</td><td style="text-align: center;"> ✔️</td>
</tr>
</table>

> [!NOTE]
> Хотя этот курс основное внимание уделяется Windows Mixed Reality иммерсивную (VR), можно также применить полученные знания в этом курсе для Microsoft HoloLens. При выполнении, а также курс, вы увидите заметки обо всех изменениях, может потребоваться использовать для поддержки HoloLens. При использовании HoloLens, вы можете заметить некоторые echo во время записи голоса.

## <a name="prerequisites"></a>предварительные требования

> [!NOTE]
> Этот учебник предназначен для разработчиков, имеющих минимальный опыт с помощью Unity и C#. Также имейте в виду, что предварительные требования и инструкции в этом документе представляют новые были протестированы и проверены на момент написания статьи (мая 2018 г.). Вы можете свободно использовать последнюю программное обеспечение, как указано в [установить средства](install-the-tools.md) статьи, то, что следует не полагать, что информация в этом курсе будет точным соответствием что можно найти в новой версии по сравнению приведенных ниже .

Рекомендуется следующее оборудование и программное обеспечение для этого курса:

- На Компьютере, разработки [совместимы с Windows Mixed Reality](https://support.microsoft.com/help/4039260/windows-10-mixed-reality-pc-hardware-guidelines) для иммерсивных разработки Гарнитура (VR)
- [Windows 10 Fall Creators Update (или более поздней версии) с включенным режимом разработчика](install-the-tools.md#installation-checklist)
- [Последний пакет SDK Windows 10](install-the-tools.md#installation-checklist)
- [Unity 2017.4](install-the-tools.md#installation-checklist)
- [Visual Studio 2017](install-the-tools.md#installation-checklist)
- Объект [иммерсивных (VR) гарнитуры смешанной реальности Windows](immersive-headset-hardware-details.md) или [Microsoft HoloLens](hololens-hardware-details.md) с включенным режимом разработчика
- Доступ к Интернету для настройки Azure и получить доступ к концентраторам уведомлений

## <a name="before-you-start"></a>Прежде чем начать

- Чтобы избежать возникновения проблем сборки этого проекта, настоятельно рекомендуется создать проект, упомянутые в этом руководстве в корень или рядом с корневой папки (пути к папкам long может привести к проблемам во время сборки).
- Необходимо быть владельцем портал разработчиков Microsoft и на портале регистрации приложений, в противном случае не будут иметь разрешение на доступ к приложению в [Глава 2](#chapter-2---retrieve-your-new-apps-credentials).

## <a name="chapter-1---create-an-application-on-the-microsoft-developer-portal"></a>Глава 1 - Создание приложения на портале разработчика Майкрософт

Чтобы использовать **центров уведомлений Azure** службы, необходимо будет создать приложение на портале разработчика Майкрософт, как приложения нужно будет регистрироваться, чтобы она могла отправлять и получать уведомления.

1.  Войдите в [портал разработчиков Microsoft](https://developer.microsoft.com/dashboard).

    > Необходимо будет войти учетную запись Майкрософт.

2.  На панели мониторинга щелкните **создать новое приложение**.

    ![Создание приложения](images/AzureLabs-Lab8-01.png)

3.  Откроется всплывающее окно, в котором необходимо зарезервировать имя для нового приложения. В текстовом поле вставьте соответствующее имя; Если выбранное имя, такт будет отображаться справа от текстового поля. При наличии доступных имя, добавленное щелкните **зарезервировать имя продукта** кнопку в левом нижнем углу всплывающего окна.

    ![обратное имя](images/AzureLabs-Lab8-02.png)

4.  Используя приложение создано вы будете готовы переместить в следующей главе.

## <a name="chapter-2---retrieve-your-new-apps-credentials"></a>Глава 2 - получить учетные данные нового приложения

Войдите на портал регистрации приложений, где будут перечислены и получить учетные данные, которые будут использоваться для установки нового приложения **службы концентраторов уведомлений** в **портал Azure**.

1.  Перейдите к [портал регистрации приложений](http://apps.dev.microsoft.com).

    ![портал регистрации приложений](images/AzureLabs-Lab8-03.png)

    > [!WARNING] 
    > Необходимо использовать учетную запись Майкрософт для входа.  
    > Это **необходимо** быть учетной записи Майкрософт, которые использовались в предыдущем [глава](#chapter-1---create-an-application-on-the-microsoft-developer-portal), на портал разработчиков Windows Store.

2.  Вы найдете приложение под управлением **моих приложений** раздел. Когда вы найдете его, щелкните его, и вы перейдете на новую страницу, на котором установлено приложение а также **регистрации**.

    ![только что зарегистрированное приложение](images/AzureLabs-Lab8-04.png)

3.  Прокрутите вниз страницу регистрации, чтобы найти ваш **секретов приложения** раздел и **ИД безопасности пакета** для вашего приложения. Скопируйте обе для использования с настройкой **службы концентраторов уведомлений Azure** в следующей главе.

    ![Секреты приложений](images/AzureLabs-Lab8-05.png)

## <a name="chapter-3---setup-azure-portal-create-notification-hubs-service"></a>Глава 3 - Настройка портала Azure: создание службы концентраторов уведомлений

С помощью учетных данных приложения извлечена, вам потребуется перейти на портал Azure, в которой будет создаваться в службе концентраторов уведомлений Azure.

1.  Войдите на [портала Azure](https://portal.azure.com).

    > [!NOTE] 
    > Если у вас еще нет учетной записи Azure, необходимо будет создать его. Если вы следуете этим руководством, аудитории или лаборатории ситуации, попросите преподавателем или из прокторов для сведения о настройке новой учетной записи.

2.  После входа в систему щелкните **New** в левом верхнем углу, а поиск **концентратора уведомлений**и нажмите кнопку ***ввод***.

    ![Поиск концентратора уведомлений](images/AzureLabs-Lab8-06.png)

    > [!NOTE] 
    > Слово ***New*** может были заменены **создать ресурс**, в новых порталов.

3.  Новая страница будет предоставить описание *центров уведомлений* службы. В нижней левой части этого запроса, выберите **создать** кнопку, чтобы создать ассоциацию с этой службой.

    ![Создайте экземпляр концентратора уведомлений](images/AzureLabs-Lab8-07.png)

4.  Когда вы перейдете на ***создать***:

    1.  Вставьте желаемого имени для данного экземпляра службы.

    2.  Укажите **пространства имен** которого можно будет связать с этим приложением.

    3.  Выберите **расположение.**

    4.  Выберите **группы ресурсов** или создайте новую. Группа ресурсов предоставляет способ отслеживания, контроля доступа, Подготовка и управление выставлением счетов для набора средств Azure. Рекомендуется хранить все службы Azure, связанные с один проект (например, такие как многому) в разделе общей группы ресурсов).

        > Если вы хотите получить дополнительные сведения о группах ресурсов Azure, выполните инструкции из этого [ссылку на управление группой ресурсов](https://docs.microsoft.com/azure/azure-resource-manager/resource-group-portal). 

    5.  Выберите соответствующее **подписки**.

    6.  Также необходимо будет подтвердить, что мы рассмотрели, положения и условия, применяемые к этой службе.

    7. Щелкните **Создать**.

        ![Заполните сведения о службе](images/AzureLabs-Lab8-08.png)

5.  Когда вы перейдете на **создать**, вы получите ожидания службы должен быть создан, это может занять около минуты.

6.  Уведомление будет отображаться на портале, после создания экземпляра службы.

    ![уведомление](images/AzureLabs-Lab8-09.png)

7.  Нажмите кнопку **перейти к ресурсу** кнопки в уведомлении для просмотра в новом экземпляре службы. Вы перейдете на новый **концентратора уведомлений** экземпляра службы.

    ![Перейти к ресурсу](images/AzureLabs-Lab8-10.png)
    
8.  На странице обзора, равном вниз по странице, щелкните **Windows (WNS).** На правой панели изменится на Показать два текстовые поля, которые требуют вашего **ИД безопасности пакета** и **ключ безопасности**, из приложения, настроенного ранее.

    ![созданная служба концентраторов](images/AzureLabs-Lab8-11.png)

9. После копирования сведений в нужные поля, нажмите кнопку **Сохранить**, и вы получите уведомление, когда в центре уведомлений успешно обновлен.

    ![Скопируйте сведения о безопасности](images/AzureLabs-Lab8-12.png)

## <a name="chapter-4---setup-azure-portal-create-table-service"></a>Глава 4 - Настройка портала Azure: создание службы таблиц

После создания экземпляра службы концентраторов уведомлений, перейдите назад на портал Azure, которой будет создаваться в службе таблиц Azure, создав ресурс хранилища.

1.  Если еще не выполнил вход, вход в [портал Azure](https://portal.azure.com).

2.  После входа в систему, щелкните **New** в левом верхнем углу, а поиск **учетной записи хранения**и нажмите кнопку **ввод**.

    > [!NOTE] 
    > Слово ***New*** может были заменены **создать ресурс**, в новых порталов.

3.  Выберите **учетная запись хранения — большой двоичный объект, файл, таблица, очередь** из списка.

    ![Поиск учетной записи хранения](images/AzureLabs-Lab8-13.png)

4.  Новая страница будет предоставить описание **учетной записи хранения** службы. В нижней левой части этого запроса, выберите **создать** кнопку, чтобы создать экземпляр этой службы.

    ![Создание экземпляра хранилища](images/AzureLabs-Lab8-14.png)

5.  Когда вы перейдете на **создать**, будут отображаться панели:

    1. Вставить нужный **имя** для данного экземпляра службы (должны указываться прописными буквами).

    2. Для **модели развертывания**, нажмите кнопку **Resource manager**.

    3.  Для **тип учетной записи**, с помощью раскрывающегося списка выберите **хранилища (общего назначения версии 1)** .

    4. Выберите соответствующее **расположение**.
    
    5.  Для **репликации** раскрывающемся меню выберите **Read-access геоизбыточного хранилища (RA-GRS)** .

    6.  Для **производительности**, нажмите кнопку **стандартный**.

    7.  В рамках **требуется безопасное перемещение** выберите **отключено**.

    8.  Из **подписки** в раскрывающемся меню выберите соответствующую подписку.

    9.  Выберите **группы ресурсов** или создайте новую. Группа ресурсов предоставляет способ отслеживания, контроля доступа, Подготовка и управление выставлением счетов для набора средств Azure. Рекомендуется хранить все службы Azure, связанные с один проект (например, такие как многому) в разделе общей группы ресурсов).

        > Если вы хотите получить дополнительные сведения о группах ресурсов Azure, выполните инструкции из этого [ссылку на управление группой ресурсов](https://docs.microsoft.com/azure/azure-resource-manager/resource-group-portal).

    10. Оставьте **виртуальные сети** как **отключено** Если этот вариант для вас.

    11. Нажмите кнопку **Создать**.

        ![Заполните сведения о хранилище](images/AzureLabs-Lab8-15.png)

6.  Когда вы перейдете на **создать**, вы получите ожидания службы должен быть создан, это может занять около минуты.

7.  Уведомление будет отображаться на портале, после создания экземпляра службы. Щелкните уведомлений для просмотра в новом экземпляре службы.

    ![новое уведомление хранилища](images/AzureLabs-Lab8-16.png)

8.  Нажмите кнопку **перейти к ресурсу** кнопки в уведомлении для просмотра в новом экземпляре службы. Вы перейдете на новую страницу Общие сведения о службе хранилища экземпляра.

    ![Перейти к ресурсу](images/AzureLabs-Lab8-17.PNG)

9. На странице обзора, в правой части окна щелкните **таблиц**.
    
    ![](images/AzureLabs-Lab8-18.PNG)

10. На правой панели появятся **служба таблиц** сведения, в которой необходимо добавить новую таблицу. Это можно сделать, щелкнув **+** **таблицы** кнопку в левом верхнем углу.

    ![Открытие таблиц](images/AzureLabs-Lab8-19.png)

11. Новая страница отображается, при котором необходимо ввести **имя таблицы**. Это имя, которое будет использовать для обращения к данным в приложении в последующих главах. Вставьте соответствующее имя и нажмите кнопку **ОК**.

    ![Создание новой таблицы](images/AzureLabs-Lab8-20.png)    

12. После создания новой таблицы, можно будет увидеть в **служба таблиц** страницы (внизу).

    ![создать новую таблицу](images/AzureLabs-Lab8-21.png)
    

## <a name="chapter-5---completing-the-azure-table-in-visual-studio"></a>Глава 5 - завершение работы таблицы Azure в Visual Studio

Теперь, когда ваш **служба таблиц** учетной записи хранения установлен и настроен, пришло время для добавления данных, который будет использоваться для хранения и извлечения данных. Редактирование таблиц можно сделать с помощью **Visual Studio**.

1.  Откройте **Visual Studio**.

2.  В меню **представление** > **Cloud Explorer**.

    ![Откройте cloud explorer](images/AzureLabs-Lab8-22.png)

3.  **Cloud Explorer** будут открываться как закрепленного элемента (быть пациента, так как загрузка может занять время).

    > [!NOTE] 
    > Если подписка использовалась для создания вашего *учетные записи хранения* не отображается, убедитесь, что у вас есть: 
    > - Вход в ту же учетную запись, которая использовалась для портала Azure.
    > - Выбранные подписки на странице управления учетной записью (может потребоваться применить фильтр из параметров учетной записи):  
    >
    >   ![найти подписку](images/AzureLabs-Lab8-22-5.png)

4.  Будут показаны облачных служб Azure. Найти **учетные записи хранения** и щелкните стрелку влево, чтобы развернуть учетные записи.

    ![Откройте учетные записи хранения](images/AzureLabs-Lab8-23.png)

5.  После развернут, только что созданный **учетной записи хранения** должны быть доступны. Щелкните стрелку слева от хранилища и найдите после, развернута, **таблиц** и щелкните стрелку рядом с ним, чтобы отобразить **таблицы** созданный в предыдущей главе. Дважды щелкните ваш **таблицы**.

    ![Откройте таблицу объектов сцены](images/AzureLabs-Lab8-24.png)

6.  Таблица откроется в центре окна Visual Studio. Щелкните значок таблицы с **+** (плюс) на нем.

    ![Добавление новой таблицы](images/AzureLabs-Lab8-25.png)

7.  Откроется окно с запроса позволяет *Добавление сущности*. Вы создадите три сущности в целом, каждая из которых несколько свойств. Можно будет заметить, что *PartitionKey* и *RowKey* уже предоставляются, так как они используются в таблице для поиска данных. 

    ![ключ раздела и строки](images/AzureLabs-Lab8-26.png)

8. Обновление *значение* из **PartitionKey** и **RowKey** следующим образом (не забудьте сделать это для каждого свойства строки, добавить, однако увеличивайте RowKey каждый раз):

    ![добавить правильные значения](images/AzureLabs-Lab8-26-5.png)

9.  Нажмите кнопку **добавить свойство** для добавления дополнительных строк данных. Сделайте вашей первой пустой соответствует приведенной ниже таблице.

10. Нажмите кнопку **ОК** при завершении работы.

    ![После завершения, нажмите кнопку ОК](images/AzureLabs-Lab8-27.png)

    > [!WARNING] 
    > Убедитесь, что вы изменили **тип** из **X**, **Y**, и **Z**, записи, чтобы **двойные**. 

11. Можно заметить, что таблица теперь содержит строки данных. Нажмите кнопку **+** (плюс) значок снова, чтобы добавить другой сущности.

    ![Первая строка](images/AzureLabs-Lab8-27-5.png)

12. Создайте дополнительное свойство, а затем задайте значения новой сущности в соответствии с показанным ниже.

    ![Добавление куба](images/AzureLabs-Lab8-28.png)

13. Повторите последний шаг, чтобы добавить другой сущности. Задайте значения для этой сущности с приведенными ниже.

    ![добавить цилиндр](images/AzureLabs-Lab8-29.png)

14. Таблица теперь должна выглядеть, как показано ниже.

    ![Полный таблицы](images/AzureLabs-Lab8-30.png)

15. В этой главе завершена. Убедитесь в том, что для сохранения.

## <a name="chapter-6---create-an-azure-function-app"></a>Глава 6 - создание приложения-функции Azure

Создайте приложение-функцию Azure, который будет вызываться приложением рабочего стола для обновления **таблицы** обработки и отправки уведомления через **концентратора уведомлений**.

Во-первых необходимо создать файл, который позволит загружать библиотеки, необходимые функции Azure.

1.  Откройте **Блокнот** (нажмите клавишу Windows ключ и тип Блокнот).

    ![Откройте в блокноте](images/AzureLabs-Lab8-31.png)

2.  Откройте Блокнот вставьте в него приведенную ниже структуру JSON. Как только вы это сделали, сохраните его на рабочем столе как **project.json**. Очень важно, что система именования верен: обеспечить его **нет .txt** расширение файла. Этот файл определяет библиотек, которые будет использовать функции, при использовании NuGet, она покажется.

    ```json
    {
    "frameworks": {
        "net46":{
        "dependencies": {
            "WindowsAzure.Storage": "7.0.0",
            "Microsoft.Azure.NotificationHubs" : "1.0.9",
            "Microsoft.Azure.WebJobs.Extensions.NotificationHubs" :"1.1.0"
        }
        }
    }
    }
    ```

3.  Войдите в [портала Azure](https://portal.azure.com).

4.  После входа в систему щелкните **New** в левом верхнем углу, а поиск **приложения-функции**, нажмите клавишу **ввод**.

    ![Поиск приложения-функции](images/AzureLabs-Lab8-32.png)

    > [!NOTE] 
    > Слово **New** может были заменены **создать ресурс**, в новых порталов.

5.  Новая страница будет предоставить описание **приложения-функции** службы. В нижней левой части этого запроса, выберите **создать** кнопку, чтобы создать ассоциацию с этой службой.

    ![экземпляре приложения-функции](images/AzureLabs-Lab8-33.png)

6.  Когда вы перейдете на **создать**, задайте приведенные ниже:

    1. Для **имя_приложения**, вставить желаемого имени для данного экземпляра службы.

    2. Выберите **подписки**.

    3. Выберите ценовую категорию, соответствующие, если это первое время создания **функция службы приложений**, уровень "бесплатный" должны быть доступны для вас.

    4. Выберите **группы ресурсов** или создайте новую. Группа ресурсов предоставляет способ отслеживания, контроля доступа, Подготовка и управление выставлением счетов для набора средств Azure. Рекомендуется хранить все службы Azure, связанные с один проект (например, такие как многому) в разделе общей группы ресурсов).

        > Если вы хотите получить дополнительные сведения о группах ресурсов Azure, выполните инструкции из этого [ссылку на управление группой ресурсов](https://docs.microsoft.com/azure/azure-resource-manager/resource-group-portal).

    5. Для **ОС**, нажмите кнопку Windows, так как целевую платформу.

    6. Выберите **текущему плану размещения и** (этот учебник использование **план потребления**.

    7. Выберите **расположение** **(выберите то же расположение, как хранилище, вы создали на предыдущем шаге)**

    8. Для **хранения** разделе **необходимо выбрать службу хранения, созданную на предыдущем шаге**.

    9. Вам не потребуется *Application Insights* в этом приложении, поэтому вы можете оставить его **Off**.

    10. Нажмите кнопку **Создать**.

        ![Создайте новый экземпляр](images/AzureLabs-Lab8-34.png)

7.  Когда вы перейдете на **создать** имеется ожидания службы должен быть создан, это может занять около минуты.

8.  Уведомление будет отображаться на портале, после создания экземпляра службы.

    ![новое уведомление](images/AzureLabs-Lab8-35.png)

9.  Щелкните уведомлений для просмотра в новом экземпляре службы.

10. Нажмите кнопку **перейти к ресурсу** кнопки в уведомлении для просмотра в новом экземпляре службы. 

    ![Перейти к ресурсу](images/AzureLabs-Lab8-36.png)

11. Нажмите кнопку **+** (плюс) значок рядом с полем *функции*, *создать*.

    ![Добавление новой функции](images/AzureLabs-Lab8-37.png)

12. На центральной панели **функция** откроется окно создания. Пропустили информацию в верхней половине панели и нажмите кнопку **пользовательская функция**, который находится ближе к нижней (в синей области, как показано ниже).

    ![Пользовательская функция](images/AzureLabs-Lab8-38.png)

13. На новой странице в окне будет отображаться различные типы функций. Прокрутите вниз, чтобы просмотреть типы сиреневый и нажмите кнопку **HTTP PUT** элемент.

    ![HTTP put ссылку](images/AzureLabs-Lab8-39.png)

    > [!IMPORTANT]
    > Может потребоваться переместитесь дальше в списке страницы (и этот образ может выглядеть точно так же, если производились обновления портала Azure), однако вы ищете элемент, названный *HTTP PUT*.

14. **HTTP PUT** появится окно, где необходимо настроить функцию (см. ниже изображения).

    1.  Для **языка,** с помощью раскрывающегося меню выберите C\#.

    2.  Для **имя** введите соответствующее имя.

    3.  В **уровень проверки подлинности** раскрывающемся меню выберите **функция**.

    4.  Для **имя таблицы** разделе, необходимо использовать правильное имя, вы использовали для создания вашего **таблицы** службы ранее (включая тот же регистр букв).

    5.  В рамках **подключение к учетной записи хранения** раздела, из раскрывающегося меню и выберите свою учетную запись хранения из него. Если он не существует, щелкните **New** hyperlink наряду с название раздела, чтобы показать другую панель, где должна быть указана вашей учетной записи хранения.

        ![новое хранилище](images/AzureLabs-Lab8-40.png)

15. Нажмите кнопку **создать** и вы получите уведомление, что ваши параметры успешно обновлены.

    ![Создание функции](images/AzureLabs-Lab8-41.png)

16. После нажатия кнопки **создать**, вы будете перенаправлены к редактору функции.

    ![Обновление кода функции](images/AzureLabs-Lab8-42.png)

17. Вставьте следующий код в редакторе функцию (заменив код в функции):

    ```csharp
    #r "Microsoft.WindowsAzure.Storage"

    using System;
    using Microsoft.WindowsAzure.Storage;
    using Microsoft.WindowsAzure.Storage.Table;
    using Microsoft.Azure.NotificationHubs;
    using Newtonsoft.Json;

    public static async Task Run(UnityGameObject gameObj, CloudTable table, IAsyncCollector<Notification> notification, TraceWriter log)
    {
        //RowKey of the table object to be changed
        string rowKey = gameObj.RowKey;

        //Retrieve the table object by its RowKey
        TableOperation operation = TableOperation.Retrieve<UnityGameObject>("UnityPartitionKey", rowKey); 

        TableResult result = table.Execute(operation);

        //Create a UnityGameObject so to set its parameters
        UnityGameObject existingGameObj = (UnityGameObject)result.Result; 

        existingGameObj.RowKey = rowKey;
        existingGameObj.X = gameObj.X;
        existingGameObj.Y = gameObj.Y;
        existingGameObj.Z = gameObj.Z;

        //Replace the table appropriate table Entity with the value of the UnityGameObject
        operation = TableOperation.Replace(existingGameObj); 

        table.Execute(operation);

        log.Verbose($"Updated object position");

        //Serialize the UnityGameObject
        string wnsNotificationPayload = JsonConvert.SerializeObject(existingGameObj);
        
        log.Info($"{wnsNotificationPayload}");

        var headers = new Dictionary<string, string>();

        headers["X-WNS-Type"] = @"wns/raw";

        //Send the raw notification to subscribed devices
        await notification.AddAsync(new WindowsNotification(wnsNotificationPayload, headers)); 

        log.Verbose($"Sent notification");
    }

    // This UnityGameObject represent a Table Entity
    public class UnityGameObject : TableEntity
    {
        public string Type { get; set; }
        public double X { get; set; }
        public double Y { get; set; }
        public double Z { get; set; }
        public string RowKey { get; set; }
    }
    ```

    > [!NOTE]
    > С помощью включенных библиотек, эта функция получает имя и расположение объекта, который был перемещен в сцене Unity (как C# объекта, называемого **UnityGameObject**). Затем этот объект используется для обновления параметров объектов в созданной таблице. После этого функция делает вызов к службе созданный концентратор уведомлений, который уведомляет о всех подписанных приложений.

18. С помощью кода в месте, нажмите кнопку **Сохранить**.

19. Затем щелкните **\<** значок (стрелка), в правой части страницы.

    ![Откройте передачи панели](images/AzureLabs-Lab8-43.png)

20. Панель будет слайд в справа. В этой панели, щелкните **отправить**, и будет отображаться в обозревателе файлов.

21. Перейдите к и нажмите кнопку, **project.json** файл, который вы создали в **Блокнот** ранее и нажмите кнопку **откройте** кнопки. Этот файл определяет библиотеки, на которые будет использовать функции.

    ![Отправка json](images/AzureLabs-Lab8-44.png)

22. Когда файл отправлен, он будет отображаться на панели справа. Если щелкнуть его, откроется его в **функция** редактора. Он должен выглядеть **точно** так же, как Далее (см. ниже шаг 23).

23. Затем в панели слева, под **функции**, нажмите кнопку **интегрировать** ссылку.

    ![Интегрируйте функции](images/AzureLabs-Lab8-45.png)

24. На следующей странице в правом верхнем углу, щелкните **расширенный редактор** (как показано ниже).

    ![откройте расширенный редактор](images/AzureLabs-Lab8-46.png)

25. Объект **function.json** на центральной панели, который необходимо заменить на следующий фрагмент кода будет открыт файл. Он определяет функцию, вы создаете и параметры передаваемые в функцию.

    ```json
    {
    "bindings": [
        {
        "authLevel": "function",
        "type": "httpTrigger",
        "methods": [
            "get",
            "post"
        ],
        "name": "gameObj",
        "direction": "in"
        },
        {
        "type": "table",
        "name": "table",
        "tableName": "SceneObjectsTable",
        "connection": "mrnothubstorage_STORAGE",
        "direction": "in"
        },
        {
        "type": "notificationHub",
        "direction": "out",
        "name": "notification",
        "hubName": "MR_NotHub_ServiceInstance",
        "connection": "MRNotHubNS_DefaultFullSharedAccessSignature_NH",
        "platform": "wns"
        }
    ]
    }
    ```

26. В редакторе теперь должна выглядеть как на следующем рисунке:

    ![к стандартным редактором](images/AzureLabs-Lab8-47.png)

27. Вы можете заметить, входные параметры, которые добавлены может не соответствовать сведениях о таблице и хранилище и поэтому потребуется обновить, используя ваши сведения. **Не делайте этого, здесь**, как оно описано далее. Просто щелкните **стандартный редактор** ссылку в правом верхнем углу страницы, чтобы вернуться назад.

28. Вернитесь в **стандартный редактор**, нажмите кнопку **Azure Table Storage (таблица)** в разделе **входных данных**. 
    
    ![Входные данные таблицы](images/AzureLabs-Lab8-47-5.png)

29. Следующие совпадение, чтобы обеспечить **вашей** сведения, как они могут отличаться (есть изображения до размера менее ниже):

    1.  **Имя таблицы**: имя таблицы, созданной в хранилище Azure, служба таблиц.

    2.  **Подключение к учетной записи хранения:** щелкните **новый**, которая отображается вместе с в раскрывающемся меню и панель будет отображаться в правой части окна.

        ![новое хранилище](images/AzureLabs-Lab8-48.png)

        1.  Выберите ваш **учетной записи хранения**, который был создан ранее для размещения **приложения-функции.**

        2. Можно будет заметить, что **учетной записи хранения** значение подключения будет создана.

        3. Убедитесь, что клавишу **Сохранить** после завершения.

    3.  **Входные данные** странице теперь должно соответствовать ниже, показывающий **вашей** сведения.

        ![завершить входных данных](images/AzureLabs-Lab8-49.png)

30. Затем щелкните **Azure центра уведомлений (уведомление)** — в разделе **выходные данные**. Убедитесь, соответствуют следующие **вашей** сведения, как они могут отличаться (есть изображения до размера менее ниже):

    1.  **Имя концентратора уведомлений**: это имя вашего **концентратора уведомлений** экземпляр службы, который был создан ранее.

    2.  **Подключение к пространству имен концентраторов уведомлений**: щелкните **новый**, которая отображается вместе с в раскрывающемся меню.

        ![Проверьте выходные данные](images/AzureLabs-Lab8-50.png)

    3. **Подключения** Откроется всплывающее окно (см. рисунок ниже), где необходимо выбрать **пространства имен** из **концентратора уведомлений**, настроенной ранее.

    4. Выберите ваш **концентратора уведомлений** имя в среднем раскрывающемся меню.

    5.  Задайте **политики** раскрывающемся меню **DefaultFullSharedAccessSignature**.

    6. Нажмите кнопку **выберите** кнопку, чтобы вернуться назад.

        ![Обновление выходных данных](images/AzureLabs-Lab8-51.png)

31.  **Выходные данные** странице теперь должно соответствовать ниже, но с **вашей** сведения вместо этого. Убедитесь, что клавишу **Сохранить**.

> [!WARNING]
> *Не изменять имя центра уведомлений напрямую* (должны все это сделать с помощью **расширенный редактор**, если предыдущие шаги выполнены правильно.

![Выводит полный](images/AzureLabs-Lab8-50.png)

32. На этом этапе следует протестировать функцию, чтобы убедиться, что он работает. Выполните указанные ниже действия. 

    1. Перейдите на страницу функции еще раз:

        ![Выводит полный](images/AzureLabs-Lab8-50-1.png)

    2. На странице «функция» нажмите **теста** вкладка в крайней правой части страницы, чтобы открыть *теста* колонке:

        ![Выводит полный](images/AzureLabs-Lab8-50-2.png)

    3. В рамках **текст запроса** textbox колонки вставить ниже кода:

        ```
        {  
            "Type":null,
            "X":3,
            "Y":0,
            "Z":1,
            "PartitionKey":null,
            "RowKey":"Obj2",
            "Timestamp":"0001-01-01T00:00:00+00:00",
            "ETag":null
        }
        ```

    4. Тестовый код на месте, щелкните **запуска** кнопку в правом нижнем углу, а тест будет выполняться. Журналы выходные данные теста будут отображаться в области консоли под код функции.

        ![Выводит полный](images/AzureLabs-Lab8-50-3.png)

    > [!WARNING]
    > Если выше тест не пройден, необходимо тщательно проверить, что указанные выше шаги выполнены точно, особенно параметров в рамках **интегрировать панели**. 

## <a name="chapter-7---set-up-desktop-unity-project"></a>Глава 7 - Настройка проекта Unity рабочего стола

> [!IMPORTANT]
> Классическое приложение, в которой вы создаете теперь **не** работают в редакторе Unity. Он должен быть запущен вне редактора, выполнив построение приложения, с помощью Visual Studio (или развернутое приложение). 

Следующие запущена типичный набор для разработки с помощью Unity и смешанной реальности и, таким образом, — это хороший шаблон для других проектов.

Настроить и проверить ваш иммерсивных гарнитуры смешанной реальности.

> [!NOTE] 
> Вы будете **не** требуются контроллеры движения курс с демороликами. Если вам нужна поддерживает настройку иммерсивных гарнитуры, выполните инструкции из этого [ссылку о том, как настроить Windows Mixed Reality](https://support.microsoft.com/en-au/help/4043101/windows-10-set-up-windows-mixed-reality).

1.  Откройте **Unity** и нажмите кнопку **New**.

    ![новый проект unity](images/AzureLabs-Lab8-52.png)

2.  Необходимо указать имя проекта Unity, вставить **UnityDesktopNotifHub**. Убедитесь, что тип проекта присваивается **3D**. Задайте **расположение** в другое место, наиболее подходящего для вас (Помните, что лучше, чем ближе к корневые каталоги). Щелкните **создать проект**.

    ![Создание проекта](images/AzureLabs-Lab8-53.png)

3.  С помощью Unity откройте, стоит проверки по умолчанию **редактор сценариев** присваивается **Visual Studio**. Перейдите к **изменить** > **предпочтения** и затем в окне «Новый» перейдите к **внешние средства**. Изменение **внешнего редактора скриптов** для **Visual Studio 2017**. Закрыть **предпочтения** окна.

    ![набор внешних инструментов VS](images/AzureLabs-Lab8-54.png)

4.  Перейдите к **файл** > **параметры построения** и выберите **универсальной платформы Windows**, затем щелкните **переключить платформу**кнопку, чтобы применить выбранные параметры.

    ![переключение платформ](images/AzureLabs-Lab8-55.png)

5.  Оставаясь в **файл** > **параметры построения**, убедитесь, что:

    1.  **Целевое устройство** присваивается **любого устройства**

        > Это приложение будет для рабочего стола, поэтому должны быть **любого устройства**

    2.  **Тип сборки** присваивается **D3D**

    3.  **Пакет SDK для** присваивается **самую новую установленную**

    4.  **Версия Visual Studio** присваивается **самую новую установленную**

    5.  **Сборка и запуск** присваивается **локального компьютера**

    6.  Здесь стоит сохранение сцены и его добавления к сборке.

        1. Это сделать, выбрав **добавьте откройте сцены**. Сохранение окно будет отображаться.

            ![Добавление открытых сцен](images/AzureLabs-Lab8-56.png)

        2. Создайте новую папку и все будущие, сцены, затем выберите **новую папку** кнопку, чтобы создать новую папку, назовите его **сцены**.

            ![Новая папка сцены](images/AzureLabs-Lab8-57.png)

        3. Откройте только что созданный **сцены** папку, а затем в **имя файла:** текстовое поле, тип **NH\_рабочего стола\_сцены**, нажмите клавишу **Сохранить**.

            ![новый NH_Desktop_Scene](images/AzureLabs-Lab8-58.png)

    7.  Для остальных параметров, в **параметры построения**, следует оставить значение по умолчанию сейчас.

6.  В одном окне щелкните **параметры проигрывателя** кнопки откроется панель связанных в пространстве где **инспектор** находится.

7.  В этой панели необходимо проверить некоторые настройки:

    1.  В **другие параметры** вкладке:

        1.  **Версия среды выполнения сценариев** должно быть **экспериментальная (эквивалент 4.6 .NET)**

        2. **Создание сценариев серверной части** должно быть **.NET**

        3. **Уровень совместимости API** должно быть **.NET 4.6**

            ![версия 4.6 net](images/AzureLabs-Lab8-59.png)

    2.  В рамках **параметров публикации** в списке **возможности**, проверьте:

        - **internetClient**

            ![Интернет-клиент делений](images/AzureLabs-Lab8-60.png)

8.  Вернитесь в **параметры построения** *Unity C\# проекты* больше не отображается серым, установите флажок рядом с это.

9.  Закрыть **параметры построения** окна.

10. Сохраните сцену и проект **файл** > **сохранить сцену / File** > **сохраните проект**.

    > [!IMPORTANT]
    > Если вы хотите пропустить *Настройка Unity* компонента для этого проекта (приложение рабочего стола) и по-прежнему непосредственно в код, вы можете [загрузить этот .unitypackage](https://github.com/Microsoft/HolographicAcademy/raw/Azure-MixedReality-Labs/Azure%20Mixed%20Reality%20Labs/MR%20and%20Azure%20308%20-%20Cross-device%20notifications/Azure-MR-308-Desktop.unitypackage), импортировать его в проект в качестве [ **Пользовательского пакета**](https://docs.unity3d.com/Manual/AssetPackages.html), а затем продолжить из [Глава 9](#chapter-9---create-the-tabletoscene-class-in-the-desktop-unity-project).  По-прежнему необходимо будет добавить компонентов скрипта.

## <a name="chapter-8---importing-the-dlls-in-unity"></a>Глава 8 - импорт библиотеки DLL в Unity

Вы будете использовать службу хранилища Azure для Unity (который сам использует пакет SDK для Azure .net). Дополнительные сведения по этой [ссылку о службе хранилища Azure для Unity](https://docs.microsoft.com/sandbox/gamedev/unity/azure-storage-unity).

В Unity, который требует подключаемых модулей, чтобы повторно настроить после импорта в настоящее время имеется известная проблема. Эти шаги (4 – 7 в этом разделе), не будет обязательным после устранения ошибки.

Чтобы импортировать пакет SDK в свой проект, убедитесь, что вы скачали последнюю версию [ **.unitypackage** ](https://aka.ms/azstorage-unitysdk) из GitHub. Затем сделайте следующее:

1.  Добавить **.unitypackage** к Unity с помощью **активы \> Импорт пакета \> пользовательского пакета** пункт меню.

2.  В **Импорт пакета Unity** поле, отобразятся, вы сможете выбрать все данные ***подключаемый модуль* \> * хранилища ***.  Снимите флажок, все остальное, так как он не требуется для этого курса.

    ![Импорт пакета](images/AzureLabs-Lab8-61.png)

3.  Нажмите кнопку ***импорта*** кнопку, чтобы добавить элементы в проект.

4.  Перейдите к **хранения** папке **подключаемые модули** в проекте можно просматривать и выбирать следующие подключаемые модули *только*:

    -   Microsoft.Data.Edm
    -   Microsoft.Data.OData
    -   Microsoft.WindowsAzure.Storage
    -   Newtonsoft.Json
    -   System.Spatial

![Снимите флажок для любой платформы](images/AzureLabs-Lab8-62.png)

5.  С помощью *этих конкретных подключаемых модулей* выбран, **снимите** **Any платформы** и **снимите флажок** **WSAPlayer** Нажмите кнопку **применить**.

    ![Применение платформы библиотек DLL](images/AzureLabs-Lab8-63.png)

    > [!NOTE] 
    > Мы отмечаем эти определенного подключаемые модули можно использовать только в редакторе Unity. Это, так как существуют различные версии одной подключаемые модули в папку WSA, которая будет использоваться после проект будет экспортирован из Unity.

6.  В **хранения** папку подключаемый модуль, выберите только:

    -   Microsoft.Data.Services.Client

        ![не обрабатывать набор библиотек DLL](images/AzureLabs-Lab8-64.png)

7.  Проверьте **процесса не** поле в разделе **параметры платформы** и нажмите кнопку ***применить***.

    ![применить без обработки](images/AzureLabs-Lab8-65.png)

    > [!NOTE] 
    > Мы отмечаем этот подключаемый модуль «Не обрабатывать», так как средство исправления сборки Unity имеет сложности обработки этот подключаемый модуль. Подключаемый модуль по-прежнему будет работать, несмотря на то, что он не обрабатывается.

## <a name="chapter-9---create-the-tabletoscene-class-in-the-desktop-unity-project"></a>Глава 9 — создать класс TableToScene в проекте Unity рабочего стола

Теперь необходимо создать скрипты, содержащий код для запуска этого приложения.

Первый скрипт, чтобы создать **TableToScene**, который отвечает за:

-   Читать сущности таблицы Azure.
-   С помощью данных из таблицы, определить, какие объекты для создания и их расположение.

Второй сценарий, вам нужно создать — **CloudScene**, который отвечает за:

-   Регистрация событий левой кнопкой мыши щелкните, чтобы разрешить пользователю перетаскивать объекты относительно сцены.
-   Сериализация данных объекта из этой сценой Unity и их отправки в приложение-функцию Azure.

Для создания этого класса:

1.  Щелкните правой кнопкой мыши в **активов** папка находится в панели «проект» **создать** > **папку**. Назовите папку **сценариев**.

    ![Создайте папку скриптов](images/AzureLabs-Lab8-66.png)

    ![Создайте папку сценарии 2](images/AzureLabs-Lab8-67.png)

2.  Дважды щелкните папку, только что создали, чтобы открыть его.

3.  Щелкните правой кнопкой мыши внутри **сценарии** папку, нажмите кнопку **создать**  >   **C# сценарий**. Назовите сценарий **TableToScene**.

    ![скрипт c#](images/AzureLabs-Lab8-68.png)
    ![TableToScene переименования](images/AzureLabs-Lab8-69.png)

4.  Дважды щелкните его, чтобы открыть его в Visual Studio 2017.

5.  Добавьте следующие пространства имен:

    ```csharp
    using Microsoft.WindowsAzure.Storage;
    using Microsoft.WindowsAzure.Storage.Auth;
    using Microsoft.WindowsAzure.Storage.Table;
    using UnityEngine;
    ```

6.  К классу вставьте следующие переменные:

    ```csharp
        /// <summary>    
        /// allows this class to behave like a singleton
        /// </summary>    
        public static TableToScene instance;

        /// <summary>    
        /// Insert here you Azure Storage name     
        /// </summary>    
        private string accountName = " -- Insert your Azure Storage name -- ";

        /// <summary>    
        /// Insert here you Azure Storage key    
        /// </summary>    
        private string accountKey = " -- Insert your Azure Storage key -- ";
    ```
    
    > [!NOTE] 
    > Substitute **accountName** значение с именем вашей службы хранилища Azure и **accountKey** значение со значением ключа, имеющиеся в службе хранилища Azure, на портале Azure (см. рисунок ниже). 
    >
    > ![ключ учетной записи выборки](images/AzureLabs-Lab8-70.png)

7.  Теперь добавьте **Start()** и **Awake()** методы для инициализации класса.

    ```csharp
        /// <summary>
        /// Triggers before initialization
        /// </summary>
        void Awake()
        {
            // static instance of this class
            instance = this;
        }

        /// <summary>
        /// Use this for initialization
        /// </summary>
        void Start()
        {  
            // Call method to populate the scene with new objects as 
            // pecified in the Azure Table
            PopulateSceneFromTableAsync();
        }
    ```

8.  В рамках **TableToScene** добавьте метод, который будет извлекать значения из таблиц Azure и использовать их для создания соответствующих примитивы в сцене.

    ```csharp
        /// <summary>    
        /// Populate the scene with new objects as specified in the Azure Table    
        /// </summary>    
        private async void PopulateSceneFromTableAsync()
        {
            // Obtain credentials for the Azure Storage
            StorageCredentials creds = new StorageCredentials(accountName, accountKey);

            // Storage account
            CloudStorageAccount account = new CloudStorageAccount(creds, useHttps: true);
            
            // Storage client
            CloudTableClient client = account.CreateCloudTableClient(); 
            
            // Table reference
            CloudTable table = client.GetTableReference("SceneObjectsTable");

            TableContinuationToken token = null;

            // Query the table for every existing Entity
            do
            {
                // Queries the whole table by breaking it into segments
                // (would happen only if the table had huge number of Entities)
                TableQuerySegment<AzureTableEntity> queryResult = await table.ExecuteQuerySegmentedAsync(new TableQuery<AzureTableEntity>(), token); 

                foreach (AzureTableEntity entity in queryResult.Results)
                {
                    GameObject newSceneGameObject = null;
                    Color newColor;

                    // check for the Entity Type and spawn in the scene the appropriate Primitive
                    switch (entity.Type)
                    {
                        case "Cube":
                            // Create a Cube in the scene
                            newSceneGameObject = GameObject.CreatePrimitive(PrimitiveType.Cube);
                            newColor = Color.blue;
                            break;

                        case "Sphere":
                            // Create a Sphere in the scene
                            newSceneGameObject = GameObject.CreatePrimitive(PrimitiveType.Sphere);
                            newColor = Color.red;
                            break;

                        case "Cylinder":
                            // Create a Cylinder in the scene
                            newSceneGameObject = GameObject.CreatePrimitive(PrimitiveType.Cylinder);
                            newColor = Color.yellow;
                            break;
                        default:
                            newColor = Color.white;
                            break;
                    }

                    newSceneGameObject.name = entity.RowKey;

                    newSceneGameObject.GetComponent<MeshRenderer>().material = new Material(Shader.Find("Diffuse"))
                    {
                        color = newColor
                    };

                    //check for the Entity X,Y,Z and move the Primitive at those coordinates
                    newSceneGameObject.transform.position = new Vector3((float)entity.X, (float)entity.Y, (float)entity.Z);
                }

                // if the token is null, it means there are no more segments left to query
                token = queryResult.ContinuationToken;
            }

            while (token != null);
        }
    ```

9.  За пределами **TableToScene** класса, необходимо определить класс, используемый приложением для сериализации и десериализации **сущностей таблицы**.

    ```csharp
        /// <summary>
        /// This objects is used to serialize and deserialize the Azure Table Entity
        /// </summary>
        [System.Serializable]
        public class AzureTableEntity : TableEntity
        {
            public AzureTableEntity(string partitionKey, string rowKey)
                : base(partitionKey, rowKey) { }

            public AzureTableEntity() { }
            public string Type { get; set; }
            public double X { get; set; }
            public double Y { get; set; }
            public double Z { get; set; }
        }
    ```

10. Убедитесь, что **Сохранить** перед вернуться в редактор Unity.

11. Нажмите кнопку **Main Camera** из **иерархии** панели, чтобы ее свойства появились на **инспектор**.

12. С помощью **сценарии** папку открыт, выберите сценарий **файл TableToScene** и перетащите его на **Main Camera**. Результат должен быть следующим образом:

    ![Добавьте скрипт к главной камеры](images/AzureLabs-Lab8-71.png)

## <a name="chapter-10---create-the-cloudscene-class-in-the-desktop-unity-project"></a>Глава 10 — создать класс CloudScene в проекте Unity рабочего стола

Второй сценарий, вам нужно создать — **CloudScene**, который отвечает за:

-   Регистрация событий левой кнопкой мыши щелкните, чтобы разрешить пользователю перетаскивать объекты относительно сцены.

-   Сериализация данных объекта из этой сценой Unity и их отправки в приложение-функцию Azure.

Чтобы создать второй скрипт:

1.  Щелкните правой кнопкой мыши внутри **сценарии** папку, нажмите кнопку **создать**, **C\# скрипт**. Назовите сценарий **CloudScene**
    
    ![скрипт c#](images/AzureLabs-Lab8-72.png)
    ![переименовать CloudScene](images/AzureLabs-Lab8-73.png)

2.  Добавьте следующие пространства имен:

    ```csharp
    using Newtonsoft.Json;
    using System.Collections;
    using System.Text;
    using System.Threading.Tasks;
    using UnityEngine;
    using UnityEngine.Networking;
    ```

3.  Вставьте следующие переменные:

    ```csharp
        /// <summary>
        /// Allows this class to behave like a singleton
        /// </summary>
        public static CloudScene instance;

        /// <summary>
        /// Insert here you Azure Function Url
        /// </summary>
        private string azureFunctionEndpoint = "--Insert here you Azure Function Endpoint--";

        /// <summary>
        /// Flag for object being moved
        /// </summary>
        private bool gameObjHasMoved;

        /// <summary>
        /// Transform of the object being dragged by the mouse
        /// </summary>
        private Transform gameObjHeld;

        /// <summary>
        /// Class hosted in the TableToScene script
        /// </summary>
        private AzureTableEntity azureTableEntity;
    ```

4.  Substitute **azureFunctionEndpoint** значение URL приложения функции Azure, находится в службе приложений Azure функцию на портале Azure, как показано на рисунке ниже:

    ![получить URL-адрес функции](images/AzureLabs-Lab8-74.png)

5.  Теперь добавьте **Start()** и **Awake()** методы для инициализации класса.

    ```csharp
        /// <summary>
        /// Triggers before initialization
        /// </summary>
        void Awake()
        {
            // static instance of this class
            instance = this;
        }

        /// <summary>
        /// Use this for initialization
        /// </summary>
        void Start()
        {
            // initialise an AzureTableEntity
            azureTableEntity = new AzureTableEntity();
        }
    ```

6.  В рамках **Update()** метод, добавьте следующий код, который обнаруживает ввод от мыши и перетащите элемент, который в свою очередь будет переместить объекты Gameobject в сцене. Если пользователь перетащен объекта, он передает названия и координат объекта метод **UpdateCloudScene()** , который будет вызывать службу приложения-функции Azure, которая обновит Azure таблицы и триггера уведомление.

    ```csharp
        /// <summary>
        /// Update is called once per frame
        /// </summary>
        void Update()
        {
            //Enable Drag if button is held down
            if (Input.GetMouseButton(0))
            {
                // Get the mouse position
                Vector3 mousePosition = new Vector3(Input.mousePosition.x, Input.mousePosition.y, 10);

                Vector3 objPos = Camera.main.ScreenToWorldPoint(mousePosition);

                Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);

                RaycastHit hit;

                // Raycast from the current mouse position to the object overlapped by the mouse
                if (Physics.Raycast(ray, out hit))
                {
                    // update the position of the object "hit" by the mouse
                    hit.transform.position = objPos;

                    gameObjHasMoved = true;

                    gameObjHeld = hit.transform;
                }
            }

            // check if the left button mouse is released while holding an object
            if (Input.GetMouseButtonUp(0) && gameObjHasMoved)
            {
                gameObjHasMoved = false;

                // Call the Azure Function that will update the appropriate Entity in the Azure Table
                // and send a Notification to all subscribed Apps
                Debug.Log("Calling Azure Function");

                StartCoroutine(UpdateCloudScene(gameObjHeld.name, gameObjHeld.position.x, gameObjHeld.position.y, gameObjHeld.position.z));
            }
        }
    ```

7.  Теперь добавьте **UpdateCloudScene()** метод, как показано ниже:

    ```csharp
        private IEnumerator UpdateCloudScene(string objName, double xPos, double yPos, double zPos)
        {
            WWWForm form = new WWWForm();

            // set the properties of the AzureTableEntity
            azureTableEntity.RowKey = objName;

            azureTableEntity.X = xPos;

            azureTableEntity.Y = yPos;

            azureTableEntity.Z = zPos;

            // Serialize the AzureTableEntity object to be sent to Azure
            string jsonObject = JsonConvert.SerializeObject(azureTableEntity);

            using (UnityWebRequest www = UnityWebRequest.Post(azureFunctionEndpoint, jsonObject))
            {
                byte[] jsonToSend = new System.Text.UTF8Encoding().GetBytes(jsonObject);

                www.uploadHandler = new UploadHandlerRaw(jsonToSend);

                www.uploadHandler.contentType = "application/json";

                www.downloadHandler = new DownloadHandlerBuffer();

                www.SetRequestHeader("Content-Type", "application/json");

                yield return www.SendWebRequest();

                string response = www.responseCode.ToString();
            }
        }
    ```

8.  Сохраните код и вернуться к Unity

9.  Перетащите **CloudScene** скрипт на **Main Camera**. 

    1. Нажмите кнопку **Main Camera** из **иерархии** панели, чтобы ее свойства появились на **инспектор**. 

    2. С помощью **сценарии** открыт, выберите папку **CloudScene** сценариев и перетащите его на **Main Camera**. Результат должен быть следующим образом:

        > ![Перетащите скрипта cloud главной камеры](images/AzureLabs-Lab8-75.png)

## <a name="chapter-11---build-the-desktop-project-to-uwp"></a>Глава 11 — построить проект для настольной системы для универсальной платформы Windows

Все необходимое для раздела этого проекта Unity теперь завершен.

1.  Перейдите к **параметры сборки** (**файл** > **параметры сборки**).

2.  Из **параметры построения** окно, нажмите кнопку **построения**.

    ![Сборка проекта](images/AzureLabs-Lab8-76.png)

3.  Объект **проводнике** будет контекстном меню окна, для расположения для сборки. Создайте новую папку (щелкнув **новую папку** в левом верхнем углу) и назовите его **ПОСТРОЕНИЯ**.

    ![новую папку для сборки](images/AzureLabs-Lab8-77.png)

    1.  Откройте новый **ПОСТРОЕНИЯ** папки и создайте другую папку (с помощью **новую папку** еще раз) и назовите его **NH\_Desktop\_приложения**.

        ![Имя папки NH_Desktop_App](images/AzureLabs-Lab8-78.png)

    2.  С помощью **NH\_Desktop\_приложения** выбранного. Нажмите кнопку **выберите папку**. Проекта займет около минуты для построения.

4.  После построения **проводнике** появится расположение нового проекта. Нет необходимости, чтобы открыть его, то, что, как вам нужно создать другой Unity project во-первых, в следующие несколько глав посвящены.


## <a name="chapter-12---set-up-mixed-reality-unity-project"></a>Глава 12 - Настройка проекта Unity смешанной реальности

Следующие запущена типичный набор для разработки с помощью смешанной реальности и, таким образом, — это хороший шаблон для других проектов.

1.  Откройте **Unity** и нажмите кнопку **New**.

    ![новый проект unity](images/AzureLabs-Lab8-79.png)

2.  Введите имя проекта Unity, теперь нужно вставить **UnityMRNotifHub**. Убедитесь, что тип проекта присваивается **3D**. Задайте **расположение** в другое место, наиболее подходящего для вас (Помните, что лучше, чем ближе к корневые каталоги). Щелкните **создать проект**.

    ![Имя UnityMRNotifHub](images/AzureLabs-Lab8-80.png)

3.  С помощью Unity откройте, стоит проверки по умолчанию **редактор сценариев** присваивается **Visual Studio**. Перейдите к **изменить** > **предпочтения** и затем в окне «Новый» перейдите к **внешние средства**. Изменение **внешнего редактора скриптов** для **Visual Studio 2017**. Закрыть **предпочтения** окна.

    ![набор внешний редактор в Visual STUDIO](images/AzureLabs-Lab8-81.png)

4.  Перейдите к **файл** > **параметры построения** и переключитесь на платформе, которое **универсальной платформы Windows**, щелкнув **переключения платформы**  кнопки.

    ![переключение платформ для универсальной платформы Windows](images/AzureLabs-Lab8-82.png)

5.  Перейдите к **файл** > **параметры построения** и убедитесь, что:

    1.  **Целевое устройство** присваивается **любого устройства**

        > Microsoft HoloLens, задайте **целевое устройство** для *HoloLens*.

    2.  **Тип сборки** присваивается **D3D**

    3.  **Пакет SDK для** присваивается **самую новую установленную**

    4.  **Версия Visual Studio** присваивается **самую новую установленную**

    5.  **Сборка и запуск** присваивается **локального компьютера**

    6.  Здесь стоит сохранение сцены и его добавления к сборке.

        1. Это сделать, выбрав **добавьте откройте сцены**. Сохранение окно будет отображаться.

            ![Добавление открытых сцен](images/AzureLabs-Lab8-83.png)

        2. Создайте новую папку и все будущие, сцены, затем выберите **новую папку** кнопку, чтобы создать новую папку, назовите его **сцены**.

            ![Новая папка сцены](images/AzureLabs-Lab8-84.png)

        3. Откройте только что созданный **сцены** папку, а затем в **имя файла:** текстовое поле, тип **NH\_MR\_сцены**, нажмите клавишу  **Сохранить**.

            ![создать сцену - NH_MR_Scene](images/AzureLabs-Lab8-85.png)

    7.  Для остальных параметров, в **параметры построения**, следует оставить значение по умолчанию сейчас.

6.  В одном окне щелкните **параметры проигрывателя** кнопки откроется панель связанных в пространстве где **инспектор** находится.    

    ![Открытие параметров проигрывателя](images/AzureLabs-Lab8-86.png)

7.  В этой панели необходимо проверить некоторые настройки:

    1.  В **другие параметры** вкладке:

        1.  **Версия среды выполнения сценариев** должно быть **экспериментальные** (.NET 4.6 эквивалент)
        2.  **Создание сценариев серверной части** должно быть ***.NET***
        3.  **Уровень совместимости API** должно быть **.NET 4.6**

            ![совместимость API](images/AzureLabs-Lab8-87.png)

    2.  Далее панели в **XR параметры** (под **параметры публикации**), деления **поддерживается виртуальной реальности**, убедитесь, что **смешанной реальности SDK Windows**  добавляется

        ![Обновление параметров xr](images/AzureLabs-Lab8-88.png)        

    3.  В рамках **параметров публикации** в списке **возможности**, выполнить проверку:

        - **internetClient**           

            ![Интернет-клиент делений](images/AzureLabs-Lab8-89.png)

8.  Вернитесь в **параметры построения**, **Unity C# проекты** больше не отображается серым: установите флажок рядом с это.

9.  Эти изменения закрывайте окно Параметры построения.

10. Сохраните сцену и проект **файл** > **сохранить сцену / File** > **сохраните проект**.

    > [!IMPORTANT]
    > Если вы хотите пропустить *Настройка Unity* компонента для этого проекта (смешанной реальности приложения) и по-прежнему непосредственно в код, вы можете [загрузить этот .unitypackage](https://github.com/Microsoft/HolographicAcademy/raw/Azure-MixedReality-Labs/Azure%20Mixed%20Reality%20Labs/MR%20and%20Azure%20308%20-%20Cross-device%20notifications/Azure-MR-308-MR.unitypackage), импортировать его в проект в качестве [ **Пользовательского пакета**](https://docs.unity3d.com/Manual/AssetPackages.html), а затем продолжить из [Глава 14](#chapter-14---creating-the-tabletoscene-class-in-the-mixed-reality-unity-project). По-прежнему необходимо будет добавить компонентов скрипта.

### <a name="chapter-13---importing-the-dlls-in-the-mixed-reality-unity-project"></a>Глава 13 - импорт библиотеки DLL в проекте Unity смешанной реальности

Вы будете использовать службу хранилища Azure для библиотеки Unity (с использованием пакета SDK для .net для Azure). Выполните инструкции из этого [ссылку на использование хранилища Azure с помощью Unity](https://docs.microsoft.com/sandbox/gamedev/unity/azure-storage-unity).
В Unity, который требует подключаемых модулей, чтобы повторно настроить после импорта в настоящее время имеется известная проблема. Эти шаги (4 – 7 в этом разделе), не будет обязательным после устранения ошибки.

Чтобы импортировать пакет SDK в свой проект, убедитесь, что вы скачали последнюю версию [.unitypackage](https://aka.ms/azstorage-unitysdk). Затем сделайте следующее:

1.  Добавление .unitypackage, загруженный из указанного выше, для Unity с помощью **активы** > **Импорт пакета** > **пользовательского пакета** пункт меню .

2.  В **Импорт пакета Unity** поле, отобразятся, вы сможете выбрать все данные **подключаемый модуль** > **хранения**.

    ![Импорт пакета](images/AzureLabs-Lab8-90.png)

3.  Нажмите кнопку **импорта** кнопку, чтобы добавить элементы в проект.

4.  Перейдите к **хранения** папке **подключаемые модули** в проекте можно просматривать и выбирать следующие подключаемые модули *только*:

    -   Microsoft.Data.Edm
    -   Microsoft.Data.OData
    -   Microsoft.WindowsAzure.Storage
    -   Newtonsoft.Json
    -   System.Spatial

    ![Выберите подключаемые модули](images/AzureLabs-Lab8-91.png)

5.  С помощью *этих конкретных подключаемых модулей* выбран, **снимите** **Any платформы** и **снимите флажок** **WSAPlayer** Нажмите кнопку **применить**.

    ![применить изменения в платформе](images/AzureLabs-Lab8-92.png)

    > [!NOTE] 
    > Время разметки эти определенного подключаемые модули можно использовать только в редакторе Unity. Это, так как существуют различные версии одной подключаемые модули в папку WSA, которая будет использоваться после проект будет экспортирован из Unity.

6.  В **хранения** папку подключаемый модуль, выберите только:

    -   Microsoft.Data.Services.Client

        ![Выберите клиента служб данных](images/AzureLabs-Lab8-93.png)

7.  Проверьте **процесса не** поле в разделе **параметры платформы** и нажмите кнопку **применить**.

    ![не обрабатывать](images/AzureLabs-Lab8-94.png)

    > [!NOTE] 
    > Время разметки этот подключаемый модуль «Не процесс» из-за сложности обработки этот подключаемый модуль средство исправления сборки Unity. Подключаемый модуль по-прежнему будет работать, несмотря на то, что она не обработана.

## <a name="chapter-14---creating-the-tabletoscene-class-in-the-mixed-reality-unity-project"></a>Глава 14 - Создание TableToScene класса в проекте Unity смешанной реальности

**TableToScene** совпадающее с тем, как описано в классе [Глава 9](#chapter-9---create-the-tabletoscene-class-in-the-desktop-unity-project). Создание одного класса в смешанной реальности, проект Unity таким же способом, как описано в [Глава 9](#chapter-9---create-the-tabletoscene-class-in-the-desktop-unity-project).

После завершения этой главы, оба вашей **проектов Unity** будет иметь этот класс на Main Camera.

## <a name="chapter-15---creating-the-notificationreceiver-class-in-the-mixed-reality-unity-project"></a>Глава 15 - Создание NotificationReceiver класса в проекте Unity смешанной реальности

Второй сценарий, вам нужно создать — **NotificationReceiver**, который отвечает за:

-   Регистрация приложения в центре уведомлений при инициализации.
-   Прослушивает уведомления, поступающие от концентратора уведомлений.
-   Десериализация данных объекта из полученного уведомления.
-   Переместите объекты Gameobject в сцене в зависимости от десериализованные данные.

Чтобы создать **NotificationReceiver** сценария:

1.  Щелкните правой кнопкой мыши внутри **сценарии** папку, нажмите кнопку **создать**, **C\# скрипт**. Назовите сценарий **NotificationReceiver**.

    ![создать новый скрипт c#](images/AzureLabs-Lab8-95.png)
    ![назовите его NotificationReceiver](images/AzureLabs-Lab8-96.png)

2.  Дважды щелкните сценарий, чтобы открыть его.

3.  Добавьте следующие пространства имен:

    ```csharp
    //using Microsoft.WindowsAzure.Messaging;
    using Newtonsoft.Json;
    using System;
    using System.Collections;
    using UnityEngine;

    #if UNITY_WSA_10_0 && !UNITY_EDITOR
    using Windows.Networking.PushNotifications;
    #endif
    ```

4.  Вставьте следующие переменные:

    ```csharp
        /// <summary>
        /// allows this class to behave like a singleton
        /// </summary>
        public static NotificationReceiver instance;

        /// <summary>
        /// Value set by the notification, new object position
        /// </summary>
        Vector3 newObjPosition;

        /// <summary>
        /// Value set by the notification, object name
        /// </summary>
        string gameObjectName;

        /// <summary>
        /// Value set by the notification, new object position
        /// </summary>
        bool notifReceived;

        /// <summary>
        /// Insert here your Notification Hub Service name 
        /// </summary>
        private string hubName = " -- Insert the name of your service -- ";

        /// <summary>
        /// Insert here your Notification Hub Service "Listen endpoint"
        /// </summary>
        private string hubListenEndpoint = "-Insert your Notification Hub Service Listen endpoint-";
    ```

5.  Substitute **hubName** значение именем своего служб концентратора уведомлений и **hubListenEndpoint** значения со значением конечной точки, найти на вкладке политики доступа к службе центра уведомлений Azure, в Портал Azure (см. рисунок ниже).

    ![Вставка конечной точке политики концентраторов уведомлений](images/AzureLabs-Lab8-97.png)

6.  Теперь добавьте **Start()** и **Awake()** методы для инициализации класса.

    ```csharp
        /// <summary>
        /// Triggers before initialization
        /// </summary>
        void Awake()
        {
            // static instance of this class
            instance = this;
        }

        /// <summary>
        /// Use this for initialization
        /// </summary>
        void Start()
        {
            // Register the App at launch
            InitNotificationsAsync();

            // Begin listening for notifications
            StartCoroutine(WaitForNotification());
        }
    ```

7.  Добавить **WaitForNotification** метод, чтобы разрешить приложению получать уведомления из библиотеки концентратора уведомлений без конфликтов с основной поток:

    ```csharp
        /// <summary>
        /// This notification listener is necessary to avoid clashes 
        /// between the notification hub and the main thread   
        /// </summary>
        private IEnumerator WaitForNotification()
        {
            while (true)
            {
                // Checks for notifications each second
                yield return new WaitForSeconds(1f);

                if (notifReceived)
                {
                    // If a notification is arrived, moved the appropriate object to the new position
                    GameObject.Find(gameObjectName).transform.position = newObjPosition;

                    // Reset the flag
                    notifReceived = false;
                }
            }
        }
    ```

8.  Следующий метод, **InitNotificationAsync()** , будет зарегистрировать приложение в службе центра уведомлений при инициализации. Код закомментирован, как Unity, не смогут сборки проекта. Комментарии будут удалены при импорте пакета Nuget для обмена сообщениями Azure в Visual Studio.

    ```csharp
        /// <summary>
        /// Register this application to the Notification Hub Service
        /// </summary>
        private async void InitNotificationsAsync()
        {
            // PushNotificationChannel channel = await PushNotificationChannelManager.CreatePushNotificationChannelForApplicationAsync();

            // NotificationHub hub = new NotificationHub(hubName, hubListenEndpoint);

            // Registration result = await hub.RegisterNativeAsync(channel.Uri);

            // If registration was successful, subscribe to Push Notifications
            // if (result.RegistrationId != null)
            // {
            //     Debug.Log($"Registration Successful: {result.RegistrationId}");
            //     channel.PushNotificationReceived += Channel_PushNotificationReceived;
            // }
        }
    ```

9.  Следующий обработчик **канал\_PushNotificationReceived()** , будут создаваться каждый раз при получении уведомления. Он десериализует уведомление, которое будет сущность таблицы Azure, который был перемещен в классическое приложение, а затем переместите соответствующий объект GameObject в сцене MR в той же позиции. 
    
    > [!IMPORTANT]
    > Код закомментирован, так как код ссылается на библиотеку обмена сообщениями Azure, которая будет добавлен после создания проекта Unity, используя диспетчер пакетов Nuget в Visual Studio. Таким образом проект Unity невозможна для построения, если только он закомментирован. Имейте в виду, что следует построить проект и затем хотите вернуться к Unity, необходимо будет **повторно комментарий** этого кода.

    ```csharp
        ///// <summary>
        ///// Handler called when a Push Notification is received
        ///// </summary>
        //private void Channel_PushNotificationReceived(PushNotificationChannel sender, PushNotificationReceivedEventArgs args)    
        //{
        //    Debug.Log("New Push Notification Received");
        //
        //    if (args.NotificationType == PushNotificationType.Raw)
        //    {
        //        //  Raw content of the Notification
        //        string jsonContent = args.RawNotification.Content;
        //
        //        // Deserialise the Raw content into an AzureTableEntity object
        //        AzureTableEntity ate = JsonConvert.DeserializeObject<AzureTableEntity>(jsonContent);
        //
        //        // The name of the Game Object to be moved
        //        gameObjectName = ate.RowKey;          
        //
        //        // The position where the Game Object has to be moved
        //        newObjPosition = new Vector3((float)ate.X, (float)ate.Y, (float)ate.Z);
        //
        //        // Flag thats a notification has been received
        //        notifReceived = true;
        //    }
        //}
    ```

10. Не забудьте сохранить изменения перед вернуться в редактор Unity.

11. Нажмите кнопку **Main Camera** из **иерархии** панели, чтобы ее свойства появились на **инспектор**.

12. С помощью **сценарии** открыт, выберите папку **NotificationReceiver** сценариев и перетащите его на **Main Camera**. Результат должен быть следующим образом:

    ![Перетащите сценарий получателя уведомлений к камере](images/AzureLabs-Lab8-98.png)

    > [!NOTE]
    > Если вы разрабатываете для Microsoft HoloLens, необходимо обновить **Main Camera** *камеры* компонента, таким образом, чтобы:
    > - Очистите флаги: Сплошным цветом
    > - Фон: Черный

## <a name="chapter-16---build-the-mixed-reality-project-to-uwp"></a>Глава 16 — построение проекта смешанной реальности для универсальной платформы Windows

В этой главе идентична процесс для предыдущий проект сборки. Все необходимое для раздела этого проекта Unity теперь завершен, так что наступило время создавать его с Unity.

1.  Перейдите к **параметры сборки** ( **файл** > **параметры сборки** ).

2.  Из **параметры построения** меню, убедитесь, **Unity C# проекты*** установлен (что позволит редактировать сценарии в этом проекте, после сборки).

3.  После этого нажмите кнопку **построения**.

    ![Сборка проекта](images/AzureLabs-Lab8-99.png)

4.  Объект **проводнике** будет контекстном меню окна, для расположения для сборки. Создайте новую папку (щелкнув **новую папку** в левом верхнем углу) и назовите его **ПОСТРОЕНИЯ**.

    ![Создайте папку builds](images/AzureLabs-Lab8-100.png)

    1.  Откройте новый **ПОСТРОЕНИЯ** папки и создайте другую папку (с помощью **новую папку** еще раз) и назовите его **NH\_MR\_приложения**.

        ![Создайте папку NH_MR_Apps](images/AzureLabs-Lab8-101.png)

    2.  С помощью **NH\_MR\_приложения** выбранного. Нажмите кнопку **выберите папку**. Проекта займет около минуты для построения.

5.  После построения, **проводнике** в расположение нового проекта откроется окно.



## <a name="chapter-17---add-nuget-packages-to-the-unitymrnotifhub-solution"></a>Глава 17 - добавить пакеты NuGet в решение UnityMRNotifHub

> [!WARNING] 
> Обратите внимание, добавив следующие пакеты NuGet (и раскомментируйте код в следующем [глава](#chapter-18---edit-unitymrnotifhub-application-notificationreceiver-class)), код, при повторном открытии в проекте Unity, представит ошибки. Если вы хотите вернуться назад и продолжить редактирование в редакторе Unity, вам необходимо комментарий errosome кода и затем раскомментируйте позже, когда вы снова находитесь в Visual Studio. 

После завершения построения смешанной реальности, перейдите к проекту смешанной реальности, который вы создали, и дважды щелкните файл решения (SLN) в этой папке, чтобы открыть решение в Visual Studio 2017.
Теперь необходимо добавить **WindowsAzure.Messaging.managed** пакета NuGet; это библиотека, которая используется для получения уведомлений из центра уведомлений.

Чтобы импортировать пакет NuGet:

1.  В **обозревателе решений**, щелкнуть правой кнопкой мыши решение

2.  Щелкните **управление пакетами NuGet**.

    ![Откройте диспетчер nuget](images/AzureLabs-Lab8-102.png)

3.  Выберите ***Обзор*** вкладку и выполните поиск **WindowsAzure.Messaging.managed**.

    ![найти обмена сообщениями пакета windows azure](images/AzureLabs-Lab8-103.png)

4.  Выберите результат (как показано ниже), а в окне справа установите флажок рядом с полем **проекта**. Это будет помещать такт в флажок рядом с полем **проекта**, вместе с флажок рядом с полем **сборки-CSharp** и **UnityMRNotifHub** проекта.

    ![Установка флажка все проекты](images/AzureLabs-Lab8-104.png)

5.  Версия, указанная изначально **может не** совместимы с этим проектом. Таким образом, щелкните раскрывающееся меню рядом **версии**и нажмите кнопку **версии 0.1.7.9**, затем нажмите кнопку **установить**.

6.  Вы завершили установки пакета NuGet. Найти закомментированный код, введенный в **NotificationReceiver** класса и удалить комментарии...



## <a name="chapter-18---edit-unitymrnotifhub-application-notificationreceiver-class"></a>Глава 18 - UnityMRNotifHub изменить приложение, класс NotificationReceiver

Следуя после добавления **пакеты NuGet**, вам нужно будет *раскомментируйте* часть кода в **NotificationReceiver** класса.

Сюда входят следующие возможности.

1. Пространство имен, верхней:

    ```csharp
    using Microsoft.WindowsAzure.Messaging;
    ```

2. Весь код внутри **InitNotificationsAsync()** метод:

    ```csharp
        /// <summary>
        /// Register this application to the Notification Hub Service
        /// </summary>
        private async void InitNotificationsAsync()
        {
            PushNotificationChannel channel = await PushNotificationChannelManager.CreatePushNotificationChannelForApplicationAsync();

            NotificationHub hub = new NotificationHub(hubName, hubListenEndpoint);

            Registration result = await hub.RegisterNativeAsync(channel.Uri);

            // If registration was successful, subscribe to Push Notifications
            if (result.RegistrationId != null)
            {
                Debug.Log($"Registration Successful: {result.RegistrationId}");
                channel.PushNotificationReceived += Channel_PushNotificationReceived;
            }
        }
    ```

> [!WARNING]
> Приведенный выше код имеет комментарий в: Убедитесь, что не случайно *раскомментируется* , комментарий (как код не будет компилироваться при наличии!).

3. И, наконец **Channel_PushNotificationReceived** событий:

    ```csharp
        /// <summary>
        /// Handler called when a Push Notification is received
        /// </summary>
        private void Channel_PushNotificationReceived(PushNotificationChannel sender, PushNotificationReceivedEventArgs args)
        {
            Debug.Log("New Push Notification Received");

            if (args.NotificationType == PushNotificationType.Raw)
            {
                //  Raw content of the Notification
                string jsonContent = args.RawNotification.Content;

                // Deserialize the Raw content into an AzureTableEntity object
                AzureTableEntity ate = JsonConvert.DeserializeObject<AzureTableEntity>(jsonContent);

                // The name of the Game Object to be moved
                gameObjectName = ate.RowKey;

                // The position where the Game Object has to be moved
                newObjPosition = new Vector3((float)ate.X, (float)ate.Y, (float)ate.Z);

                // Flag thats a notification has been received
                notifReceived = true;
            }
        }
    ```

С помощью этих Раскомментировать области кода убедитесь, что сохранить и затем перейти к следующей главе.

## <a name="chapter-19---associate-the-mixed-reality-project-to-the-store-app"></a>Глава 19 - связать проект смешанной реальности в приложение Store

Теперь необходимо связать **смешанной реальности** проекта в приложение Store, созданную в начале лаборатории.

1.  Откройте решение.

2.  Щелкните правой кнопкой проект приложения UWP на панели обозревателя решений, перейдите к **Store**, и **связать приложение с Store...** .

    ![Откройте связи с магазином](images/AzureLabs-Lab8-105.png)

3.  Новое окно будет отображаться вызываемой **связь приложений с Windows Store**. Нажмите кнопку **Далее**.

    ![Перейдите к следующему экрану](images/AzureLabs-Lab8-106.png)

4.  Он загрузит все приложения, связанные с учетной записью, в котором был выполнен вход. Если вы не вошли в учетную запись, вы можете **вход** на этой странице.

5.  Найти **Store имя_приложения** , созданного в начале работы с этим руководством и выберите его. Затем нажмите кнопку **Далее**.

    ![Найдите и выберите имя хранилища](images/AzureLabs-Lab8-107.png)

6.  Нажмите кнопку **связать**.

    ![связать приложение](images/AzureLabs-Lab8-108.png)

7.  Создание приложения **связанные** с приложением Store. Это необходимо для включения уведомлений.

## <a name="chapter-20---deploy-unitymrnotifhub-and-unitydesktopnotifhub-applications"></a>Глава 20 - развертывание приложений UnityMRNotifHub и UnityDesktopNotifHub

В этой главе может быть проще, используя два человека, как результат будет включать как приложения, работающие, один работающий на компьютере рабочего стола, а другой в пределах вашей иммерсивных гарнитуры.

Приложение иммерсивных гарнитура ожидает изменений в сцену (позиция изменения из локального объекты Gameobject) и классическое приложение будет вносить изменения в их локальной сцены (позиция изменения), которая будет общей для него MR. Имеет смысл для развертывания приложения на MR во-первых, следуют классическое приложение, чтобы получатель может начать прослушивание.

Чтобы развернуть **UnityMRNotifHub** приложения на локальном компьютере:

1.  Откройте файл решения вашей **UnityMRNotifHub** приложения в **Visual Studio 2017**.

2.  В **платформа решения**выберите **x86, локальный компьютер**.

3.  В **конфигурации решения** выберите **Отладка**.

    ![Настройка проекта](images/AzureLabs-Lab8-109.png)

4.  Перейдите к **меню "сборка"** и щелкнуть **развернуть решение** для загрузки неопубликованных приложений на компьютер.

5.  Приложения появятся в списке установленных приложений, Готово к запуску.

Чтобы развернуть **UnityDesktopNotifHub** приложения на локальном компьютере:

1.  Откройте файл решения вашей **UnityDesktopNotifHub** приложения в **Visual Studio 2017**.

2.  В **платформа решения**выберите **x86, локальный компьютер**.

3.  В **конфигурации решения** выберите **Отладка**.

    ![Настройка проекта](images/AzureLabs-Lab8-110.png)

4.  Перейдите к **меню "сборка"** и щелкнуть **развернуть решение** для загрузки неопубликованных приложений на компьютер.

5.  Приложения появятся в списке установленных приложений, Готово к запуску.

6.  Запустите приложение смешанной реальности, следуют настольного приложения.

Благодаря выполнению обоих приложений переместите объект в сцене настольных систем (с помощью левой кнопки мыши). Эти изменения расположения, применяемые будет внесенных локально, сериализовать и отправить службе приложения-функции. Служба приложения-функции, затем обновит таблицы, а также в центре уведомлений. Получение обновления, центра уведомлений будет отправлять обновленные данные непосредственно на все зарегистрированные приложения (в данном случае приложение иммерсивных гарнитуры), которые затем будут десериализации входящих данных и применяют новые данные позиционными для локальных объектов, переместить их в сцене.


## <a name="your-finished-your-azure-notification-hubs-application"></a>Ваш завершения приложения центров уведомлений Azure
 
Поздравляем, вы создали приложение смешанной реальности, использует службу концентраторов уведомлений Azure и Разрешить взаимодействие между приложениями.
 
![конечный продукт-end](images/AzureLabs-Lab8-00.png)
 
## <a name="bonus-exercises"></a>Упражнения премии

### <a name="exercise-1"></a>Упражнение 1

Можно работать как изменить цвет объекты Gameobject и отправки этого уведомления в другие приложения, просмотр сцены?

### <a name="exercise-2"></a>Упражнение 2

Можно добавить в приложение MR перемещение объекты Gameobject и см. в разделе обновленные сцены в свое приложение?
