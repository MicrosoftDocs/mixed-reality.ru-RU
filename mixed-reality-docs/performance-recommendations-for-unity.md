---
title: Рекомендации по повышению производительности для Unity
description: Советы, связанные с Unity, для повышения производительности с приложениями смешанной реальности.
author: Troy-Ferrell
ms.author: trferrel
ms.date: 03/26/2019
ms.topic: article
keywords: графика, ЦП, GPU, подготовка к просмотру, сборка мусора, hololens
ms.openlocfilehash: b0821f07184bff8630f6b6af0d0fc461f6fcd133
ms.sourcegitcommit: 8f3ff9738397d9b9fdf4703b14b89d416f0186a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/12/2019
ms.locfileid: "67843336"
---
# <a name="performance-recommendations-for-unity"></a>Рекомендации по повышению производительности для Unity

Эта статья основана на обсуждениях, описанных в разделе [рекомендации по повышению производительности смешанной реальности](understanding-performance-for-mixed-reality.md) , но посвящена вопросам, относящимся к среде механизма Unity.

Также настоятельно рекомендуется, чтобы разработчики Просмотрели [Рекомендуемые параметры среды для статьи Unity](Recommended-settings-for-unity.md). В этой статье содержится содержимое с некоторыми из наиболее важных конфигураций сцены в отношении создания производительных приложений смешанной реальности. Некоторые из этих рекомендуемых параметров также выделены ниже.

## <a name="how-to-profile-with-unity"></a>Профилирование с помощью Unity

Unity предоставляет встроенный **[профилировщик Unity](https://docs.unity3d.com/Manual/Profiler.html)** , который является отличным ресурсом для сбора ценных сведений о производительности для конкретного приложения. Хотя можно запустить профилировщик в-редакторе, эти метрики не представляют истинную среду выполнения, поэтому результаты из этого следует использовать с осторожностью. Рекомендуется выполнять удаленное профилирование приложения во время работы на устройстве для получения наиболее точных и практичных ценных сведений. Кроме того, [отладчик frames](https://docs.unity3d.com/Manual/FrameDebugger.html) Unity также является очень мощным и ценным средством для использования.

Unity предоставляет замечательную документацию по следующим параметрам:
1) Как подключить [профилировщик Unity к ПРИЛОЖЕНИЯМ UWP удаленно](https://docs.unity3d.com/Manual/windowsstore-profiler.html)
2) Как эффективно [диагностировать проблемы с производительностью с помощью профилировщика Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)

>[!NOTE]
> После подключения профилировщика Unity и добавления профилировщика GPU (см. раздел *Добавление профилировщика* в правом верхнем углу) можно увидеть, сколько времени тратится на ЦП & GPU, соответственно в середине профилировщика. Это позволяет разработчику получить быструю аппроксимацию, если к приложению привязан ЦП или GPU.
>
> ![ЦП Unity и GPU](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a>Рекомендации по производительности ЦП

Приведенное ниже содержимое содержит более подробные рекомендации по производительности, особенно предназначенные для разработки C# Unity &.

#### <a name="cache-references"></a>Ссылки на кэш

Рекомендуется кэшировать ссылки на все соответствующие компоненты и объекты gameobject при инициализации. Это обусловлено тем, что повторяющиеся вызовы функций, такие как *[\<> ()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* , значительно дороже, чем затраты на память для хранения указателя. Это также относится к очень регулярно используемой [камере. Main](https://docs.unity3d.com/ScriptReference/Camera-main.html). На самом деле, *камера. Main* просто использует *[финдгамеобжектсвистаг ()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* , под которым дорогостоящий Поиск объекта Camera с помощью тега *"маинкамера"* .

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] 
> Избегайте использования компонента GetString (String) <br/>
> При использовании функции *[-компонента ()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* существует несколько различных перегрузок. Важно всегда использовать реализации на основе типов и никогда не применять перегрузку поиска на основе строк. Поиск по строке в сцене значительно дороже, чем поиск по типу. <br/>
> Рекомендуется Компонент-компонент (тип Type) <br/>
> Рекомендуется T-компонент\<t > () <br/>
> Правильным Компонент-компонент (String) > <br/>

#### <a name="avoid-expensive-operations"></a>Избегайте дорогостоящих операций

1) **Избегайте использования [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**

    Хотя LINQ может быть очень четким и удобным для чтения и записи, обычно требуется гораздо больше вычислительных ресурсов и особенно больший объем памяти, чем написание алгоритма вручную.

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) **Общие интерфейсы API Unity**

    Некоторые API Unity, хотя и полезны, могут быть очень ресурсоемкими. Большинство из них охватывают весь граф сцены для поиска соответствующего списка объекты gameobject. Обычно эти операции можно избежать, если кэшировать ссылки или реализовать компонент Manager для объекты gameobject для контроля ссылок во время выполнения.

        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()

>[!NOTE]
> При любых затратах *[SendMessage ()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* и *[броадкастмессаже ()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* следует устранять. Эти функции могут находиться в порядке вы можете обрабатывать медленнее, чем прямые вызовы функций.

3) **Будьте осторожны при упаковке**

    [Упаковка](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) — это основная концепция C# языка и среды выполнения. Это процесс упаковки переменных со значениями типа char, int, bool и т. д. в ссылочные переменные. Если типизированная переменная со значением "упакована", она упаковывается внутри объекта System. Object, который хранится в управляемой куче. Таким же объем памяти выделяется и, в конечном итоге, при удалении должна обрабатывать сборщик мусора. Распределение и освобождение ресурсов приводят к снижению производительности, и во многих случаях их не требуется или можно легко заменить на менее дорогостоящую альтернативу.

#### <a name="repeating-code-paths"></a>Повторяющиеся пути кода

Любые повторяющиеся функции обратного вызова Unity (т. е. Обновление), выполняемое много раз в секунду и (или) кадре, должно быть тщательно написано. Все дорогостоящие операции в этом случае будут иметь огромное и устойчивое влияние на производительность.

1) **Пустые функции обратного вызова**

    Несмотря на то, что приведенный ниже код может показаться безобиднымим в приложении, особенно поскольку каждый сценарий Unity выполняет автоматическую инициализацию с помощью этого блока кода, эти пустые обратные вызовы могут быть очень ресурсоемкими. Unity работает с неуправляемой или управляемой границей кода, между кодом UnityEngine и кодом приложения. Переключение контекста на этот мост занимает довольно много ресурсов, даже если нет никаких действий для выполнения. Это особенно проблематично, если приложение имеет 100 объекты gameobject с компонентами, которые имеют пустые повторяющиеся обратные вызовы Unity.

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> Update () — это наиболее распространенная версия этой проблемы с производительностью, но другие повторяющиеся обратные вызовы Unity, такие как следующие, могут быть так же неплохы, если не хуже: Фикседупдате (), Латеупдате (), Онпострендер ", OnPreRender (), Онрендеримаже () и т. д. 

2) **Однократное выполнение операций для каждого кадра**

    Следующие API Unity являются общими операциями для многих holographic приложений. Хотя это не всегда возможно, результаты этих функций могут быть вычислены один раз, а результаты повторно используются в приложении для определенного кадра.

    о. как правило, рекомендуется иметь выделенный одноэлементный класс или службу для Райкастия взгляда в сцену, а затем повторно использовать этот результат во всех остальных компонентах сцены, а не повторять и фактически идентичные операции Райкаст по каждому см. Разумеется, некоторым приложениям может потребоваться райкастс из разных источников или разных [лайермаскс](https://docs.unity3d.com/ScriptReference/LayerMask.html).

        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()

    б) Избегайте операций с методом "не Component" () в повторяющихся обратных вызовах Unity, таких как Update (), путем [кэширования ссылок](#cache-references) в Start () или в спящий режим ()

        UnityEngine.Object.GetComponent()

    в) рекомендуется создавать экземпляры всех объектов, если это возможно, при инициализации и использовать [пул объектов](#object-pooling) для перезапуска и повторного использования объекты gameobject во время выполнения приложения.

        UnityEngine.Object.Instantiate()

3) **Избегайте использования интерфейсов и виртуальных конструкций**

    Вызов функций через интерфейсы и прямые объекты или вызов виртуальных функций часто может оказаться гораздо более затратным, чем использование прямых конструкций или прямых вызовов функций. Если виртуальная функция или интерфейс не требуется, то ее следует удалить. Однако на производительность этих подходов обычно стоит компромисс, если они используются для упрощения совместной работы, удобочитаемости кода и удобства поддержки кода. 

4) **Избегайте передачи структур по значению**

    В отличие от классов, структуры являются типами значений и при передаче непосредственно в функцию их содержимое копируется в только что созданный экземпляр. Эта копия добавляет стоимость ЦП, а также дополнительную память в стеке. Для небольших структур такой результат обычно очень минимальный, а значит, приемлем. Однако, если возможно, для функций повторно вызывается каждый кадр, а также функции, принимающие крупные структуры, по возможности измените определение функции для передачи по ссылке. [Дополнительные сведения](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a>Прочее

1) **Физики**

    ответ. как правило, самый простой способ улучшить физические затраты — ограничить время, затрачиваемое на физическое или количество итераций в секунду. Разумеется, это снизит точность имитации. См. раздел [тимеманажер](https://docs.unity3d.com/Manual/class-TimeManager.html) в Unity.

    б) тип конфликтующих данных в Unity имеет широко разные характеристики производительности. В приведенном ниже порядке перечислены наиболее производительные конфликтующие по крайней мере более производительные конфликтующие. Наиболее важно избегать появления подлинности сети, которые значительно дороже, чем простые конфликты.

        Sphere < Capsule < Box <<< Mesh (Convex) < Mesh (non-Convex)

    Дополнительные сведения см. в разделе рекомендации по [использованию Unity физика](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) .

2) **Анимирован**

    Отключите анимацию простоя, отключив компонент аниматор (отключение объекта Game не приведет к тому же результату). Избегайте шаблонов разработки, где аниматор находится в цикле, устанавливая значение в одно и то же действие. Для этого метода есть значительные издержки, которые не влияют на приложение. [Дополнительные сведения см. здесь.](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) **Сложные алгоритмы**

    Если приложение использует сложные алгоритмы, такие как обратная кинематика, поиск пути и т. д., найдите более простой подход или настройте соответствующие параметры для их производительности.

## <a name="cpu-to-gpu-performance-recommendations"></a>Рекомендации по производительности ЦП и GPU

Как правило, производительность процессора в графическом ПРОЦЕССОРе сводится к **вызовам Draw** , отправляемым на графическую карту. Чтобы повысить производительность, для достижения оптимальных результатов вызовы рисования должны быть стратегическими **а) уменьшенными** или **b)** . Поскольку вызовы рисования являются ресурсоемкими, их уменьшение позволит сократить общую работу. Кроме того, изменения состояния между вызовами Draw требуют дорогостоящих действий по проверке и переводу в драйвере графики и, таким образом, реструктуризация вызовов рисования приложения для ограничения изменений состояния (т. е. различные материалы и т. д. могут повысить производительность.

В Unity есть отличная статья, в которой приводится обзор и подробно в пакетную обработку вызовов для своей платформы.
- [Пакетная обработка вызовов Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html)

#### <a name="single-pass-instanced-rendering"></a>Обработка экземпляров с одним проходом

Однопроходная Визуализация с одним экземпляром в Unity позволяет уменьшить число вызовов рисования для каждого глаза до одного экземпляра Draw. Из-за согласованности кэша между двумя вызовами Draw также существует и некоторое улучшение производительности GPU.

Включение этой функции в проекте Unity
1)  Откройте **Параметры проигрывателя XR** (выберите **Правка** > **Параметры** > проекта**проигрыватель** > **Параметры XR**).
2) Выберите **однопроходный экземпляр** из раскрывающегося меню **метода подготовки** к просмотру (необходимо установить флажок "**поддерживается виртуальная реальность** ").

Ознакомьтесь со следующими статьями из Unity, чтобы получить подробные сведения об этом подходе к отрисовке.
- [Как добиться максимальной производительности AR и VR с помощью расширенной стерео визуализации](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)
- [Однопроходный создание экземпляров](https://docs.unity3d.com/Manual/SinglePassInstancing.html) 

>[!NOTE]
> Одна из распространенных проблем с однопроходным экземпляром отрисовки происходит, если у разработчиков уже есть пользовательские шейдеры, не написанные для создания экземпляров. После включения этой функции разработчики могут заметить, что некоторые объекты gameobjectы отображаются только в одном глазе. Это обусловлено тем, что связанные пользовательские шейдеры не имеют соответствующих свойств для создания экземпляров.
>
> Способы решения этой проблемы см. в разделе однопроходное [Отображение стерео для HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) из Unity.

#### <a name="static-batching"></a>Статическая пакетирование

Unity может пакетно группировать многие статические объекты, чтобы уменьшить число вызовов рисования к GPU. Статическая пакетирование работает для большинства объектов модуля [подготовки](https://docs.unity3d.com/ScriptReference/Renderer.html) отчетов в Unity, что **1) совместно используют один и тот же материал** и **2). все они помечены как *статические***  (выберите объект в Unity и установите флажок в правом верхнем углу инспектора). Объекты gameobject, помеченный как *static* , невозможно переместить во время выполнения приложения. Поэтому статическая пакетирование может быть трудно использовать в HoloLens, где практически все объекты должны размещаться, перемещаться, масштабироваться и т. д. Для впечатляющих головных телефонов статическая пакетирование может значительно сократить число вызовов рисования и, таким образом, повысить производительность.

Дополнительные сведения см. в разделе *статическая пакетирование пакетной* обработки [в Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) .

#### <a name="dynamic-batching"></a>Динамическая пакетирование

Поскольку объекты не помечаются как *статические* для разработки HoloLens, динамическая Пакетная обработка может оказаться отличным инструментом для компенсации этой недостаточной функции. Конечно же, он также может быть полезен и на впечатляющих гарнитурах. Динамическая пакетирование в Unity может быть непростой, так как объекты gameobject должен иметь **общий доступ к одному и тому же материалу** и **б), что соответствует длинному списку других критериев**.

Полный список см. в статье *Динамическая Пакетная обработка* в [Unity. Пакетная обработка вызовов](https://docs.unity3d.com/Manual/DrawCallBatching.html) . Чаще всего объекты gameobject становятся недопустимыми для динамического пакетной обработки, так как связанные данные сетки могут быть не более 300 вершин.

#### <a name="other-techniques"></a>Другие методы

Пакетная обработка может выполняться, только если несколько объекты gameobject могут использовать одни и те же материалы. Как правило, это будет заблокировано потребностью объекты gameobject иметь уникальную текстуру для соответствующих материалов. Обычно текстуры объединяются в одну большую текстуру — метод, называемый [вытягивания текстур](https://en.wikipedia.org/wiki/Texture_atlas).

Кроме того, обычно предпочтительнее объединять сетки в один GameObject, где это возможно и разумно. Каждый модуль подготовки в Unity будет иметь связанные с ним вызовы рисования и отправлять объединенную сетку в одном модуле подготовки отчетов. 

>[!NOTE]
> Изменение свойств модуля подготовки отчетов. Material во время выполнения создает копию материала и, таким же, может привести к нарушению пакетирования. Используйте визуализатор. Шаредматериал для изменения свойств общих материалов в объекты gameobject.

## <a name="gpu-performance-recommendations"></a>Рекомендации по производительности GPU

Дополнительные сведения об [оптимизации отрисовки графики в Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games) 

### <a name="optimize-depth-buffer-sharing"></a>Оптимизация совместного использования буфера глубины

Обычно рекомендуется включить **совместное использование буфера глубины** в **параметрах XR проигрывателя** , чтобы оптимизировать [стабильность](Hologram-stability.md). При включении повторного проецирования на основе глубины с помощью этого параметра рекомендуется выбрать **16-разрядный формат глубины** , а не **24-разрядный формат глубины**. 16-разрядные буферы глубины радикально снижают пропускную способность (и, таким образом, энергопотребление), связанную с трафиком в буфере глубины. Это может быть большой степенью выигрыша, но она применима только для удобства работы с небольшим диапазоном глубины, [так как с](https://en.wikipedia.org/wiki/Z-fighting) 16-разрядными, скорее всего, будет возникать большая вероятность. Чтобы избежать этих артефактов, измените близкие и далеко вырезанные плоскости [камеры Unity](https://docs.unity3d.com/Manual/class-Camera.html) , чтобы учитывать меньшую точность. Для приложений на основе HoloLens далеко плоскость 50 млн вместо 1000m по умолчанию Unity может, как правило, устранить любые отрезки от z.

### <a name="reduce-poly-count"></a>Сокращение числа поли

Число многоугольников обычно сокращается с помощью
1) Удаление объектов из сцены
2) Децимации-ресурс, который сокращает количество многоугольников для данной сетки
3) Реализация в приложении [системы уровня детализации (Лод)](https://docs.unity3d.com/Manual/LevelOfDetail.html) , которая визуализирует объекты с более низкими координатами с использованием более низких версий той же геометрии

### <a name="understanding-shaders-in-unity"></a>Общие сведения о шейдерах в Unity

Простая аппроксимация для сравнения шейдеров в производительности заключается в определении среднего числа операций, выполняемых во время выполнения. Это можно легко сделать в Unity.

1) Выберите ресурс шейдера или материал, а затем в правом верхнем углу окна инспектора выберите значок шестеренки и нажмите **кнопку "выбрать шейдер"** .

    ![Выбор шейдера в Unity](images/Select-shader-unity.png)
2) Выбрав ресурс шейдера, нажмите кнопку **"компилировать и отобразить код"** в окне инспектора.

    ![Компиляция кода шейдера в Unity](images/compile-shader-code-unity.PNG)

3) После компиляции найдите раздел статистики в результатах с числом различных операций для шейдера вершин и текстуры (Обратите внимание, что обычно шейдеры пикселей также называются шейдерами фрагментов).

    ![Операции шейдера Unity Standard](images/unity-standard-shader-compilation.png)

#### <a name="optmize-pixel-shaders"></a>Оптмизеные шейдеры пикселей

Просмотрев скомпилированные статистические результаты с помощью приведенного выше метода, [шейдер фрагментов](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) обычно выполняет больше операций, чем [шейдер вершин](https://en.wikipedia.org/wiki/Shader#Vertex_shaders) в среднем. Шейдер фрагментов, также называемый шейдером пикселей, выполняется на экране в выводе экрана, а шейдер вершин выполняется только на вершину всех сеток, отображаемых на экране. 

Таким же словами, не только у шейдеров фрагментов есть больше инструкций, чем шейдеры вершин из-за всех вычислений освещения, шейдеры фрагментов практически всегда выполняются в более крупном наборе данных. Например, если в качестве выходных данных экрана используется образ в формате 2000 (2000), то шейдер фрагментов может стать выполненным, например, следующим образом: 4 000 000 раз. Если выводятся два глаза, это число удваивается, поскольку имеется два экрана. Если приложение смешанной реальности имеет несколько проходов, полноэкранные действия после обработки или отрисовку нескольких сеток на один и тот же пиксель, это число будет существенно возрастать. 

Таким образом, уменьшение количества операций в шейдере фрагментов может привести к значительному повышению производительности по сравнению с оптимизацией в шейдере вершин.

#### <a name="unity-standard-shader-alternatives"></a>Альтернативные варианты шейдера Unity Standard

Вместо использования на основе физической отрисовки (PBR) или другого высококачественного шейдера рассмотрите использование более производительного и более дешевого шейдера. [Набор средств Mixed Reality](https://github.com/Microsoft/MixedRealityToolkit-Unity) предоставляет [стандартный шейдер мртк](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) , оптимизированный для проектов смешанной реальности.

Unity также предоставляет унлит, освещенность вершин, диффузию и другие упрощенные параметры шейдера, которые значительно быстрее по сравнению с шейдером стандарта Unity. Более подробные сведения см. [в статье Использование и производительность встроенных шейдеров](https://docs.unity3d.com/Manual/shader-Performance.html) .

#### <a name="shader-preloading"></a>Предварительная загрузка шейдера

Используйте *предварительную загрузку шейдера* и другие приемы для оптимизации [времени загрузки шейдера](http://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html). В частности, Предварительная загрузка шейдера означает, что вы не увидите хитчес из-за компиляции шейдера времени выполнения.

### <a name="limit-overdraw"></a>Ограничить перерисовку

В Unity один может отображать перерисовку для своего сцены, переключаясь в [**меню режима рисования**](https://docs.unity3d.com/Manual/ViewModes.html) в левом верхнем углу **представления сцены** и выбрав команду Перерисовать .

Как правило, перерисовку можно уменьшить путем отбора объектов перед отправкой в GPU. Unity предоставляет подробные сведения о реализации [отбора перекрытия](https://docs.unity3d.com/Manual/OcclusionCulling.html) для подсистемы.

## <a name="memory-recommendations"></a>Рекомендации по использованию памяти

Чрезмерное выделение памяти & операциях изъятия может оказать негативное влияние на работу с holographic, что приведет к нестабильной производительности, замороженным кадрам и другим негативным последствиям. Особенно важно понимать требования к памяти при разработке в Unity, так как управление памятью управляется сборщиком мусора.

#### <a name="garbage-collection"></a>Сборка мусора

При активации сборщика мусора для анализа объектов, которые больше не находятся в области действия во время выполнения, и их освобождения памяти для повторного использования, holographic приложений не сможет обработать вычислительные ресурсы до момента их обработки. Для постоянных распределений и отмены распределения обычно требуется, чтобы сборщик мусора выполнялся чаще, что приводит к ухудшению производительности и удобства работы пользователей.

В Unity была предоставлена отличная страница, в которой подробно объясняется, как работает сборщик мусора и советы по написанию более эффективного кода в отношении управления памятью.
- [Оптимизация сборки мусора в играх Unity](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)

Одной из наиболее распространенных методик, приводящих к чрезмерной сборке мусора, является кэширование ссылок на компоненты и классы в разработке Unity. Все ссылки должны быть захвачены во время запуска () или спящего режима () и повторно использоваться в последующих функциях, таких как Update () или Латеупдате ().

Другие краткие советы:
- Использование класса [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# для динамической сборки сложных строк во время выполнения
- Удалить вызовы Debug. log (), если они больше не нужны, так как они все еще выполняются во всех версиях сборки приложения.
- Если в holographic приложении обычно требуется много памяти, рассмотрите возможность вызова [ _**System. GC. сбора ()**_ ](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) во время загрузки, например при показе экрана загрузки или перехода

#### <a name="object-pooling"></a>Объединение объектов в пул

Использование пулов объектов — популярная методика снижения затрат на непрерывное выделение памяти & освобождением объектов. Это делается путем выделения большого пула идентичных объектов и повторного использования неактивных, доступных экземпляров из этого пула вместо постоянного создания и уничтожения объектов с течением времени. Пулы объектов отлично подходят для повторного создания компонентов, которые имеют переменное время существования во время выполнения приложения.

- [Руководство по пулам объектов в Unity](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a>Производительность при запуске

Рекомендуется запустить приложение с небольшой сценой, а затем использовать *[сценеманажер. лоадсценеасинк](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* для загрузки оставшейся части сцены. Это позволяет приложению перейти в интерактивное состояние как можно быстрее. Имейте в виду, что во время активации новой сцены может возникнуть большой Пиковый объем ресурсов ЦП, а все отображаемое содержимое может перебои или Хитч. Один из способов обойти это — установить для свойства AsyncOperation. Алловсценеактиватион значение false в загружаемой сцене, дождаться загрузки сцены, очистить экран до черного, а затем снова установить значение true для завершения активации сцены.

Помните, что во время загрузки сцены с начальным экраном пользователю будет отображаться экран-заставка.

## <a name="see-also"></a>См. также
- [Оптимизация отрисовки графики в играх Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)
- [Оптимизация сборки мусора в играх Unity](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)
- [Лучшие методики [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)
- [Оптимизация скриптов [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)
