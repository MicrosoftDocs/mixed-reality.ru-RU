---
title: Рекомендации по повышению производительности для Unity
description: Советы, связанные с Unity, для повышения производительности с приложениями смешанной реальности.
author: Troy-Ferrell
ms.author: trferrel
ms.date: 03/26/2019
ms.topic: article
keywords: графика, ЦП, GPU, подготовка к просмотру, сборка мусора, hololens
ms.openlocfilehash: b0821f07184bff8630f6b6af0d0fc461f6fcd133
ms.sourcegitcommit: 8f3ff9738397d9b9fdf4703b14b89d416f0186a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/12/2019
ms.locfileid: "67843336"
---
# <a name="performance-recommendations-for-unity"></a><span data-ttu-id="dbddd-104">Рекомендации по повышению производительности для Unity</span><span class="sxs-lookup"><span data-stu-id="dbddd-104">Performance recommendations for Unity</span></span>

<span data-ttu-id="dbddd-105">Эта статья основана на обсуждениях, описанных в разделе [рекомендации по повышению производительности смешанной реальности](understanding-performance-for-mixed-reality.md) , но посвящена вопросам, относящимся к среде механизма Unity.</span><span class="sxs-lookup"><span data-stu-id="dbddd-105">This article builds on the discussion outlined in [performance recommendations for mixed reality](understanding-performance-for-mixed-reality.md) but focuses on learnings specific to the Unity engine environment.</span></span>

<span data-ttu-id="dbddd-106">Также настоятельно рекомендуется, чтобы разработчики Просмотрели [Рекомендуемые параметры среды для статьи Unity](Recommended-settings-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="dbddd-106">It is also highly advisable that developers review the [recommended environment settings for Unity article](Recommended-settings-for-unity.md).</span></span> <span data-ttu-id="dbddd-107">В этой статье содержится содержимое с некоторыми из наиболее важных конфигураций сцены в отношении создания производительных приложений смешанной реальности.</span><span class="sxs-lookup"><span data-stu-id="dbddd-107">This article has content with some of the most important scene configurations in regards to building performant Mixed Reality apps.</span></span> <span data-ttu-id="dbddd-108">Некоторые из этих рекомендуемых параметров также выделены ниже.</span><span class="sxs-lookup"><span data-stu-id="dbddd-108">Some of these recommended settings are highlighted below as well.</span></span>

## <a name="how-to-profile-with-unity"></a><span data-ttu-id="dbddd-109">Профилирование с помощью Unity</span><span class="sxs-lookup"><span data-stu-id="dbddd-109">How to profile with Unity</span></span>

<span data-ttu-id="dbddd-110">Unity предоставляет встроенный **[профилировщик Unity](https://docs.unity3d.com/Manual/Profiler.html)** , который является отличным ресурсом для сбора ценных сведений о производительности для конкретного приложения.</span><span class="sxs-lookup"><span data-stu-id="dbddd-110">Unity provides the **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** built-in which is a great resource to gather valuable performance insights for your particular app.</span></span> <span data-ttu-id="dbddd-111">Хотя можно запустить профилировщик в-редакторе, эти метрики не представляют истинную среду выполнения, поэтому результаты из этого следует использовать с осторожностью.</span><span class="sxs-lookup"><span data-stu-id="dbddd-111">Although one can run the profiler in-editor, these metrics do not represent the true runtime environment and thus, results from this should be used cautiously.</span></span> <span data-ttu-id="dbddd-112">Рекомендуется выполнять удаленное профилирование приложения во время работы на устройстве для получения наиболее точных и практичных ценных сведений.</span><span class="sxs-lookup"><span data-stu-id="dbddd-112">It is recommended to remotely profile your application while running on device for most accurate and actionable insights.</span></span> <span data-ttu-id="dbddd-113">Кроме того, [отладчик frames](https://docs.unity3d.com/Manual/FrameDebugger.html) Unity также является очень мощным и ценным средством для использования.</span><span class="sxs-lookup"><span data-stu-id="dbddd-113">Further, Unity's [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html)  is also a very powerful and insight tool to utilize.</span></span>

<span data-ttu-id="dbddd-114">Unity предоставляет замечательную документацию по следующим параметрам:</span><span class="sxs-lookup"><span data-stu-id="dbddd-114">Unity provides great documentation for:</span></span>
1) <span data-ttu-id="dbddd-115">Как подключить [профилировщик Unity к ПРИЛОЖЕНИЯМ UWP удаленно](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span><span class="sxs-lookup"><span data-stu-id="dbddd-115">How to connect the [Unity profiler to UWP applications remotely](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span></span>
2) <span data-ttu-id="dbddd-116">Как эффективно [диагностировать проблемы с производительностью с помощью профилировщика Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span><span class="sxs-lookup"><span data-stu-id="dbddd-116">How to effectively [diagnose performance problems with the Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span></span>

>[!NOTE]
> <span data-ttu-id="dbddd-117">После подключения профилировщика Unity и добавления профилировщика GPU (см. раздел *Добавление профилировщика* в правом верхнем углу) можно увидеть, сколько времени тратится на ЦП & GPU, соответственно в середине профилировщика.</span><span class="sxs-lookup"><span data-stu-id="dbddd-117">With the Unity Profiler connected and after adding the GPU profiler (see *Add Profiler* in top right corner), one can see how much time is being spent on the CPU & GPU respectively in the middle of the profiler.</span></span> <span data-ttu-id="dbddd-118">Это позволяет разработчику получить быструю аппроксимацию, если к приложению привязан ЦП или GPU.</span><span class="sxs-lookup"><span data-stu-id="dbddd-118">This allows the developer to get a quick approximation if their application is CPU or GPU bounded.</span></span>
>
> ![ЦП Unity и GPU](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a><span data-ttu-id="dbddd-120">Рекомендации по производительности ЦП</span><span class="sxs-lookup"><span data-stu-id="dbddd-120">CPU performance recommendations</span></span>

<span data-ttu-id="dbddd-121">Приведенное ниже содержимое содержит более подробные рекомендации по производительности, особенно предназначенные для разработки C# Unity &.</span><span class="sxs-lookup"><span data-stu-id="dbddd-121">The content below covers more in-depth performance practices, especially targeted for Unity & C# development.</span></span>

#### <a name="cache-references"></a><span data-ttu-id="dbddd-122">Ссылки на кэш</span><span class="sxs-lookup"><span data-stu-id="dbddd-122">Cache references</span></span>

<span data-ttu-id="dbddd-123">Рекомендуется кэшировать ссылки на все соответствующие компоненты и объекты gameobject при инициализации.</span><span class="sxs-lookup"><span data-stu-id="dbddd-123">It is best practice to cache references to all relevant components and GameObjects at initialization.</span></span> <span data-ttu-id="dbddd-124">Это обусловлено тем, что повторяющиеся вызовы функций, такие как *[\<> ()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* , значительно дороже, чем затраты на память для хранения указателя.</span><span class="sxs-lookup"><span data-stu-id="dbddd-124">This is because repeating function calls such as *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* are significantly more expensive relative to the memory cost to store a pointer.</span></span> <span data-ttu-id="dbddd-125">Это также относится к очень регулярно используемой [камере. Main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span><span class="sxs-lookup"><span data-stu-id="dbddd-125">This also applies to to the very, regularly used [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span></span> <span data-ttu-id="dbddd-126">На самом деле, *камера. Main* просто использует *[финдгамеобжектсвистаг ()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* , под которым дорогостоящий Поиск объекта Camera с помощью тега *"маинкамера"* .</span><span class="sxs-lookup"><span data-stu-id="dbddd-126">*Camera.main* actually just uses *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* underneath which expensively searches your scene graph for a camera object with the *"MainCamera"* tag.</span></span>

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] 
> <span data-ttu-id="dbddd-127">Избегайте использования компонента GetString (String)</span><span class="sxs-lookup"><span data-stu-id="dbddd-127">Avoid GetComponent(string)</span></span> <br/>
> <span data-ttu-id="dbddd-128">При использовании функции *[-компонента ()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* существует несколько различных перегрузок.</span><span class="sxs-lookup"><span data-stu-id="dbddd-128">When using *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)*, there are a handful of different overloads.</span></span> <span data-ttu-id="dbddd-129">Важно всегда использовать реализации на основе типов и никогда не применять перегрузку поиска на основе строк.</span><span class="sxs-lookup"><span data-stu-id="dbddd-129">It is important to always use the Type based implementations and never the string-based searching overload.</span></span> <span data-ttu-id="dbddd-130">Поиск по строке в сцене значительно дороже, чем поиск по типу.</span><span class="sxs-lookup"><span data-stu-id="dbddd-130">Searching by string in your scene is significantly more costly than searching by Type.</span></span> <br/>
> <span data-ttu-id="dbddd-131">Рекомендуется Компонент-компонент (тип Type)</span><span class="sxs-lookup"><span data-stu-id="dbddd-131">(Good) Component GetComponent(Type type)</span></span> <br/>
> <span data-ttu-id="dbddd-132">Рекомендуется T-компонент\<t > ()</span><span class="sxs-lookup"><span data-stu-id="dbddd-132">(Good) T GetComponent\<T>()</span></span> <br/>
> <span data-ttu-id="dbddd-133">Правильным Компонент-компонент (String) ></span><span class="sxs-lookup"><span data-stu-id="dbddd-133">(Bad) Component GetComponent(string)></span></span> <br/>

#### <a name="avoid-expensive-operations"></a><span data-ttu-id="dbddd-134">Избегайте дорогостоящих операций</span><span class="sxs-lookup"><span data-stu-id="dbddd-134">Avoid expensive operations</span></span>

1) <span data-ttu-id="dbddd-135">**Избегайте использования [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span><span class="sxs-lookup"><span data-stu-id="dbddd-135">**Avoid use of [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span></span>

    <span data-ttu-id="dbddd-136">Хотя LINQ может быть очень четким и удобным для чтения и записи, обычно требуется гораздо больше вычислительных ресурсов и особенно больший объем памяти, чем написание алгоритма вручную.</span><span class="sxs-lookup"><span data-stu-id="dbddd-136">Although LINQ can be very clean and easy to read and write, it generally requires much more computation and particularly more memory allocation than writing the algorithm out manually.</span></span>

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) <span data-ttu-id="dbddd-137">**Общие интерфейсы API Unity**</span><span class="sxs-lookup"><span data-stu-id="dbddd-137">**Common Unity APIs**</span></span>

    <span data-ttu-id="dbddd-138">Некоторые API Unity, хотя и полезны, могут быть очень ресурсоемкими.</span><span class="sxs-lookup"><span data-stu-id="dbddd-138">Certain Unity APIs, although useful, can be very expensive to execute.</span></span> <span data-ttu-id="dbddd-139">Большинство из них охватывают весь граф сцены для поиска соответствующего списка объекты gameobject.</span><span class="sxs-lookup"><span data-stu-id="dbddd-139">Most of these involve searching your entire scene graph for some matching list of GameObjects.</span></span> <span data-ttu-id="dbddd-140">Обычно эти операции можно избежать, если кэшировать ссылки или реализовать компонент Manager для объекты gameobject для контроля ссылок во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="dbddd-140">These operations can generally be avoided by caching references or implementing a manager component for the GameObjects in question to track the references at runtime.</span></span>

        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()

>[!NOTE]
> <span data-ttu-id="dbddd-141">При любых затратах *[SendMessage ()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* и *[броадкастмессаже ()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* следует устранять.</span><span class="sxs-lookup"><span data-stu-id="dbddd-141">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* and *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* should be eliminated at all costs.</span></span> <span data-ttu-id="dbddd-142">Эти функции могут находиться в порядке вы можете обрабатывать медленнее, чем прямые вызовы функций.</span><span class="sxs-lookup"><span data-stu-id="dbddd-142">These functions can be on the order of 1000x slower than direct function calls.</span></span>

3) <span data-ttu-id="dbddd-143">**Будьте осторожны при упаковке**</span><span class="sxs-lookup"><span data-stu-id="dbddd-143">**Beware of boxing**</span></span>

    <span data-ttu-id="dbddd-144">[Упаковка](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) — это основная концепция C# языка и среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="dbddd-144">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) is a core concept of the C# language and runtime.</span></span> <span data-ttu-id="dbddd-145">Это процесс упаковки переменных со значениями типа char, int, bool и т. д. в ссылочные переменные.</span><span class="sxs-lookup"><span data-stu-id="dbddd-145">It is the process of wrapping value-typed variables such as char, int, bool, etc. into reference-typed variables.</span></span> <span data-ttu-id="dbddd-146">Если типизированная переменная со значением "упакована", она упаковывается внутри объекта System. Object, который хранится в управляемой куче.</span><span class="sxs-lookup"><span data-stu-id="dbddd-146">When a value-typed variable is "boxed", it is wrapped inside of a System.Object which is stored on the managed heap.</span></span> <span data-ttu-id="dbddd-147">Таким же объем памяти выделяется и, в конечном итоге, при удалении должна обрабатывать сборщик мусора.</span><span class="sxs-lookup"><span data-stu-id="dbddd-147">Thus, memory is allocated and eventually when disposed must be processed by the garbage collector.</span></span> <span data-ttu-id="dbddd-148">Распределение и освобождение ресурсов приводят к снижению производительности, и во многих случаях их не требуется или можно легко заменить на менее дорогостоящую альтернативу.</span><span class="sxs-lookup"><span data-stu-id="dbddd-148">These allocations and deallocations incur a performance cost and in many scenarios are unnecessary or can be easily replaced by a less expensive alternative.</span></span>

#### <a name="repeating-code-paths"></a><span data-ttu-id="dbddd-149">Повторяющиеся пути кода</span><span class="sxs-lookup"><span data-stu-id="dbddd-149">Repeating code paths</span></span>

<span data-ttu-id="dbddd-150">Любые повторяющиеся функции обратного вызова Unity (т. е.</span><span class="sxs-lookup"><span data-stu-id="dbddd-150">Any repeating Unity callback functions (i.e</span></span> <span data-ttu-id="dbddd-151">Обновление), выполняемое много раз в секунду и (или) кадре, должно быть тщательно написано.</span><span class="sxs-lookup"><span data-stu-id="dbddd-151">Update) that are executed many times per second and/or frame should be written very carefully.</span></span> <span data-ttu-id="dbddd-152">Все дорогостоящие операции в этом случае будут иметь огромное и устойчивое влияние на производительность.</span><span class="sxs-lookup"><span data-stu-id="dbddd-152">Any expensive operations here will have huge and consistent impact on performance.</span></span>

1) <span data-ttu-id="dbddd-153">**Пустые функции обратного вызова**</span><span class="sxs-lookup"><span data-stu-id="dbddd-153">**Empty callback functions**</span></span>

    <span data-ttu-id="dbddd-154">Несмотря на то, что приведенный ниже код может показаться безобиднымим в приложении, особенно поскольку каждый сценарий Unity выполняет автоматическую инициализацию с помощью этого блока кода, эти пустые обратные вызовы могут быть очень ресурсоемкими.</span><span class="sxs-lookup"><span data-stu-id="dbddd-154">Although the code below may seem innocent to leave in your application, especially since every Unity script auto-initializes with this code block, these empty callbacks can actually become very expensive.</span></span> <span data-ttu-id="dbddd-155">Unity работает с неуправляемой или управляемой границей кода, между кодом UnityEngine и кодом приложения.</span><span class="sxs-lookup"><span data-stu-id="dbddd-155">Unity operates back and forth over an unmanaged/managed code boundary, between UnityEngine code and your application code.</span></span> <span data-ttu-id="dbddd-156">Переключение контекста на этот мост занимает довольно много ресурсов, даже если нет никаких действий для выполнения.</span><span class="sxs-lookup"><span data-stu-id="dbddd-156">Context switching over this bridge is fairly expensive even if there is nothing to execute.</span></span> <span data-ttu-id="dbddd-157">Это особенно проблематично, если приложение имеет 100 объекты gameobject с компонентами, которые имеют пустые повторяющиеся обратные вызовы Unity.</span><span class="sxs-lookup"><span data-stu-id="dbddd-157">This becomes especially problematic if your app has 100's of GameObjects with components that have empty repeating Unity callbacks.</span></span>

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> <span data-ttu-id="dbddd-158">Update () — это наиболее распространенная версия этой проблемы с производительностью, но другие повторяющиеся обратные вызовы Unity, такие как следующие, могут быть так же неплохы, если не хуже: Фикседупдате (), Латеупдате (), Онпострендер ", OnPreRender (), Онрендеримаже () и т. д.</span><span class="sxs-lookup"><span data-stu-id="dbddd-158">Update() is the most common manifestation of this performance issue but other repeating Unity callbacks such as the following can be equally as bad if not worse: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span></span> 

2) <span data-ttu-id="dbddd-159">**Однократное выполнение операций для каждого кадра**</span><span class="sxs-lookup"><span data-stu-id="dbddd-159">**Operations to favor running once per frame**</span></span>

    <span data-ttu-id="dbddd-160">Следующие API Unity являются общими операциями для многих holographic приложений.</span><span class="sxs-lookup"><span data-stu-id="dbddd-160">The following Unity APIs are common operations for many Holographic Apps.</span></span> <span data-ttu-id="dbddd-161">Хотя это не всегда возможно, результаты этих функций могут быть вычислены один раз, а результаты повторно используются в приложении для определенного кадра.</span><span class="sxs-lookup"><span data-stu-id="dbddd-161">Although not always possible, the results from these functions can very commonly be computed once and the results re-utilized across the application for a given frame.</span></span>

    <span data-ttu-id="dbddd-162">о. как правило, рекомендуется иметь выделенный одноэлементный класс или службу для Райкастия взгляда в сцену, а затем повторно использовать этот результат во всех остальных компонентах сцены, а не повторять и фактически идентичные операции Райкаст по каждому см.</span><span class="sxs-lookup"><span data-stu-id="dbddd-162">a) Generally it is good practice to have a dedicated Singleton class or service to handle your gaze Raycast into the scene and then re-use this result in all other scene components, instead of making repeated and essentially identical Raycast operations by each component.</span></span> <span data-ttu-id="dbddd-163">Разумеется, некоторым приложениям может потребоваться райкастс из разных источников или разных [лайермаскс](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span><span class="sxs-lookup"><span data-stu-id="dbddd-163">Of course, some applications may require raycasts from different origins or against different [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span></span>

        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()

    <span data-ttu-id="dbddd-164">б) Избегайте операций с методом "не Component" () в повторяющихся обратных вызовах Unity, таких как Update (), путем [кэширования ссылок](#cache-references) в Start () или в спящий режим ()</span><span class="sxs-lookup"><span data-stu-id="dbddd-164">b) Avoid GetComponent() operations in repeated Unity callbacks like Update() by [caching references](#cache-references) in Start() or Awake()</span></span>

        UnityEngine.Object.GetComponent()

    <span data-ttu-id="dbddd-165">в) рекомендуется создавать экземпляры всех объектов, если это возможно, при инициализации и использовать [пул объектов](#object-pooling) для перезапуска и повторного использования объекты gameobject во время выполнения приложения.</span><span class="sxs-lookup"><span data-stu-id="dbddd-165">c) It is good practice to instantiate all objects, if possible, at initialization and use [object pooling](#object-pooling) to recycle and re-use GameObjects throughout runtime of your application</span></span>

        UnityEngine.Object.Instantiate()

3) <span data-ttu-id="dbddd-166">**Избегайте использования интерфейсов и виртуальных конструкций**</span><span class="sxs-lookup"><span data-stu-id="dbddd-166">**Avoid interfaces and virtual constructs**</span></span>

    <span data-ttu-id="dbddd-167">Вызов функций через интерфейсы и прямые объекты или вызов виртуальных функций часто может оказаться гораздо более затратным, чем использование прямых конструкций или прямых вызовов функций.</span><span class="sxs-lookup"><span data-stu-id="dbddd-167">Invoking function calls through interfaces vs direct objects or calling virtual functions can often times be much more expensive than utilizing direct constructs or direct function calls.</span></span> <span data-ttu-id="dbddd-168">Если виртуальная функция или интерфейс не требуется, то ее следует удалить.</span><span class="sxs-lookup"><span data-stu-id="dbddd-168">If the virtual function or interface is unnecessary, then it should be removed.</span></span> <span data-ttu-id="dbddd-169">Однако на производительность этих подходов обычно стоит компромисс, если они используются для упрощения совместной работы, удобочитаемости кода и удобства поддержки кода.</span><span class="sxs-lookup"><span data-stu-id="dbddd-169">However, the performance hit for these approaches are generally worth the trade-off if utilizing them simplifies development collaboration, code readability, and code maintainability.</span></span> 

4) <span data-ttu-id="dbddd-170">**Избегайте передачи структур по значению**</span><span class="sxs-lookup"><span data-stu-id="dbddd-170">**Avoid passing structs by value**</span></span>

    <span data-ttu-id="dbddd-171">В отличие от классов, структуры являются типами значений и при передаче непосредственно в функцию их содержимое копируется в только что созданный экземпляр.</span><span class="sxs-lookup"><span data-stu-id="dbddd-171">Unlike classes, structs are value-types and when passed directly to a function, their contents are copied into a newly created instance.</span></span> <span data-ttu-id="dbddd-172">Эта копия добавляет стоимость ЦП, а также дополнительную память в стеке.</span><span class="sxs-lookup"><span data-stu-id="dbddd-172">This copy adds CPU cost as well as additional memory on the stack.</span></span> <span data-ttu-id="dbddd-173">Для небольших структур такой результат обычно очень минимальный, а значит, приемлем.</span><span class="sxs-lookup"><span data-stu-id="dbddd-173">For small structs, the effect is usually very minimal and thus acceptable.</span></span> <span data-ttu-id="dbddd-174">Однако, если возможно, для функций повторно вызывается каждый кадр, а также функции, принимающие крупные структуры, по возможности измените определение функции для передачи по ссылке.</span><span class="sxs-lookup"><span data-stu-id="dbddd-174">However, for functions repeatedly invoked every frame as well as functions taking large structs, if possible modify the function definition to pass by reference.</span></span> [<span data-ttu-id="dbddd-175">Дополнительные сведения</span><span class="sxs-lookup"><span data-stu-id="dbddd-175">Learn more here</span></span>](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a><span data-ttu-id="dbddd-176">Прочее</span><span class="sxs-lookup"><span data-stu-id="dbddd-176">Miscellaneous</span></span>

1) <span data-ttu-id="dbddd-177">**Физики**</span><span class="sxs-lookup"><span data-stu-id="dbddd-177">**Physics**</span></span>

    <span data-ttu-id="dbddd-178">ответ. как правило, самый простой способ улучшить физические затраты — ограничить время, затрачиваемое на физическое или количество итераций в секунду.</span><span class="sxs-lookup"><span data-stu-id="dbddd-178">a) Generally, easiest way to improve physics is to limit the amount of time spent on Physics or the number of iterations per second.</span></span> <span data-ttu-id="dbddd-179">Разумеется, это снизит точность имитации.</span><span class="sxs-lookup"><span data-stu-id="dbddd-179">Of course, this will reduce simulation accuracy.</span></span> <span data-ttu-id="dbddd-180">См. раздел [тимеманажер](https://docs.unity3d.com/Manual/class-TimeManager.html) в Unity.</span><span class="sxs-lookup"><span data-stu-id="dbddd-180">See [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span></span>

    <span data-ttu-id="dbddd-181">б) тип конфликтующих данных в Unity имеет широко разные характеристики производительности.</span><span class="sxs-lookup"><span data-stu-id="dbddd-181">b) The type of colliders in Unity have widely different performance characteristics.</span></span> <span data-ttu-id="dbddd-182">В приведенном ниже порядке перечислены наиболее производительные конфликтующие по крайней мере более производительные конфликтующие.</span><span class="sxs-lookup"><span data-stu-id="dbddd-182">The order below lists the most performant colliders to least performant colliders from left to right.</span></span> <span data-ttu-id="dbddd-183">Наиболее важно избегать появления подлинности сети, которые значительно дороже, чем простые конфликты.</span><span class="sxs-lookup"><span data-stu-id="dbddd-183">It is most important to avoid Mesh Colliders which are substantially more expensive than the primitive colliders.</span></span>

        Sphere < Capsule < Box <<< Mesh (Convex) < Mesh (non-Convex)

    <span data-ttu-id="dbddd-184">Дополнительные сведения см. в разделе рекомендации по [использованию Unity физика](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) .</span><span class="sxs-lookup"><span data-stu-id="dbddd-184">See [Unity Physics Best Practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) for more info</span></span>

2) <span data-ttu-id="dbddd-185">**Анимирован**</span><span class="sxs-lookup"><span data-stu-id="dbddd-185">**Animations**</span></span>

    <span data-ttu-id="dbddd-186">Отключите анимацию простоя, отключив компонент аниматор (отключение объекта Game не приведет к тому же результату).</span><span class="sxs-lookup"><span data-stu-id="dbddd-186">Disable idle animations by disabling the Animator component (disabling the game object won't have the same effect).</span></span> <span data-ttu-id="dbddd-187">Избегайте шаблонов разработки, где аниматор находится в цикле, устанавливая значение в одно и то же действие.</span><span class="sxs-lookup"><span data-stu-id="dbddd-187">Avoid design patterns where an animator sits in a loop setting a value to the same thing.</span></span> <span data-ttu-id="dbddd-188">Для этого метода есть значительные издержки, которые не влияют на приложение.</span><span class="sxs-lookup"><span data-stu-id="dbddd-188">There is considerable overhead for this technique, with no effect on the application.</span></span> [<span data-ttu-id="dbddd-189">Дополнительные сведения см. здесь.</span><span class="sxs-lookup"><span data-stu-id="dbddd-189">Learn more here.</span></span>](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) <span data-ttu-id="dbddd-190">**Сложные алгоритмы**</span><span class="sxs-lookup"><span data-stu-id="dbddd-190">**Complex algorithms**</span></span>

    <span data-ttu-id="dbddd-191">Если приложение использует сложные алгоритмы, такие как обратная кинематика, поиск пути и т. д., найдите более простой подход или настройте соответствующие параметры для их производительности.</span><span class="sxs-lookup"><span data-stu-id="dbddd-191">If your application is using complex algorithms such as inverse kinematics, path finding, etc, look to find a simpler approach or adjust relevant settings for their performance</span></span>

## <a name="cpu-to-gpu-performance-recommendations"></a><span data-ttu-id="dbddd-192">Рекомендации по производительности ЦП и GPU</span><span class="sxs-lookup"><span data-stu-id="dbddd-192">CPU-to-GPU performance recommendations</span></span>

<span data-ttu-id="dbddd-193">Как правило, производительность процессора в графическом ПРОЦЕССОРе сводится к **вызовам Draw** , отправляемым на графическую карту.</span><span class="sxs-lookup"><span data-stu-id="dbddd-193">Generally, CPU-to-GPU performance comes down to the **draw calls** submitted to the graphics card.</span></span> <span data-ttu-id="dbddd-194">Чтобы повысить производительность, для достижения оптимальных результатов вызовы рисования должны быть стратегическими **а) уменьшенными** или **b)** .</span><span class="sxs-lookup"><span data-stu-id="dbddd-194">To improve performance, draw calls need to be strategically **a) reduced** or **b) restructured** for optimal results.</span></span> <span data-ttu-id="dbddd-195">Поскольку вызовы рисования являются ресурсоемкими, их уменьшение позволит сократить общую работу.</span><span class="sxs-lookup"><span data-stu-id="dbddd-195">Since draw calls themselves are resource-intensive, reducing them will reduce overall work required.</span></span> <span data-ttu-id="dbddd-196">Кроме того, изменения состояния между вызовами Draw требуют дорогостоящих действий по проверке и переводу в драйвере графики и, таким образом, реструктуризация вызовов рисования приложения для ограничения изменений состояния (т. е.</span><span class="sxs-lookup"><span data-stu-id="dbddd-196">Further, state changes between draw calls requires costly validation and translation steps in the graphics driver and thus, restructuring of your application's draw calls to limit state changes(i.e</span></span> <span data-ttu-id="dbddd-197">различные материалы и т. д. могут повысить производительность.</span><span class="sxs-lookup"><span data-stu-id="dbddd-197">different materials, etc) can boost performance.</span></span>

<span data-ttu-id="dbddd-198">В Unity есть отличная статья, в которой приводится обзор и подробно в пакетную обработку вызовов для своей платформы.</span><span class="sxs-lookup"><span data-stu-id="dbddd-198">Unity has a great article that gives an overview and dives into batching draw calls for their platform.</span></span>
- [<span data-ttu-id="dbddd-199">Пакетная обработка вызовов Unity</span><span class="sxs-lookup"><span data-stu-id="dbddd-199">Unity Draw Call Batching</span></span>](https://docs.unity3d.com/Manual/DrawCallBatching.html)

#### <a name="single-pass-instanced-rendering"></a><span data-ttu-id="dbddd-200">Обработка экземпляров с одним проходом</span><span class="sxs-lookup"><span data-stu-id="dbddd-200">Single pass instanced rendering</span></span>

<span data-ttu-id="dbddd-201">Однопроходная Визуализация с одним экземпляром в Unity позволяет уменьшить число вызовов рисования для каждого глаза до одного экземпляра Draw.</span><span class="sxs-lookup"><span data-stu-id="dbddd-201">Single Pass Instanced Rendering in Unity allows for draw calls for each eye to be reduced down to one instanced draw call.</span></span> <span data-ttu-id="dbddd-202">Из-за согласованности кэша между двумя вызовами Draw также существует и некоторое улучшение производительности GPU.</span><span class="sxs-lookup"><span data-stu-id="dbddd-202">Due to cache coherency between two draw calls, there is also some performance improvement on the GPU as well.</span></span>

<span data-ttu-id="dbddd-203">Включение этой функции в проекте Unity</span><span class="sxs-lookup"><span data-stu-id="dbddd-203">To enable this feature in your Unity Project</span></span>
1)  <span data-ttu-id="dbddd-204">Откройте **Параметры проигрывателя XR** (выберите **Правка** > **Параметры** > проекта**проигрыватель** > **Параметры XR**).</span><span class="sxs-lookup"><span data-stu-id="dbddd-204">Open **Player XR Settings** (go to **Edit** > **Project Settings** > **Player** > **XR Settings**)</span></span>
2) <span data-ttu-id="dbddd-205">Выберите **однопроходный экземпляр** из раскрывающегося меню **метода подготовки** к просмотру (необходимо установить флажок "**поддерживается виртуальная реальность** ").</span><span class="sxs-lookup"><span data-stu-id="dbddd-205">Select **Single Pass Instanced** from the **Stereo Rendering Method** drop-down menu (**Virtual Reality Supported** checkbox must be checked)</span></span>

<span data-ttu-id="dbddd-206">Ознакомьтесь со следующими статьями из Unity, чтобы получить подробные сведения об этом подходе к отрисовке.</span><span class="sxs-lookup"><span data-stu-id="dbddd-206">Read the following articles from Unity for details with this rendering approach.</span></span>
- [<span data-ttu-id="dbddd-207">Как добиться максимальной производительности AR и VR с помощью расширенной стерео визуализации</span><span class="sxs-lookup"><span data-stu-id="dbddd-207">How to maximize AR and VR performance with advanced stereo rendering</span></span>](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)
- [<span data-ttu-id="dbddd-208">Однопроходный создание экземпляров</span><span class="sxs-lookup"><span data-stu-id="dbddd-208">Single Pass Instancing</span></span>](https://docs.unity3d.com/Manual/SinglePassInstancing.html) 

>[!NOTE]
> <span data-ttu-id="dbddd-209">Одна из распространенных проблем с однопроходным экземпляром отрисовки происходит, если у разработчиков уже есть пользовательские шейдеры, не написанные для создания экземпляров.</span><span class="sxs-lookup"><span data-stu-id="dbddd-209">One common issue with Single Pass Instanced Rendering occurs if developers already have existing custom shaders not written for instancing.</span></span> <span data-ttu-id="dbddd-210">После включения этой функции разработчики могут заметить, что некоторые объекты gameobjectы отображаются только в одном глазе.</span><span class="sxs-lookup"><span data-stu-id="dbddd-210">After enabling this feature, developers may notice some GameObjects only render in one eye.</span></span> <span data-ttu-id="dbddd-211">Это обусловлено тем, что связанные пользовательские шейдеры не имеют соответствующих свойств для создания экземпляров.</span><span class="sxs-lookup"><span data-stu-id="dbddd-211">This is because the associated custom shaders do not have the appropriate properties for instancing.</span></span>
>
> <span data-ttu-id="dbddd-212">Способы решения этой проблемы см. в разделе однопроходное [Отображение стерео для HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) из Unity.</span><span class="sxs-lookup"><span data-stu-id="dbddd-212">See [Single Pass Stereo Rendering for HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) from Unity for how to address this problem</span></span>

#### <a name="static-batching"></a><span data-ttu-id="dbddd-213">Статическая пакетирование</span><span class="sxs-lookup"><span data-stu-id="dbddd-213">Static batching</span></span>

<span data-ttu-id="dbddd-214">Unity может пакетно группировать многие статические объекты, чтобы уменьшить число вызовов рисования к GPU.</span><span class="sxs-lookup"><span data-stu-id="dbddd-214">Unity is able to batch many static objects to reduce draw calls to the GPU.</span></span> <span data-ttu-id="dbddd-215">Статическая пакетирование работает для большинства объектов модуля [подготовки](https://docs.unity3d.com/ScriptReference/Renderer.html) отчетов в Unity, что **1) совместно используют один и тот же материал** и **2). все они помечены как *статические***  (выберите объект в Unity и установите флажок в правом верхнем углу инспектора).</span><span class="sxs-lookup"><span data-stu-id="dbddd-215">Static Batching works for most [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) objects in Unity that **1) share the same material** and **2) are all marked as *Static*** (Select an object in Unity and click the checkbox in the top right of the inspector).</span></span> <span data-ttu-id="dbddd-216">Объекты gameobject, помеченный как *static* , невозможно переместить во время выполнения приложения.</span><span class="sxs-lookup"><span data-stu-id="dbddd-216">GameObjects marked as *Static* cannot be moved throughout your application's runtime.</span></span> <span data-ttu-id="dbddd-217">Поэтому статическая пакетирование может быть трудно использовать в HoloLens, где практически все объекты должны размещаться, перемещаться, масштабироваться и т. д. Для впечатляющих головных телефонов статическая пакетирование может значительно сократить число вызовов рисования и, таким образом, повысить производительность.</span><span class="sxs-lookup"><span data-stu-id="dbddd-217">Thus, static batching can be difficult to leverage on HoloLens where virtually every object needs to be placed, moved, scaled, etc. For immersive headsets, static batching can dramatically reduce draw calls and thus improve performance.</span></span>

<span data-ttu-id="dbddd-218">Дополнительные сведения см. в разделе *статическая пакетирование пакетной* обработки [в Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) .</span><span class="sxs-lookup"><span data-stu-id="dbddd-218">Read *Static Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for more details.</span></span>

#### <a name="dynamic-batching"></a><span data-ttu-id="dbddd-219">Динамическая пакетирование</span><span class="sxs-lookup"><span data-stu-id="dbddd-219">Dynamic batching</span></span>

<span data-ttu-id="dbddd-220">Поскольку объекты не помечаются как *статические* для разработки HoloLens, динамическая Пакетная обработка может оказаться отличным инструментом для компенсации этой недостаточной функции.</span><span class="sxs-lookup"><span data-stu-id="dbddd-220">Since it is problematic to mark objects as *Static* for HoloLens development, dynamic batching can be a great tool to compensate for this lacking feature.</span></span> <span data-ttu-id="dbddd-221">Конечно же, он также может быть полезен и на впечатляющих гарнитурах.</span><span class="sxs-lookup"><span data-stu-id="dbddd-221">Of course, it is can also be useful on immersive headsets as well.</span></span> <span data-ttu-id="dbddd-222">Динамическая пакетирование в Unity может быть непростой, так как объекты gameobject должен иметь **общий доступ к одному и тому же материалу** и **б), что соответствует длинному списку других критериев**.</span><span class="sxs-lookup"><span data-stu-id="dbddd-222">Dynamic batching in Unity can be difficult though to enable because GameObjects must **a) share the same Material** and **b) meet a long list of other criteria**.</span></span>

<span data-ttu-id="dbddd-223">Полный список см. в статье *Динамическая Пакетная обработка* в [Unity. Пакетная обработка вызовов](https://docs.unity3d.com/Manual/DrawCallBatching.html) .</span><span class="sxs-lookup"><span data-stu-id="dbddd-223">Read *Dynamic Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for the full list.</span></span> <span data-ttu-id="dbddd-224">Чаще всего объекты gameobject становятся недопустимыми для динамического пакетной обработки, так как связанные данные сетки могут быть не более 300 вершин.</span><span class="sxs-lookup"><span data-stu-id="dbddd-224">Most commonly, GameObjects become invalid to be batched dynamically because the associated mesh data can be no more than 300 vertices.</span></span>

#### <a name="other-techniques"></a><span data-ttu-id="dbddd-225">Другие методы</span><span class="sxs-lookup"><span data-stu-id="dbddd-225">Other techniques</span></span>

<span data-ttu-id="dbddd-226">Пакетная обработка может выполняться, только если несколько объекты gameobject могут использовать одни и те же материалы.</span><span class="sxs-lookup"><span data-stu-id="dbddd-226">Batching can only occur if multiple GameObjects are able to share the same material.</span></span> <span data-ttu-id="dbddd-227">Как правило, это будет заблокировано потребностью объекты gameobject иметь уникальную текстуру для соответствующих материалов.</span><span class="sxs-lookup"><span data-stu-id="dbddd-227">Typically this will be blocked by the need for GameObjects to have a unique texture for their respective Material.</span></span> <span data-ttu-id="dbddd-228">Обычно текстуры объединяются в одну большую текстуру — метод, называемый [вытягивания текстур](https://en.wikipedia.org/wiki/Texture_atlas).</span><span class="sxs-lookup"><span data-stu-id="dbddd-228">It is common to combine Textures into one big Texture, a method known as [Texture Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span></span>

<span data-ttu-id="dbddd-229">Кроме того, обычно предпочтительнее объединять сетки в один GameObject, где это возможно и разумно.</span><span class="sxs-lookup"><span data-stu-id="dbddd-229">Further, it is generally preferable to combine meshes into one GameObject where possible and reasonable.</span></span> <span data-ttu-id="dbddd-230">Каждый модуль подготовки в Unity будет иметь связанные с ним вызовы рисования и отправлять объединенную сетку в одном модуле подготовки отчетов.</span><span class="sxs-lookup"><span data-stu-id="dbddd-230">Each Renderer in Unity will have it's associated draw call(s) versus submitting a combined mesh under one Renderer.</span></span> 

>[!NOTE]
> <span data-ttu-id="dbddd-231">Изменение свойств модуля подготовки отчетов. Material во время выполнения создает копию материала и, таким же, может привести к нарушению пакетирования.</span><span class="sxs-lookup"><span data-stu-id="dbddd-231">Modifying properties of Renderer.material at runtime will create a copy of the Material and thus potentially break batching.</span></span> <span data-ttu-id="dbddd-232">Используйте визуализатор. Шаредматериал для изменения свойств общих материалов в объекты gameobject.</span><span class="sxs-lookup"><span data-stu-id="dbddd-232">Use Renderer.sharedMaterial to modify shared material properties across GameObjects.</span></span>

## <a name="gpu-performance-recommendations"></a><span data-ttu-id="dbddd-233">Рекомендации по производительности GPU</span><span class="sxs-lookup"><span data-stu-id="dbddd-233">GPU performance recommendations</span></span>

<span data-ttu-id="dbddd-234">Дополнительные сведения об [оптимизации отрисовки графики в Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span><span class="sxs-lookup"><span data-stu-id="dbddd-234">Learn more about [optimizing graphics rendering in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span></span> 

### <a name="optimize-depth-buffer-sharing"></a><span data-ttu-id="dbddd-235">Оптимизация совместного использования буфера глубины</span><span class="sxs-lookup"><span data-stu-id="dbddd-235">Optimize depth buffer sharing</span></span>

<span data-ttu-id="dbddd-236">Обычно рекомендуется включить **совместное использование буфера глубины** в **параметрах XR проигрывателя** , чтобы оптимизировать [стабильность](Hologram-stability.md).</span><span class="sxs-lookup"><span data-stu-id="dbddd-236">It is generally recommended to enable **Depth buffer sharing** under **Player XR Settings** to optimize for [hologram stability](Hologram-stability.md).</span></span> <span data-ttu-id="dbddd-237">При включении повторного проецирования на основе глубины с помощью этого параметра рекомендуется выбрать **16-разрядный формат глубины** , а не **24-разрядный формат глубины**.</span><span class="sxs-lookup"><span data-stu-id="dbddd-237">When enabling depth-based late-stage reprojection with this setting however, it is recommended to select **16-bit depth format** instead of **24-bit depth format**.</span></span> <span data-ttu-id="dbddd-238">16-разрядные буферы глубины радикально снижают пропускную способность (и, таким образом, энергопотребление), связанную с трафиком в буфере глубины.</span><span class="sxs-lookup"><span data-stu-id="dbddd-238">The 16-bit depth buffers will drastically reduces the bandwidth (and thus power) associated with depth buffer traffic.</span></span> <span data-ttu-id="dbddd-239">Это может быть большой степенью выигрыша, но она применима только для удобства работы с небольшим диапазоном глубины, [так как с](https://en.wikipedia.org/wiki/Z-fighting) 16-разрядными, скорее всего, будет возникать большая вероятность.</span><span class="sxs-lookup"><span data-stu-id="dbddd-239">This can be a big power win, but is only applicable for experiences with a small depth range as [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) is more likely to occur with 16-bit than 24-bit.</span></span> <span data-ttu-id="dbddd-240">Чтобы избежать этих артефактов, измените близкие и далеко вырезанные плоскости [камеры Unity](https://docs.unity3d.com/Manual/class-Camera.html) , чтобы учитывать меньшую точность.</span><span class="sxs-lookup"><span data-stu-id="dbddd-240">To avoid these artifacts, modify the near/far clip planes of the [Unity camera](https://docs.unity3d.com/Manual/class-Camera.html) to account for the lower precision.</span></span> <span data-ttu-id="dbddd-241">Для приложений на основе HoloLens далеко плоскость 50 млн вместо 1000m по умолчанию Unity может, как правило, устранить любые отрезки от z.</span><span class="sxs-lookup"><span data-stu-id="dbddd-241">For HoloLens-based applications, a far clip plane of 50m instead of the Unity default 1000m can generally eliminate any z-fighting.</span></span>

### <a name="reduce-poly-count"></a><span data-ttu-id="dbddd-242">Сокращение числа поли</span><span class="sxs-lookup"><span data-stu-id="dbddd-242">Reduce poly count</span></span>

<span data-ttu-id="dbddd-243">Число многоугольников обычно сокращается с помощью</span><span class="sxs-lookup"><span data-stu-id="dbddd-243">Polygon count is usually reduced by either</span></span>
1) <span data-ttu-id="dbddd-244">Удаление объектов из сцены</span><span class="sxs-lookup"><span data-stu-id="dbddd-244">Removing objects from a scene</span></span>
2) <span data-ttu-id="dbddd-245">Децимации-ресурс, который сокращает количество многоугольников для данной сетки</span><span class="sxs-lookup"><span data-stu-id="dbddd-245">Asset decimation which reduces the number of polygons for a given mesh</span></span>
3) <span data-ttu-id="dbddd-246">Реализация в приложении [системы уровня детализации (Лод)](https://docs.unity3d.com/Manual/LevelOfDetail.html) , которая визуализирует объекты с более низкими координатами с использованием более низких версий той же геометрии</span><span class="sxs-lookup"><span data-stu-id="dbddd-246">Implementing a [Level of Detail (LOD) System](https://docs.unity3d.com/Manual/LevelOfDetail.html) into your application which renders far away objects with lower-polygon version of the same geometry</span></span>

### <a name="understanding-shaders-in-unity"></a><span data-ttu-id="dbddd-247">Общие сведения о шейдерах в Unity</span><span class="sxs-lookup"><span data-stu-id="dbddd-247">Understanding shaders in Unity</span></span>

<span data-ttu-id="dbddd-248">Простая аппроксимация для сравнения шейдеров в производительности заключается в определении среднего числа операций, выполняемых во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="dbddd-248">An easy approximation to compare shaders in performance is to identify the average number of operations each executes at runtime.</span></span> <span data-ttu-id="dbddd-249">Это можно легко сделать в Unity.</span><span class="sxs-lookup"><span data-stu-id="dbddd-249">This can be done easily in Unity.</span></span>

1) <span data-ttu-id="dbddd-250">Выберите ресурс шейдера или материал, а затем в правом верхнем углу окна инспектора выберите значок шестеренки и нажмите **кнопку "выбрать шейдер"** .</span><span class="sxs-lookup"><span data-stu-id="dbddd-250">Select your shader asset or select a material, then in top right corner of the inspector window, select the gear icon and then **"Select Shader"**</span></span>

    ![Выбор шейдера в Unity](images/Select-shader-unity.png)
2) <span data-ttu-id="dbddd-252">Выбрав ресурс шейдера, нажмите кнопку **"компилировать и отобразить код"** в окне инспектора.</span><span class="sxs-lookup"><span data-stu-id="dbddd-252">With the shader asset selected, click the **"Compile and show code"** button under the inspector window</span></span>

    ![Компиляция кода шейдера в Unity](images/compile-shader-code-unity.PNG)

3) <span data-ttu-id="dbddd-254">После компиляции найдите раздел статистики в результатах с числом различных операций для шейдера вершин и текстуры (Обратите внимание, что обычно шейдеры пикселей также называются шейдерами фрагментов).</span><span class="sxs-lookup"><span data-stu-id="dbddd-254">After compiling, look for the statistics section in the results with the number of different operations for both the vertex and pixel shader (Note: pixel shaders are often also called fragment shaders)</span></span>

    ![Операции шейдера Unity Standard](images/unity-standard-shader-compilation.png)

#### <a name="optmize-pixel-shaders"></a><span data-ttu-id="dbddd-256">Оптмизеные шейдеры пикселей</span><span class="sxs-lookup"><span data-stu-id="dbddd-256">Optmize pixel shaders</span></span>

<span data-ttu-id="dbddd-257">Просмотрев скомпилированные статистические результаты с помощью приведенного выше метода, [шейдер фрагментов](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) обычно выполняет больше операций, чем [шейдер вершин](https://en.wikipedia.org/wiki/Shader#Vertex_shaders) в среднем.</span><span class="sxs-lookup"><span data-stu-id="dbddd-257">Looking at the compiled statistic results using the method above, the [fragment shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) will generally execute more operations than the [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders) on average.</span></span> <span data-ttu-id="dbddd-258">Шейдер фрагментов, также называемый шейдером пикселей, выполняется на экране в выводе экрана, а шейдер вершин выполняется только на вершину всех сеток, отображаемых на экране.</span><span class="sxs-lookup"><span data-stu-id="dbddd-258">The fragment shader, also known as the pixel shader, is executed per pixel on the screen output while the vertex shader is only executed per-vertex of all meshes being drawn to the screen.</span></span> 

<span data-ttu-id="dbddd-259">Таким же словами, не только у шейдеров фрагментов есть больше инструкций, чем шейдеры вершин из-за всех вычислений освещения, шейдеры фрагментов практически всегда выполняются в более крупном наборе данных.</span><span class="sxs-lookup"><span data-stu-id="dbddd-259">Thus, not only do fragment shaders have more instructions than vertex shaders because of all the lighting calculations, fragment shaders are almost always executed on a larger dataset.</span></span> <span data-ttu-id="dbddd-260">Например, если в качестве выходных данных экрана используется образ в формате 2000 (2000), то шейдер фрагментов может стать выполненным, например, следующим образом: 4 000 000 раз.</span><span class="sxs-lookup"><span data-stu-id="dbddd-260">For example, if the screen output is a 2k by 2k image, then the fragment shader can get executed 2,000\*2,000 = 4,000,000 times.</span></span> <span data-ttu-id="dbddd-261">Если выводятся два глаза, это число удваивается, поскольку имеется два экрана.</span><span class="sxs-lookup"><span data-stu-id="dbddd-261">If rendering two eyes, this number doubles since there are two screens.</span></span> <span data-ttu-id="dbddd-262">Если приложение смешанной реальности имеет несколько проходов, полноэкранные действия после обработки или отрисовку нескольких сеток на один и тот же пиксель, это число будет существенно возрастать.</span><span class="sxs-lookup"><span data-stu-id="dbddd-262">If a mixed reality application has multiple passes, full-screen post-processing effects, or rendering multiple meshes to the same pixel, this number will increase dramatically.</span></span> 

<span data-ttu-id="dbddd-263">Таким образом, уменьшение количества операций в шейдере фрагментов может привести к значительному повышению производительности по сравнению с оптимизацией в шейдере вершин.</span><span class="sxs-lookup"><span data-stu-id="dbddd-263">Therefore, reducing the number of operations in the fragment shader can generally give far greater performance gains over optimizations in the vertex shader.</span></span>

#### <a name="unity-standard-shader-alternatives"></a><span data-ttu-id="dbddd-264">Альтернативные варианты шейдера Unity Standard</span><span class="sxs-lookup"><span data-stu-id="dbddd-264">Unity Standard shader alternatives</span></span>

<span data-ttu-id="dbddd-265">Вместо использования на основе физической отрисовки (PBR) или другого высококачественного шейдера рассмотрите использование более производительного и более дешевого шейдера.</span><span class="sxs-lookup"><span data-stu-id="dbddd-265">Instead of using a physically based rendering (PBR) or other high-quality shader, look at utilizing a more performant and cheaper shader.</span></span> <span data-ttu-id="dbddd-266">[Набор средств Mixed Reality](https://github.com/Microsoft/MixedRealityToolkit-Unity) предоставляет [стандартный шейдер мртк](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) , оптимизированный для проектов смешанной реальности.</span><span class="sxs-lookup"><span data-stu-id="dbddd-266">The [Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) provides the [MRTK standard shader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) that has been optimized for mixed reality projects.</span></span>

<span data-ttu-id="dbddd-267">Unity также предоставляет унлит, освещенность вершин, диффузию и другие упрощенные параметры шейдера, которые значительно быстрее по сравнению с шейдером стандарта Unity.</span><span class="sxs-lookup"><span data-stu-id="dbddd-267">Unity also provides an unlit, vertex lit, diffuse, and other simplified shader options that are significantly faster compared to the Unity Standard shader.</span></span> <span data-ttu-id="dbddd-268">Более подробные сведения см. [в статье Использование и производительность встроенных шейдеров](https://docs.unity3d.com/Manual/shader-Performance.html) .</span><span class="sxs-lookup"><span data-stu-id="dbddd-268">See [Usage and Performance of Built-in Shaders](https://docs.unity3d.com/Manual/shader-Performance.html) for more detailed information.</span></span>

#### <a name="shader-preloading"></a><span data-ttu-id="dbddd-269">Предварительная загрузка шейдера</span><span class="sxs-lookup"><span data-stu-id="dbddd-269">Shader preloading</span></span>

<span data-ttu-id="dbddd-270">Используйте *предварительную загрузку шейдера* и другие приемы для оптимизации [времени загрузки шейдера](http://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span><span class="sxs-lookup"><span data-stu-id="dbddd-270">Use *Shader preloading* and other tricks to optimize [shader load time](http://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span></span> <span data-ttu-id="dbddd-271">В частности, Предварительная загрузка шейдера означает, что вы не увидите хитчес из-за компиляции шейдера времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="dbddd-271">In particular, shader preloading means you won't see any hitches due to runtime shader compilation.</span></span>

### <a name="limit-overdraw"></a><span data-ttu-id="dbddd-272">Ограничить перерисовку</span><span class="sxs-lookup"><span data-stu-id="dbddd-272">Limit overdraw</span></span>

<span data-ttu-id="dbddd-273">В Unity один может отображать перерисовку для своего сцены, переключаясь в [**меню режима рисования**](https://docs.unity3d.com/Manual/ViewModes.html) в левом верхнем углу **представления сцены** и выбрав команду Перерисовать .</span><span class="sxs-lookup"><span data-stu-id="dbddd-273">In Unity, one can display overdraw for their scene, by toggling the [**draw mode menu**](https://docs.unity3d.com/Manual/ViewModes.html) in the top left corner of the **Scene view** and selecting **Overdraw**.</span></span>

<span data-ttu-id="dbddd-274">Как правило, перерисовку можно уменьшить путем отбора объектов перед отправкой в GPU.</span><span class="sxs-lookup"><span data-stu-id="dbddd-274">Generally, overdraw can be mitigated by culling objects ahead of time before they are sent to the GPU.</span></span> <span data-ttu-id="dbddd-275">Unity предоставляет подробные сведения о реализации [отбора перекрытия](https://docs.unity3d.com/Manual/OcclusionCulling.html) для подсистемы.</span><span class="sxs-lookup"><span data-stu-id="dbddd-275">Unity provides details on implementing [Occlusion Culling](https://docs.unity3d.com/Manual/OcclusionCulling.html) for their engine.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="dbddd-276">Рекомендации по использованию памяти</span><span class="sxs-lookup"><span data-stu-id="dbddd-276">Memory recommendations</span></span>

<span data-ttu-id="dbddd-277">Чрезмерное выделение памяти & операциях изъятия может оказать негативное влияние на работу с holographic, что приведет к нестабильной производительности, замороженным кадрам и другим негативным последствиям.</span><span class="sxs-lookup"><span data-stu-id="dbddd-277">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="dbddd-278">Особенно важно понимать требования к памяти при разработке в Unity, так как управление памятью управляется сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="dbddd-278">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="garbage-collection"></a><span data-ttu-id="dbddd-279">Сборка мусора</span><span class="sxs-lookup"><span data-stu-id="dbddd-279">Garbage collection</span></span>

<span data-ttu-id="dbddd-280">При активации сборщика мусора для анализа объектов, которые больше не находятся в области действия во время выполнения, и их освобождения памяти для повторного использования, holographic приложений не сможет обработать вычислительные ресурсы до момента их обработки.</span><span class="sxs-lookup"><span data-stu-id="dbddd-280">Holographic apps will loose processing compute time to the garbage collector (GC) when the GC is activated to analyze objects that are no longer in scope during execution and their memory needs to be released so it can be made available for re-use.</span></span> <span data-ttu-id="dbddd-281">Для постоянных распределений и отмены распределения обычно требуется, чтобы сборщик мусора выполнялся чаще, что приводит к ухудшению производительности и удобства работы пользователей.</span><span class="sxs-lookup"><span data-stu-id="dbddd-281">Constant allocations and de-allocations will generally require the garbage collector to run more frequently thus hurting performance and user experience.</span></span>

<span data-ttu-id="dbddd-282">В Unity была предоставлена отличная страница, в которой подробно объясняется, как работает сборщик мусора и советы по написанию более эффективного кода в отношении управления памятью.</span><span class="sxs-lookup"><span data-stu-id="dbddd-282">Unity has provided an excellent page that explains in detail how the garbage collector works and tips to write more efficient code in regards to memory management.</span></span>
- [<span data-ttu-id="dbddd-283">Оптимизация сборки мусора в играх Unity</span><span class="sxs-lookup"><span data-stu-id="dbddd-283">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)

<span data-ttu-id="dbddd-284">Одной из наиболее распространенных методик, приводящих к чрезмерной сборке мусора, является кэширование ссылок на компоненты и классы в разработке Unity.</span><span class="sxs-lookup"><span data-stu-id="dbddd-284">One of the most common practices that leads to excessive garbage collection is not caching references to components and classes in Unity development.</span></span> <span data-ttu-id="dbddd-285">Все ссылки должны быть захвачены во время запуска () или спящего режима () и повторно использоваться в последующих функциях, таких как Update () или Латеупдате ().</span><span class="sxs-lookup"><span data-stu-id="dbddd-285">Any references should be captured during Start() or Awake() and re-used in later functions such as Update() or LateUpdate().</span></span>

<span data-ttu-id="dbddd-286">Другие краткие советы:</span><span class="sxs-lookup"><span data-stu-id="dbddd-286">Other quick tips:</span></span>
- <span data-ttu-id="dbddd-287">Использование класса [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# для динамической сборки сложных строк во время выполнения</span><span class="sxs-lookup"><span data-stu-id="dbddd-287">Use the [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# class to dynamically build complex strings at runtime</span></span>
- <span data-ttu-id="dbddd-288">Удалить вызовы Debug. log (), если они больше не нужны, так как они все еще выполняются во всех версиях сборки приложения.</span><span class="sxs-lookup"><span data-stu-id="dbddd-288">Remove calls to Debug.Log() when no longer needed as they still execute in all build versions of an app</span></span>
- <span data-ttu-id="dbddd-289">Если в holographic приложении обычно требуется много памяти, рассмотрите возможность вызова [ _**System. GC. сбора ()**_ ](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) во время загрузки, например при показе экрана загрузки или перехода</span><span class="sxs-lookup"><span data-stu-id="dbddd-289">If your holographic app generally requires lots of memory, consider calling  [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) during loading phases such as when presenting a loading or transition screen</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="dbddd-290">Объединение объектов в пул</span><span class="sxs-lookup"><span data-stu-id="dbddd-290">Object pooling</span></span>

<span data-ttu-id="dbddd-291">Использование пулов объектов — популярная методика снижения затрат на непрерывное выделение памяти & освобождением объектов.</span><span class="sxs-lookup"><span data-stu-id="dbddd-291">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="dbddd-292">Это делается путем выделения большого пула идентичных объектов и повторного использования неактивных, доступных экземпляров из этого пула вместо постоянного создания и уничтожения объектов с течением времени.</span><span class="sxs-lookup"><span data-stu-id="dbddd-292">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="dbddd-293">Пулы объектов отлично подходят для повторного создания компонентов, которые имеют переменное время существования во время выполнения приложения.</span><span class="sxs-lookup"><span data-stu-id="dbddd-293">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

- [<span data-ttu-id="dbddd-294">Руководство по пулам объектов в Unity</span><span class="sxs-lookup"><span data-stu-id="dbddd-294">Object Pooling Tutorial in Unity</span></span>](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a><span data-ttu-id="dbddd-295">Производительность при запуске</span><span class="sxs-lookup"><span data-stu-id="dbddd-295">Startup performance</span></span>

<span data-ttu-id="dbddd-296">Рекомендуется запустить приложение с небольшой сценой, а затем использовать *[сценеманажер. лоадсценеасинк](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* для загрузки оставшейся части сцены.</span><span class="sxs-lookup"><span data-stu-id="dbddd-296">You should consider starting your app with a smaller scene, then using *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* to load the rest of the scene.</span></span> <span data-ttu-id="dbddd-297">Это позволяет приложению перейти в интерактивное состояние как можно быстрее.</span><span class="sxs-lookup"><span data-stu-id="dbddd-297">This allows your app to get to an interactive state as fast as possible.</span></span> <span data-ttu-id="dbddd-298">Имейте в виду, что во время активации новой сцены может возникнуть большой Пиковый объем ресурсов ЦП, а все отображаемое содержимое может перебои или Хитч.</span><span class="sxs-lookup"><span data-stu-id="dbddd-298">Be aware that there may be a large CPU spike while the new scene is being activated and that any rendered content might stutter or hitch.</span></span> <span data-ttu-id="dbddd-299">Один из способов обойти это — установить для свойства AsyncOperation. Алловсценеактиватион значение false в загружаемой сцене, дождаться загрузки сцены, очистить экран до черного, а затем снова установить значение true для завершения активации сцены.</span><span class="sxs-lookup"><span data-stu-id="dbddd-299">One way to work around this is to set the AsyncOperation.allowSceneActivation property to false on the scene being loaded, wait for the scene to load, clear the screen to black, and then set back to true to complete the scene activation.</span></span>

<span data-ttu-id="dbddd-300">Помните, что во время загрузки сцены с начальным экраном пользователю будет отображаться экран-заставка.</span><span class="sxs-lookup"><span data-stu-id="dbddd-300">Remember that while the startup scene is loading the holographic splash screen will be displayed to the user.</span></span>

## <a name="see-also"></a><span data-ttu-id="dbddd-301">См. также</span><span class="sxs-lookup"><span data-stu-id="dbddd-301">See also</span></span>
- [<span data-ttu-id="dbddd-302">Оптимизация отрисовки графики в играх Unity</span><span class="sxs-lookup"><span data-stu-id="dbddd-302">Optimizing graphics rendering in Unity games</span></span>](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)
- [<span data-ttu-id="dbddd-303">Оптимизация сборки мусора в играх Unity</span><span class="sxs-lookup"><span data-stu-id="dbddd-303">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)
- <span data-ttu-id="dbddd-304">[Лучшие методики [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span><span class="sxs-lookup"><span data-stu-id="dbddd-304">[Physics Best Practices [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span></span>
- <span data-ttu-id="dbddd-305">[Оптимизация скриптов [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span><span class="sxs-lookup"><span data-stu-id="dbddd-305">[Optimizing Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span></span>
