---
title: Рекомендации по производительности для Unity
description: Характерное для Unity советы по улучшению производительности с помощью приложения смешанной реальности.
author: Troy-Ferrell
ms.author: trferrel
ms.date: 03/26/2019
ms.topic: article
keywords: графики, ЦП, gpu, Подготовка к просмотру, сборщик мусора, hololens
ms.openlocfilehash: b0821f07184bff8630f6b6af0d0fc461f6fcd133
ms.sourcegitcommit: 8f3ff9738397d9b9fdf4703b14b89d416f0186a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/12/2019
ms.locfileid: "67843336"
---
# <a name="performance-recommendations-for-unity"></a>Рекомендации по производительности для Unity

Эта статья основана на обсуждение, описанные в [рекомендации по производительности для смешанной реальности](understanding-performance-for-mixed-reality.md) уделяется вопросам полученные данные для конкретных для среды ядра Unity.

Также настоятельно рекомендуется, разработчикам ознакомиться с [рекомендуемые параметры среды для статьи Unity](Recommended-settings-for-unity.md). В этой статье имеет содержимое с некоторыми из наиболее важных конфигураций сцены в отношении создания производительных приложений смешанной реальности. Некоторые из этих рекомендуемых параметров будут выделены ниже также.

## <a name="how-to-profile-with-unity"></a>Профилирование с помощью Unity

Среда Unity предоставляет **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** встроенные, который является превосходным ресурсом, чтобы собрать сведения производительность для вашего конкретного приложения. Несмотря на то, что можно запускать профилировщика в редакторе, эти показатели представляют значение true, среда выполнения, и таким образом, результаты из этого следует использовать осторожно. Рекомендуется удаленно профиль вашего приложения во время выполнения на устройстве для наиболее точные и практических сведений. Кроме того, Unity [отладчик кадра](https://docs.unity3d.com/Manual/FrameDebugger.html) также является очень мощным и средством анализа для использования.

Среда Unity предоставляет важная документация для:
1) Как подключить [Unity profiler для приложений UWP удаленно](https://docs.unity3d.com/Manual/windowsstore-profiler.html)
2) Как эффективно [диагностики проблем производительности с помощью Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)

>[!NOTE]
> С помощью Unity Profiler подключен и после добавления профилировщик GPU (см. в разделе *добавьте Profiler* в правом верхнем углу), один можно увидеть, сколько времени тратится на ЦП и GPU соответственно середине профилировщика. Это позволяет разработчику для получения быстрого приближения при ограниченных GPU или ЦП своих приложений.
>
> ![Unity ЦП и GPU](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a>Рекомендации по производительности ЦП

Содержимое ниже описаны дополнительные оптимизации подробно производительности, особенно предназначенные для Unity & C# разработки.

#### <a name="cache-references"></a>Ссылки кэша

Это рекомендуется для кэширования ссылок на все соответствующие компоненты и объекты Gameobject при инициализации. Это обусловлено повторяющиеся вызовы функций, таких как *[GetComponent\<T > ()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* значительно дороже, по отношению к памяти для хранения указателя. Это относится также к очень, регулярно используемые [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html). *Camera.Main* фактически использует *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* под которой затратами, выполняет поиск в графе сцены, для объекта камеры с *«MainCamera»*  тега.

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] 
> Избегайте GetComponent(string) <br/>
> При использовании  *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* , существует множество различных перегрузок. Очень важно всегда использовать в реализациях на основе типа он не может быть перегрузка поиска строковых. Поиск по строке в сцене является значительно дороже, чем поиск по типу. <br/>
> (Хорошо) Компонент GetComponent (тип) <br/>
> (Хорошо) T GetComponent\<T >) <br/>
> (Плохое) Компонент GetComponent(string) > <br/>

#### <a name="avoid-expensive-operations"></a>Избежать ресурсоемких операций

1) **Избегайте использования [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**

    Несмотря на то, что LINQ может быть очень простым и ясным для чтения и записи, обычно требуется намного больше вычислений и особенно дополнительные выделения памяти, чем написание алгоритм вручную.

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) **Общие интерфейсы API Unity**

    Некоторые API Unity, хоть и полезны, может быть очень дорогостоящей. Большинство из них включают в себя поиск граф сцены целиком для некоторых соответствующий список объекты Gameobject. Обычно эти операции можно избежать путем кэширования ссылки или реализация компонента диспетчера для объекты Gameobject рассматриваемый для отслеживания ссылок во время выполнения.

        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()

>[!NOTE]
> *[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)*  и *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* необходимо устранить любой ценой. Эти функции могут быть порядка 1000 x медленнее, чем прямые вызовы.

3) **Имейте в виду, упаковки-преобразования**

    [Упаковка-преобразование](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) является основным принципом C# языка и среды выполнения. Это процесс упаковки значение типизированные переменные, например char, int, bool, и т.д. в ссылку типизированные переменные. Значение переменной «упаковывается», оборачивается внутри System.Object, который хранится в управляемой куче. Таким образом, выделения памяти и со временем при удалении обрабатывается сборщиком мусора. Этих операций выделения и освобождения к затратам производительности и во многих случаях являются ненужными или могут быть просто заменены более дешевле по сравнению.

#### <a name="repeating-code-paths"></a>Повторение путях кода

Повторяющийся функций обратного вызова Unity (например) Обновление), которые выполняются несколько раз в секунду и/или кадр должен быть записан очень осторожно. Здесь ресурсоемких операций повлияет огромный и согласованное на производительность.

1) **Функции обратного вызова пустой**

    Несмотря на то, что в приведенном ниже коде может показаться безобидно, чтобы выйти из приложения, особенно с момента каждые Unity скрипта автоматически инициализирует с этот блок кода, эти пустой обратные вызовы фактически может стать очень дорого. Unity функционирует и обратно через границу управляемого и неуправляемого кода между кодом UnityEngine и код приложения. Контекст, переключение этот мост стоит довольно дорого, даже если нет ничего для выполнения. Это становится особенно проблематичным, если ваше приложение должно быть 100 объекты Gameobject с компонентами, которые имеют пустой повторяющейся обратные вызовы Unity.

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> Update() наиболее распространенной реализацией этой проблемы с производительностью, но другие повторяющиеся обратные вызовы Unity следующего может быть столь же же плохо, если не хуже: OnPostRender FixedUpdate() LateUpdate(),» OnPreRender(), OnRenderImage() и т. д. 

2) **Операции предпочитать однократного запуска на кадр**

    Следующие API-интерфейсы Unity — это распространенные операции для многих приложений, Holographic. Несмотря на то что не всегда возможно, результаты из этих функций может быть вычислено очень часто один раз и результатов, повторно используется во всем приложении для заданного кадра.

    ) обычно рекомендуется имели выделенный Singleton-класса или службы для обработки вашего Raycast взглядом на сцене и повторно использовать этот результат во всех других компонентах сцены, вместо того, чтобы операции Raycast повторяющиеся и по сути идентичны каждым компонент. Само собой, некоторым приложениям может понадобиться raycasts из разных источников или от разных [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).

        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()

    b) GetComponent() операций в повторяющихся обратные вызовы Unity как Update(), избежать [кэширования ссылки](#cache-references) в Start() или Awake()

        UnityEngine.Object.GetComponent()

    c) рекомендуется создать все объекты, если это возможно, инициализации и использования [пулов объектов](#object-pooling) корзины и повторно использовать объекты Gameobject на протяжении всего времени выполнения приложения

        UnityEngine.Object.Instantiate()

3) **Избегайте интерфейсы и виртуальными конструкциями**

    Вызовы функции через интерфейсы vs прямых объектов или вызов виртуальных функций зачастую можно гораздо дороже, чем прямое конструкции или прямые вызовы. Если виртуальной функции или интерфейса не нужен, то его следует удалить. Однако снижение производительности для этих подходов, обычно пожертвовать если их использование упрощает совместной разработки, читаемость кода и удобства поддержки кода. 

4) **Избежать передачи структуры по значению**

    В отличие от классов структуры являются типами значений и копируются при передаче непосредственно в функции, их содержимое в только что созданный экземпляр. Эта копия добавляет ЦП, а также дополнительная память в стеке. Для небольших структур результат будет обычно минимальными и таким образом приемлемо. Тем не менее для каждого кадра многократно вызывать функции, а также функции, принимающие больших структур, если это возможно измените определение функции для передачи по ссылке. [Дополнительные сведения](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a>Прочее

1) **Физика**

    ) в целом самый простой способ улучшить физики является ограничить объем времени, затрачиваемого на физических или число итераций в секунду. Само собой это позволит снизить точность модели. См. в разделе [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) в Unity

    (б) тип colliders в Unity имеют широко различные характеристики производительности. Порядок ниже перечислены большинство colliders высокой производительностью для минимальных colliders высокопроизводительных слева направо. Наиболее важно избежать Mesh Colliders которого существенно дороже, чем примитивный colliders.

        Sphere < Capsule < Box <<< Mesh (Convex) < Mesh (non-Convex)

    См. в разделе [рекомендации физики Unity](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) Дополнительные сведения

2) **Анимации**

    Отключить простоя анимации путем отключения компонента Animator (отключение игровому объекту не будет иметь тот же эффект). Избегайте шаблоны разработки, где animator находится в цикле присвоить то же самое значение. Есть существенные системные издержки, в рамках этого способа без влияния на приложение. [Дополнительные сведения см. здесь.](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) **Сложные алгоритмы**

    Если приложение использует сложные алгоритмы, например обратной кинематики, путь поиска, и т.д., можно попытаться найти более простой подход, или настроить соответствующие параметры для их производительность

## <a name="cpu-to-gpu-performance-recommendations"></a>Рекомендации по повышению производительности ЦП в GPU

Как правило, производительности ЦП в GPU идет **вызовы draw** отправляется графической карты. Чтобы повысить производительность, должны быть стратегически вызовов draw **) ограниченной** или **b) реструктуризации** для получения оптимальных результатов. Так как вызовы draw, сами являются ресурсоемкими, сокращая их уменьшит общую работ, необходимый. Кроме того, состояние изменения между вызовами draw требует дорогостоящих проверки и действия преобразования в графическом драйвере и таким образом, реструктуризацию вызовы draw в приложении, чтобы ограничить изменения состояния (например) различные материалы и т. д) может повысить производительность.

Unity есть хорошая статья, представлен обзор и углубляется в Пакетная обработка вызовов draw для своей платформы.
- [Unity рисования пакетной обработки вызова](https://docs.unity3d.com/Manual/DrawCallBatching.html)

#### <a name="single-pass-instanced-rendering"></a>Один проход внутренне отрисовки

Однократного прохода отрисовки Instanced в Unity позволяет вызовов draw для каждого глаза быть уменьшен до вызова draw один экземпляр. Из-за согласование с кэшем между двумя вызовами draw есть также некоторые улучшения производительности на GPU, а также.

Чтобы включить эту функцию в проекте Unity
1)  Откройте **параметры проигрывателя XR** (перейдите к **изменить** > **параметры проекта** > **проигрывателя**  >  **XR параметры**)
2) Выберите **экземпляры одного передать** из **стерео метод визуализации** раскрывающееся меню (**поддерживается виртуальной реальности** должен быть установлен флажок)

Дополнительные сведения при таком подходе подготовки к просмотру, ознакомьтесь со следующими статьями из Unity.
- [Как добиться максимальной производительности AR и VR с расширенный рендеринг стерео](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)
- [Создание экземпляров однократного прохода](https://docs.unity3d.com/Manual/SinglePassInstancing.html) 

>[!NOTE]
> Один распространенная проблема с одной передавать экземпляры отрисовки возникает, если разработчики уже есть существующие пользовательскими шейдерами, не написаны для создания экземпляров. После включения этого компонента, разработчики заметить некоторые объекты Gameobject только визуализации, в один глаз. Это обусловлено тем, связанных пользовательскими шейдерами, не имеют соответствующих свойств для создания экземпляров.
>
> См. в разделе [единый передать стерео отрисовки для HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) из Unity способов решения этой проблемы

#### <a name="static-batching"></a>Статические пакетной обработки

Unity способен выполнить пакетную много статических объектов для сокращения вызовов draw в GPU. Статические Пакетная обработка работает для большинства [модуль подготовки отчетов](https://docs.unity3d.com/ScriptReference/Renderer.html) объектов в Unity, **1) совместно используют тот же материал** и **2) являются все помеченные как *статический***  () Выберите объект в Unity и установите флажок в правом верхнем углу inspector). Объекты Gameobject с пометкой *статический* не может быть перемещен на протяжении всего времени выполнения приложения. Таким образом статический Пакетная обработка может быть трудно применять на HoloLens, где практически любой объект, должен быть помещен, перемещенный, масштабируемого и т. д. Для иммерсивную статические пакетной обработки можно значительно сократить вызовов draw и тем самым улучшить производительность.

Чтение *статический пакетной обработки* под [рисования вызвать пакетную обработку в Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) Дополнительные сведения.

#### <a name="dynamic-batching"></a>Динамические пакетной обработки

Так как он является проблематичным, чтобы пометить объекты как *статический* для разработки HoloLens, динамические Пакетная обработка может быть отличное средство для решения данной проблемы отсутствует компонент. Само собой, это может также пригодиться в иммерсивную также. Динамические пакетную обработку в Unity довольно сложно хотя включить, поскольку объекты Gameobject необходимо **) общего ресурса такого же материала** и **b) соответствуют длинный список других критериев**.

Чтение *динамического пакетной обработки* под [рисования вызвать пакетную обработку в Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) полный список. Обычно объекты Gameobject становятся недействительными организуемые динамически, так как связанные сети данные могут быть не более чем 300 вершины.

#### <a name="other-techniques"></a>другие функции

Пакетная обработка возможна только если несколько объекты Gameobject могут совместно использовать тот же материал. Обычно это будет блокироваться потребность в объекты Gameobject иметь уникальный текстуры для их соответствующие материалы. Довольно часто для объединения в один большой текстуры, метод, называемый текстуры [Atlasing текстуры](https://en.wikipedia.org/wiki/Texture_atlas).

Кроме того обычно предпочтительнее объединить сеток в один объект GameObject, где это возможно и наиболее подходящий. Каждый модуль подготовки отчетов в Unity оно было связано вызовов draw и отправка сетку, объединенных в один модуль подготовки отчетов. 

>[!NOTE]
> Изменение свойств Renderer.material во время выполнения будет создать копию материала и таким образом нарушить пакетной обработки. Используйте Renderer.sharedMaterial для изменения свойств материалов совместно объекты Gameobject.

## <a name="gpu-performance-recommendations"></a>Рекомендации по производительности GPU

Дополнительные сведения о [оптимизация отрисовки графики в Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games) 

### <a name="optimize-depth-buffer-sharing"></a>Оптимизировать совместное использование буфера глубины

Обычно рекомендуется включить **совместное использование буфера глубины** под **параметры проигрывателя XR** для оптимизации для [голограмма стабильность](Hologram-stability.md). При включении функции на основе глубины reprojection последующего с этот параметр, тем не менее, рекомендуется выбрать **формат 16-битовая глубина** вместо **глубина 24-разрядный формат**. Будет буферов глубины 16-разрядное коренным образом уменьшает пропускную способность (и тем самым питания) связанные с трафиком буфер глубины. Это может быть win Большая мощность, но применяется только для взаимодействия с небольшой глубины диапазон как [борьба с z](https://en.wikipedia.org/wiki/Z-fighting) более вероятна с 16-разрядное, чем 24 бита. Чтобы предотвратить эти артефакты, изменить плоскостей практически/до дальней отсекающей [камеры Unity](https://docs.unity3d.com/Manual/class-Camera.html) скомпенсировать низкой точности. Для приложений на основе HoloLens до дальней отсекающей плоскости из 50 млн вместо Unity по умолчанию 1000 МБ обычно можно исключить любые борьба z.

### <a name="reduce-poly-count"></a>Уменьшение числа poly

Количество многоугольников, обычно уменьшается на один
1) Удаление объектов из сцены
2) Decimation активов, что уменьшает количество многоугольников данной сетки
3) Реализация [уровень детализации (LOD) системы](https://docs.unity3d.com/Manual/LevelOfDetail.html) в приложение, в которой отображается слишком далеко от объектов с версией той же геометрии в нижнем многоугольника

### <a name="understanding-shaders-in-unity"></a>Основные сведения о шейдеров в Unity

Легко приближенное значение для сравнения шейдеров в производительности — чтобы определить среднее число операций каждого выполняется во время выполнения. Это можно легко сделать в Unity.

1) Выберите ресурс шейдера или выберите материал, а затем в правом верхнем углу окна инспектора, щелкните значок шестеренки и затем **«Шейдера выберите»**

    ![Выберите шейдер в Unity](images/Select-shader-unity.png)
2) С активом шейдера выбран, щелкните **«Компиляции и Показать код»** кнопки в окне инспектора

    ![Компиляция кода шейдера в Unity](images/compile-shader-code-unity.PNG)

3) После компиляции, найдите раздел статистики в результатах с количество различных операций для шейдеров вершин и пикселей (Примечание: построители текстуры, часто также называются шейдеры фрагмент)

    ![Операции стандартный шейдера Unity](images/unity-standard-shader-compilation.png)

#### <a name="optmize-pixel-shaders"></a>Построители текстуры пространств

Просмотрев результаты скомпилированного статистики, используя описанный выше, метод [fragment шейдера](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) обычно будет выполнять больше операций, чем [вершинный построитель текстуры](https://en.wikipedia.org/wiki/Shader#Vertex_shaders) в среднем. Шейдер фрагментов, также называется текстуры, выполняется на пиксель в окне вывода во время вершинный построитель текстуры — только выполненного отдельных вершин все сеток, в которых выводится на экран. 

Таким образом не только фрагмент шейдеры у Дополнительные инструкции, чем шейдеры вершин из-за всех вычислениях освещения, шейдеры фрагмент почти всегда выполняются на набора данных большего размера. Например, если выходные данные, экран 2k 2 k образа, затем шейдер фрагмента можно получить выполнения 2, 000 * 2 000 = 4,000,000 раз. Если Подготовка к просмотру двух глаза, этот номер удваивается, так как существуют два экрана. Если приложения смешанной реальности несколько проходов, весь экран постобработка эффекты или Подготовка к просмотру нескольких сеток и тому же пикселу, значительно увеличит это число. 

Таким образом уменьшая количество операций в шейдере фрагмент обычно обеспечивает гораздо большей производительности по оптимизации в шейдер вершин.

#### <a name="unity-standard-shader-alternatives"></a>Альтернативные варианты Standard шейдера Unity

Вместо использования физически на основе отрисовки (PBR) или другие шейдера высокого качества, взгляните на использование более высокую производительность и дешевле шейдера. [Смешанной реальности Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) предоставляет [MRTK стандартный шейдера](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) , был оптимизирован для смешанной реальности проектов.

Unity также предоставляет Неосвещенные, горит вершин, упрощенная шейдера рассеянный и другие параметры, которые являются значительно быстрее по сравнению с Unity стандартный шейдера. См. в разделе [об использовании и производительности встроенные шейдеры](https://docs.unity3d.com/Manual/shader-Performance.html) более подробные сведения.

#### <a name="shader-preloading"></a>Предварительная загрузка шейдера

Используйте *шейдера предварительная загрузка* и другие рекомендации для оптимизации [время загрузки шейдера](http://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html). В частности шейдер предварительная загрузка означает, что вы не увидите любой остановок, из-за компиляции шейдеров во время выполнения.

### <a name="limit-overdraw"></a>Ограничение может быть нарисован поверх

В Unity, один может отображать перерисовывать для их сцены, переключив [ **вывод меню режима** ](https://docs.unity3d.com/Manual/ViewModes.html) в верхнем левом углу **представлении сцены** и выбрав **перекрытий** .

Как правило, перерисовывать можно устранить путем отбора объектов заранее, перед их отправкой в GPU. Среда Unity предоставляет сведения о реализации [визуализируемых перекрытия](https://docs.unity3d.com/Manual/OcclusionCulling.html) для их ядра.

## <a name="memory-recommendations"></a>Рекомендации по объему памяти

Операции выделения и освобождения слишком большой объем памяти, могут иметь неблагоприятное воздействие на holographic приводит к несогласованности производительности, зафиксированной кадров и других неблагоприятное поведение приложения. Это особенно важно понять рекомендации по использованию памяти, при разработке в Unity, так как управление памятью осуществляется сборщиком мусора.

#### <a name="garbage-collection"></a>Сборка мусора

Holographic приложений потеряете обработки вычислительное время, чтобы сборщик мусора (GC), когда сборщик Мусора активируется для анализа объектов, которые больше не находятся в области действия во время выполнения и их памяти должно быть запущено, поэтому его можно сделать доступным для повторного использования. Константы и отменить выделение как правило, требуют сборщик мусора более частое выполнение таким образом снижает производительность и взаимодействие с пользователем.

Unity предоставляет отличную страницу, которая подробно рассказывается о том, как работает сборщик мусора и советы по написать более эффективный код в отношении управления памятью.
- [Оптимизация сбора мусора в игр Unity](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)

Один из наиболее распространенных рекомендациям, приводит к избыточной сборки мусора выполняет кэширование ссылок на компоненты и классы в разработки Unity. Все ссылки должны перехватывать во Start() или Awake() и повторно использовать в последующих функции например Update() или LateUpdate().

Другие советы:
- Используйте [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# класс динамически создавать сложные строки во время выполнения
- Удалите вызовы Debug.Log(), когда не нужно, так как они по-прежнему выполняться во всех версиях сборки приложения
- Если holographic приложения обычно требуется большой объем памяти, рассмотрите возможность вызова [ _**System.GC.Collect()**_ ](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) во время загрузки этапов, таких как при проведении загрузки или Переход экрана

#### <a name="object-pooling"></a>Использование пулов объектов

Использование пулов объектов — популярный способ для сокращения затрат непрерывное выделение и освобождение объектов. Это делается путем выделения большого пула идентичные объекты и повторное использование экземпляров неактивных, доступные из этого пула, а не постоянно порождении и уничтожение объектов со временем. Пулы объектов отлично подходят для повторно готовый к применению компонентов, которые имеют время существования переменной во время приложения.

- [Использование пулов руководства в Unity объектов](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a>Производительность при запуске

Можно запустить приложение с меньшего размера сцены, а затем с помощью *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* загрузить остальная часть сцены. Это позволяет приложению получить в интерактивном режиме максимально возможной скоростью. Быть виду, может быть пику загрузки ЦП при активации новой сцены и может задержкам, готовый для просмотра содержимого или каких-либо помех. Один из способов обойти эту проблему — AsyncOperation.allowSceneActivation свойству задано значение false на сцене загружаемый, дождитесь сцены загрузить, Очистить экран черный и обратно задайте значение true, чтобы завершить активацию сцены.

Помните, что во время загрузки заставку на экране-заставке holographic будет отображаться для пользователя.

## <a name="see-also"></a>См. также
- [Оптимизация отрисовки графики в игр Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)
- [Оптимизация сбора мусора в игр Unity](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)
- [Рекомендации по обеспечению физики [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)
- [Оптимизация сценариев [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)
