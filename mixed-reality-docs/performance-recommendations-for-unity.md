---
title: Рекомендации по производительности для Unity
description: Советы для платформы Unity по повышению производительности приложений смешанной реальности.
author: Troy-Ferrell
ms.author: trferrel
ms.date: 03/26/2019
ms.topic: article
keywords: графика, ЦП, GPU, преобразование для просмотра, сборка мусора, hololens
ms.localizationpriority: high
ms.openlocfilehash: 18691ab7993b2802268d3c4ce05532dfa5bd1723
ms.sourcegitcommit: 9de2cb11321e6517db69e8c93459a205900a2174
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/24/2020
ms.locfileid: "80160020"
---
# <a name="performance-recommendations-for-unity"></a><span data-ttu-id="bf55e-104">Рекомендации по производительности для Unity</span><span class="sxs-lookup"><span data-stu-id="bf55e-104">Performance recommendations for Unity</span></span>

<span data-ttu-id="bf55e-105">Эта статья основана на обсуждении, начатом в [рекомендациях по производительности для смешанной реальности](understanding-performance-for-mixed-reality.md), но посвящена более узким вопросам, имеющим отношение к среде подсистемы Unity.</span><span class="sxs-lookup"><span data-stu-id="bf55e-105">This article builds on the discussion outlined in [performance recommendations for mixed reality](understanding-performance-for-mixed-reality.md) but focuses on learnings specific to the Unity engine environment.</span></span>

## <a name="use-recommended-unity-project-settings"></a><span data-ttu-id="bf55e-106">Использование рекомендуемых параметров проекта Unity</span><span class="sxs-lookup"><span data-stu-id="bf55e-106">Use recommended Unity project settings</span></span>

<span data-ttu-id="bf55e-107">Самый важный шаг при оптимизации производительности приложений смешанной реальности в Unity — использовать [рекомендуемые параметры среды для Unity](recommended-settings-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="bf55e-107">The most important first step when optimizing performance of mixed reality apps in Unity is to be sure you are using the [recommended environment settings for Unity](recommended-settings-for-unity.md).</span></span> <span data-ttu-id="bf55e-108">В этой статье содержится информация о самых важных конфигурациях сцены для создания производительных приложений смешанной реальности.</span><span class="sxs-lookup"><span data-stu-id="bf55e-108">That article contains content with some of the most important scene configurations for building performant Mixed Reality apps.</span></span> <span data-ttu-id="bf55e-109">Некоторые из этих рекомендаций отдельно выделены ниже.</span><span class="sxs-lookup"><span data-stu-id="bf55e-109">Some of these recommended settings are highlighted below, as well.</span></span>

## <a name="how-to-profile-with-unity"></a><span data-ttu-id="bf55e-110">Профилирование с помощью Unity</span><span class="sxs-lookup"><span data-stu-id="bf55e-110">How to profile with Unity</span></span>

<span data-ttu-id="bf55e-111">В Unity доступен встроенный **[профилировщик Unity](https://docs.unity3d.com/Manual/Profiler.html)** , который служит отличным инструментом для сбора ценных сведений о производительности для конкретного приложения.</span><span class="sxs-lookup"><span data-stu-id="bf55e-111">Unity provides the **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** built-in, which is a great resource to gather valuable performance insights for your particular app.</span></span> <span data-ttu-id="bf55e-112">Этот профилировщик можно запустить прямо в редакторе, но метрики не будут отражать условия в реальной среде выполнения, поэтому полученные таким образом результаты следует использовать с осторожностью.</span><span class="sxs-lookup"><span data-stu-id="bf55e-112">Although one can run the profiler in-editor, these metrics do not represent the true runtime environment and thus, results from this should be used cautiously.</span></span> <span data-ttu-id="bf55e-113">Мы рекомендуем выполнять дистанционное профилирование приложения, работающего на реальном устройстве, чтобы получить наиболее точные и применимые результаты.</span><span class="sxs-lookup"><span data-stu-id="bf55e-113">It is recommended to remotely profile your application while running on device for most accurate and actionable insights.</span></span> <span data-ttu-id="bf55e-114">Еще одним мощным и ценным инструментом для работы является отладчик [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html) в Unity.</span><span class="sxs-lookup"><span data-stu-id="bf55e-114">Further, Unity's [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html) is also a very powerful and insight tool to utilize.</span></span>

<span data-ttu-id="bf55e-115">Для Unity доступна замечательная документация по следующим темам:</span><span class="sxs-lookup"><span data-stu-id="bf55e-115">Unity provides great documentation for:</span></span>
1) <span data-ttu-id="bf55e-116">[Удаленное подключение профилировщика Unity к приложениям UWP](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span><span class="sxs-lookup"><span data-stu-id="bf55e-116">How to connect the [Unity profiler to UWP applications remotely](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span></span>
2) <span data-ttu-id="bf55e-117">[Эффективная диагностика проблем с производительностью с помощью профилировщика Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span><span class="sxs-lookup"><span data-stu-id="bf55e-117">How to effectively [diagnose performance problems with the Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span></span>

>[!NOTE]
> <span data-ttu-id="bf55e-118">Подключив профилировщик Unity и добавив профилировщик GPU с помощью действия *Add Profiler* (Добавить профилировщик) в верхнем правом углу, в средней области профилировщика вы увидите, сколько времени тратится на работу центрального и графического процессоров.</span><span class="sxs-lookup"><span data-stu-id="bf55e-118">With the Unity Profiler connected and after adding the GPU profiler (see *Add Profiler* in top right corner), one can see how much time is being spent on the CPU & GPU respectively in the middle of the profiler.</span></span> <span data-ttu-id="bf55e-119">Это позволяет разработчику быстро получить приближенные сведения о требованиях приложения к ЦП или GPU.</span><span class="sxs-lookup"><span data-stu-id="bf55e-119">This allows the developer to get a quick approximation if their application is CPU or GPU bounded.</span></span>
>
> ![ЦП и GPU в Unity](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a><span data-ttu-id="bf55e-121">Рекомендации по производительности ЦП</span><span class="sxs-lookup"><span data-stu-id="bf55e-121">CPU performance recommendations</span></span>

<span data-ttu-id="bf55e-122">Ниже приводятся более подробные рекомендации по производительности, которые особенно касаются разработки на C# в Unity.</span><span class="sxs-lookup"><span data-stu-id="bf55e-122">The content below covers more in-depth performance practices, especially targeted for Unity & C# development.</span></span>

#### <a name="cache-references"></a><span data-ttu-id="bf55e-123">Кэширование ссылок</span><span class="sxs-lookup"><span data-stu-id="bf55e-123">Cache references</span></span>

<span data-ttu-id="bf55e-124">Мы рекомендуем при инициализации кэшировать ссылки на все используемые компоненты и игровые объекты.</span><span class="sxs-lookup"><span data-stu-id="bf55e-124">It is best practice to cache references to all relevant components and GameObjects at initialization.</span></span> <span data-ttu-id="bf55e-125">Это обусловлено тем, что повторяющиеся вызовы *[GetComponentT\<T >()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* и аналогичных функций значительно дороже, чем используемая память для хранения указателя.</span><span class="sxs-lookup"><span data-stu-id="bf55e-125">This is because repeating function calls such as *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* are significantly more expensive relative to the memory cost to store a pointer.</span></span> <span data-ttu-id="bf55e-126">Это также относится к часто используемому объекту [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span><span class="sxs-lookup"><span data-stu-id="bf55e-126">This also applies to to the very regularly used [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span></span> <span data-ttu-id="bf55e-127">По сути *Camera.main* просто использует *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* для выполнения дорогостоящего поиска объекта камеры в графе сцены по тегу *MainCamera*.</span><span class="sxs-lookup"><span data-stu-id="bf55e-127">*Camera.main* actually just uses *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* underneath, which expensively searches your scene graph for a camera object with the *"MainCamera"* tag.</span></span>

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] 
> <span data-ttu-id="bf55e-128">Отказ от использования GetComponent(string)</span><span class="sxs-lookup"><span data-stu-id="bf55e-128">Avoid GetComponent(string)</span></span> <br/>
> <span data-ttu-id="bf55e-129">При использовании *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* существует несколько разных перегрузок.</span><span class="sxs-lookup"><span data-stu-id="bf55e-129">When using *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)*, there are a handful of different overloads.</span></span> <span data-ttu-id="bf55e-130">Важно всегда использовать реализации на основе конкретных типов, но не перегрузку поиска на основе строк.</span><span class="sxs-lookup"><span data-stu-id="bf55e-130">It is important to always use the Type-based implementations and never the string-based searching overload.</span></span> <span data-ttu-id="bf55e-131">Поиск по строке в сцене значительно дороже, чем поиск по типу.</span><span class="sxs-lookup"><span data-stu-id="bf55e-131">Searching by string in your scene is significantly more costly than searching by Type.</span></span> <br/>
> <span data-ttu-id="bf55e-132">(Хорошо) Component GetComponent(Type type)</span><span class="sxs-lookup"><span data-stu-id="bf55e-132">(Good) Component GetComponent(Type type)</span></span> <br/>
> <span data-ttu-id="bf55e-133">(Хорошо) T GetComponent\<T>()</span><span class="sxs-lookup"><span data-stu-id="bf55e-133">(Good) T GetComponent\<T>()</span></span> <br/>
> <span data-ttu-id="bf55e-134">(Плохо) Component GetComponent(string)</span><span class="sxs-lookup"><span data-stu-id="bf55e-134">(Bad) Component GetComponent(string)></span></span> <br/>

#### <a name="avoid-expensive-operations"></a><span data-ttu-id="bf55e-135">Отказ от дорогостоящих операций</span><span class="sxs-lookup"><span data-stu-id="bf55e-135">Avoid expensive operations</span></span>

1) <span data-ttu-id="bf55e-136">**Отказ от использования [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span><span class="sxs-lookup"><span data-stu-id="bf55e-136">**Avoid use of [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span></span>

    <span data-ttu-id="bf55e-137">Благодаря чистоте код LINQ проще читать и писать, но он требует гораздо больше вычислительных ресурсов и особенно выделенной памяти, чем написанный вручную алгоритм.</span><span class="sxs-lookup"><span data-stu-id="bf55e-137">Although LINQ can be very clean and easy to read and write, it generally requires much more computation and particularly more memory allocation than writing the algorithm out manually.</span></span>

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) <span data-ttu-id="bf55e-138">**Распространенные API Unity**</span><span class="sxs-lookup"><span data-stu-id="bf55e-138">**Common Unity APIs**</span></span>

    <span data-ttu-id="bf55e-139">Некоторые API Unity при всей очевидной пользе могут быть очень ресурсоемкими.</span><span class="sxs-lookup"><span data-stu-id="bf55e-139">Certain Unity APIs, although useful, can be very expensive to execute.</span></span> <span data-ttu-id="bf55e-140">Большинство из них выполняют поиск соответствующих игровых объектов по всему графу сцены.</span><span class="sxs-lookup"><span data-stu-id="bf55e-140">Most of these involve searching your entire scene graph for some matching list of GameObjects.</span></span> <span data-ttu-id="bf55e-141">Обычно этих операций можно избежать, кэшируя ссылки или создав компонент управления нужными игровыми объектами для отслеживания ссылок во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="bf55e-141">These operations can generally be avoided by caching references or implementing a manager component for the GameObjects in question to track the references at runtime.</span></span>

        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()

>[!NOTE]
> <span data-ttu-id="bf55e-142">Удалите все *[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* и *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* любой ценой.</span><span class="sxs-lookup"><span data-stu-id="bf55e-142">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* and *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* should be eliminated at all costs.</span></span> <span data-ttu-id="bf55e-143">Эти функции работают на три порядка медленнее, чем прямые вызовы функций.</span><span class="sxs-lookup"><span data-stu-id="bf55e-143">These functions can be on the order of 1000x slower than direct function calls.</span></span>

3) <span data-ttu-id="bf55e-144">**Остерегайтесь упаковки-преобразования**</span><span class="sxs-lookup"><span data-stu-id="bf55e-144">**Beware of boxing**</span></span>

    <span data-ttu-id="bf55e-145">Концепция [упаковки-преобразования](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) очень важна в языке и среде выполнения C#.</span><span class="sxs-lookup"><span data-stu-id="bf55e-145">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) is a core concept of the C# language and runtime.</span></span> <span data-ttu-id="bf55e-146">Так называют процесс создания переменных со ссылочным типом в виде оболочек для переменных со значениями типа, такими как char, int, bool и т. д.</span><span class="sxs-lookup"><span data-stu-id="bf55e-146">It is the process of wrapping value-typed variables such as char, int, bool, etc. into reference-typed variables.</span></span> <span data-ttu-id="bf55e-147">Если переменная со значением типа "упакована", она помещается в объект System.Object, который хранится в управляемой куче.</span><span class="sxs-lookup"><span data-stu-id="bf55e-147">When a value-typed variable is "boxed", it is wrapped inside of a System.Object which is stored on the managed heap.</span></span> <span data-ttu-id="bf55e-148">Это означает, что для нее выделяется память и ее нужно обрабатывать сборщиком мусора после освобождения.</span><span class="sxs-lookup"><span data-stu-id="bf55e-148">Thus, memory is allocated and eventually when disposed must be processed by the garbage collector.</span></span> <span data-ttu-id="bf55e-149">Такие процессы выделения и освобождения ресурсов приводят к снижению производительности, а во многих случаях их можно убрать или легко заменить на менее дорогостоящую альтернативу.</span><span class="sxs-lookup"><span data-stu-id="bf55e-149">These allocations and deallocations incur a performance cost and in many scenarios are unnecessary or can be easily replaced by a less expensive alternative.</span></span>

    <span data-ttu-id="bf55e-150">Одной из наиболее распространенных форм упаковки-преобразования является использование [типов значений, допускающих значение NULL](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/).</span><span class="sxs-lookup"><span data-stu-id="bf55e-150">One of the most common forms of boxing in development is the use of [nullable value types](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/).</span></span> <span data-ttu-id="bf55e-151">Часто вам нужно, чтобы функция могла возвращать значение NULL для типа значения, особенно если операция не всегда может получить нужное значение.</span><span class="sxs-lookup"><span data-stu-id="bf55e-151">It is common to want to be able to return null for a value type in a function, especially when the operation may fail trying to get the value.</span></span> <span data-ttu-id="bf55e-152">Потенциальная проблема этого подхода заключается в том, что выделение памяти выполняется из кучи и должно затем обрабатываться сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="bf55e-152">The potential problem with this approach is that allocation now occurs on the heap and consequently needs to be garbage collected later.</span></span>

    <span data-ttu-id="bf55e-153">**Пример упаковки-преобразования в C#**</span><span class="sxs-lookup"><span data-stu-id="bf55e-153">**Example of boxing in C#**</span></span>

    ```csharp
    // boolean value type is boxed into object boxedMyVar on the heap
    bool myVar = true;
    object boxedMyVar = myVar;
    ```

    <span data-ttu-id="bf55e-154">**Пример проблемной упаковки-преобразования в типы значений, допускающие значения NULL**</span><span class="sxs-lookup"><span data-stu-id="bf55e-154">**Example of problematic boxing via nullable value types**</span></span>

    <span data-ttu-id="bf55e-155">В этом коде демонстрируется фиктивный класс частиц, который можно создать в проекте Unity.</span><span class="sxs-lookup"><span data-stu-id="bf55e-155">This code demonstrates a dummy particle class that one may create in a Unity project.</span></span> <span data-ttu-id="bf55e-156">Вызов `TryGetSpeed()` приведет к выделению объекта из кучи, которое позднее придется обработать сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="bf55e-156">A call to `TryGetSpeed()` will cause object allocation on the heap which will need to be garbage collected at a later point in time.</span></span> <span data-ttu-id="bf55e-157">Этот пример особенно проблематичен, так как в сцене может быть несколько тысяч частиц, каждая из которых опрашивается для получения их текущей скорости.</span><span class="sxs-lookup"><span data-stu-id="bf55e-157">This example is particularly problematic as there may be 1000+ or many more particles in a scene, each being asked for their current speed.</span></span> <span data-ttu-id="bf55e-158">Это означает, что придется выделить и впоследствии освободить несколько тысяч объектов для каждого кадра, что значительно снизит производительность.</span><span class="sxs-lookup"><span data-stu-id="bf55e-158">Thus, 1000's of objects would be allocated and consequently de-allocated every frame, which would greatly diminish performance.</span></span> <span data-ttu-id="bf55e-159">Переписав эту функцию так, чтобы в случае ошибки она возвращала отрицательное значение (например, –1), мы сможем избежать этой проблемы и сохранить выделение памяти из стека.</span><span class="sxs-lookup"><span data-stu-id="bf55e-159">Re-writing the function to return a negative value such as -1 to indicate a failure would avoid this issue and keep memory on the stack.</span></span>

    ```csharp
        public class MyParticle
        {
            // Example of function returning nullable value type
            public int? TryGetSpeed()
            {
                // Returns current speed int value or null if fails
            }
        }
    ```

#### <a name="repeating-code-paths"></a><span data-ttu-id="bf55e-160">Повторяющиеся пути кода</span><span class="sxs-lookup"><span data-stu-id="bf55e-160">Repeating code paths</span></span>

<span data-ttu-id="bf55e-161">Любые повторяющиеся функции обратного вызова в Unity (например,</span><span class="sxs-lookup"><span data-stu-id="bf55e-161">Any repeating Unity callback functions (i.e</span></span> <span data-ttu-id="bf55e-162">Update), которые выполняются много раз каждую секунду и (или) для каждого кадра, следует обдумывать очень тщательно.</span><span class="sxs-lookup"><span data-stu-id="bf55e-162">Update) that are executed many times per second and/or frame should be written very carefully.</span></span> <span data-ttu-id="bf55e-163">Любые дорогостоящие операции в этом коде будут иметь огромное и стабильное влияние на производительность.</span><span class="sxs-lookup"><span data-stu-id="bf55e-163">Any expensive operations here will have huge and consistent impact on performance.</span></span>

1) <span data-ttu-id="bf55e-164">**Пустые функции обратного вызова**</span><span class="sxs-lookup"><span data-stu-id="bf55e-164">**Empty callback functions**</span></span>

    <span data-ttu-id="bf55e-165">Несмотря на внешнюю безобидность приведенного ниже кода, эти пустые обратные вызовы могут быть очень ресурсоемкими, особенно учитывая, что каждый скрипт Unity выполняет автоматическую инициализацию с помощью этого блока кода.</span><span class="sxs-lookup"><span data-stu-id="bf55e-165">Although the code below may seem innocent to leave in your application, especially since every Unity script auto-initializes with this code block, these empty callbacks can actually become very expensive.</span></span> <span data-ttu-id="bf55e-166">Unity придется постоянно переключаться между неуправляемой и управляемой частью кода, то есть между кодом UnityEngine и кодом приложения.</span><span class="sxs-lookup"><span data-stu-id="bf55e-166">Unity operates back and forth over an unmanaged/managed code boundary, between UnityEngine code and your application code.</span></span> <span data-ttu-id="bf55e-167">Такое переключение контекста на этой границе требует много ресурсов, даже если не выполняется никаких действий.</span><span class="sxs-lookup"><span data-stu-id="bf55e-167">Context switching over this bridge is fairly expensive, even if there is nothing to execute.</span></span> <span data-ttu-id="bf55e-168">Это особенно проблематично, если приложение использует сотни игровых объектов, компоненты которых имеют повторяющиеся пустые обратные вызовы Unity.</span><span class="sxs-lookup"><span data-stu-id="bf55e-168">This becomes especially problematic if your app has 100's of GameObjects with components that have empty repeating Unity callbacks.</span></span>

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> <span data-ttu-id="bf55e-169">Update() служит самым ярким примером этой проблемы с производительностью, но некоторые другие повторяющиеся обратные вызовы Unity могут оказаться не менее или даже более серьезными, как например следующие: FixedUpdate(), LateUpdate(), OnPostRender(), OnPreRender(), OnRenderImage() и т. п.</span><span class="sxs-lookup"><span data-stu-id="bf55e-169">Update() is the most common manifestation of this performance issue but other repeating Unity callbacks, such as the following can be equally as bad, if not worse: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span></span> 

2) <span data-ttu-id="bf55e-170">**Однократное выполнение операций для каждого кадра**</span><span class="sxs-lookup"><span data-stu-id="bf55e-170">**Operations to favor running once per frame**</span></span>

    <span data-ttu-id="bf55e-171">Следующие API Unity содержат операции, типичные для многих голографических приложений.</span><span class="sxs-lookup"><span data-stu-id="bf55e-171">The following Unity APIs are common operations for many Holographic Apps.</span></span> <span data-ttu-id="bf55e-172">Хотя и не всегда, результаты таких функций часто можно вычислять один раз за кадр и повторно использовать в приложении для всего этого кадра.</span><span class="sxs-lookup"><span data-stu-id="bf55e-172">Although not always possible, the results from these functions can very commonly be computed once and the results re-utilized across the application for a given frame.</span></span>

    <span data-ttu-id="bf55e-173">а) Как общее правило, мы рекомендуем выделить один класс или службу Singleton, чтобы обработать Raycast для взгляда на сцену и повторно использовать полученный результат во всех остальных компонентах сцены, не повторяя по сути идентичные операции Raycast для каждого компонента.</span><span class="sxs-lookup"><span data-stu-id="bf55e-173">a) Generally it is good practice to have a dedicated Singleton class or service to handle your gaze Raycast into the scene and then re-use this result in all other scene components, instead of making repeated and essentially identical Raycast operations by each component.</span></span> <span data-ttu-id="bf55e-174">Разумеется, в некоторых приложениях нужно выполнять Raycast из разных позиций или с разными [LayerMask](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span><span class="sxs-lookup"><span data-stu-id="bf55e-174">Of course, some applications may require raycasts from different origins or against different [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span></span>

        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()

    <span data-ttu-id="bf55e-175">б) Избегайте операций с методом GetComponent() в повторяющихся обратных вызовах Unity, таких как Update(), используя [кэширование ссылок](#cache-references) в Start () или Awake().</span><span class="sxs-lookup"><span data-stu-id="bf55e-175">b) Avoid GetComponent() operations in repeated Unity callbacks like Update() by [caching references](#cache-references) in Start() or Awake()</span></span>

        UnityEngine.Object.GetComponent()

    <span data-ttu-id="bf55e-176">в) Мы рекомендуем по возможности создавать экземпляры всех объектов при инициализации и применять [пулы объектов](#object-pooling) для повторного использования игровых объектов на протяжении всей работы приложения.</span><span class="sxs-lookup"><span data-stu-id="bf55e-176">c) It is good practice to instantiate all objects, if possible, at initialization and use [object pooling](#object-pooling) to recycle and re-use GameObjects throughout runtime of your application</span></span>

        UnityEngine.Object.Instantiate()

3) <span data-ttu-id="bf55e-177">**Отказ от использования интерфейсов и виртуальных конструкций**</span><span class="sxs-lookup"><span data-stu-id="bf55e-177">**Avoid interfaces and virtual constructs**</span></span>

    <span data-ttu-id="bf55e-178">Вызов функций через интерфейсы вместо прямого обращения к объектам либо вызов виртуальных функций часто будет гораздо более затратным, чем использование прямых конструкций или прямых вызовов функций.</span><span class="sxs-lookup"><span data-stu-id="bf55e-178">Invoking function calls through interfaces vs direct objects or calling virtual functions can often times be much more expensive than utilizing direct constructs or direct function calls.</span></span> <span data-ttu-id="bf55e-179">Если виртуальная функция или интерфейс являются необязательными, их следует удалить.</span><span class="sxs-lookup"><span data-stu-id="bf55e-179">If the virtual function or interface is unnecessary, then it should be removed.</span></span> <span data-ttu-id="bf55e-180">Однако для этих подходов ухудшение производительности часто будет хорошим компромиссом, если их применение упрощает совместную работу, повышает удобочитаемость или удобство поддержки кода.</span><span class="sxs-lookup"><span data-stu-id="bf55e-180">However, the performance hit for these approaches are generally worth the trade-off if utilizing them simplifies development collaboration, code readability, and code maintainability.</span></span>

    <span data-ttu-id="bf55e-181">В общем случае мы рекомендуем не объявлять поля и функции виртуальными, если нет четкого понимания, что этот элемент придется перезаписывать.</span><span class="sxs-lookup"><span data-stu-id="bf55e-181">Generally, the recommendation is to not mark fields and functions as virtual unless there is a clear expectation that this member needs to be overwritten.</span></span> <span data-ttu-id="bf55e-182">Разработчикам нужно быть особенно осторожными в путях кода с высокой частотой исполнения, то есть вызываемых один и более раз для каждого кадра, таких как метод `UpdateUI()`.</span><span class="sxs-lookup"><span data-stu-id="bf55e-182">One should be especially careful around high-frequency code paths that are called many times per frame or even once per frame such as an `UpdateUI()` method.</span></span>

4) <span data-ttu-id="bf55e-183">**Отказ от передачи структур по значению**</span><span class="sxs-lookup"><span data-stu-id="bf55e-183">**Avoid passing structs by value**</span></span>

    <span data-ttu-id="bf55e-184">В отличие от классов, для структуры типы определяются значением, и при прямой передаче в функцию их содержимое копируется в только что созданный экземпляр.</span><span class="sxs-lookup"><span data-stu-id="bf55e-184">Unlike classes, structs are value-types and when passed directly to a function, their contents are copied into a newly created instance.</span></span> <span data-ttu-id="bf55e-185">Эта копия повышает нагрузку на ЦП и требует дополнительной памяти из стека.</span><span class="sxs-lookup"><span data-stu-id="bf55e-185">This copy adds CPU cost, as well as additional memory on the stack.</span></span> <span data-ttu-id="bf55e-186">Влияние небольших структур обычно минимально и может считаться приемлемым.</span><span class="sxs-lookup"><span data-stu-id="bf55e-186">For small structs, the effect is usually very minimal and thus acceptable.</span></span> <span data-ttu-id="bf55e-187">Но для тех функций, которые несколько раз вызываются для каждого кадра и (или) принимают крупные структуры, по возможности измените определение функции так, чтобы передавать им ссылку.</span><span class="sxs-lookup"><span data-stu-id="bf55e-187">However, for functions repeatedly invoked every frame as well as functions taking large structs, if possible modify the function definition to pass by reference.</span></span> [<span data-ttu-id="bf55e-188">Дополнительные сведения см. здесь</span><span class="sxs-lookup"><span data-stu-id="bf55e-188">Learn more here</span></span>](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a><span data-ttu-id="bf55e-189">Прочее</span><span class="sxs-lookup"><span data-stu-id="bf55e-189">Miscellaneous</span></span>

1) <span data-ttu-id="bf55e-190">**Физика**</span><span class="sxs-lookup"><span data-stu-id="bf55e-190">**Physics**</span></span>

    <span data-ttu-id="bf55e-191">а) Как правило, для улучшения обработки физики следует ограничить количество времени или количество итераций в секунду, затрачиваемых на ее обработку.</span><span class="sxs-lookup"><span data-stu-id="bf55e-191">a) Generally, the easiest way to improve physics is to limit the amount of time spent on Physics or the number of iterations per second.</span></span> <span data-ttu-id="bf55e-192">Разумеется, это снизит точность имитации.</span><span class="sxs-lookup"><span data-stu-id="bf55e-192">Of course, this will reduce simulation accuracy.</span></span> <span data-ttu-id="bf55e-193">См. документацию по [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) в Unity.</span><span class="sxs-lookup"><span data-stu-id="bf55e-193">See [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span></span>

    <span data-ttu-id="bf55e-194">б) Тип коллайдера в Unity может иметь очень разные характеристики производительности.</span><span class="sxs-lookup"><span data-stu-id="bf55e-194">b) The type of colliders in Unity have widely different performance characteristics.</span></span> <span data-ttu-id="bf55e-195">В приведенном ниже списке коллайдеры перечислены в порядке уменьшения производительности, слева направо.</span><span class="sxs-lookup"><span data-stu-id="bf55e-195">The order below lists the most performant colliders to least performant colliders from left to right.</span></span> <span data-ttu-id="bf55e-196">Важнее всего избегать коллайдеров сетки, которые значительно дороже коллайдеров примитивов.</span><span class="sxs-lookup"><span data-stu-id="bf55e-196">It is most important to avoid Mesh Colliders, which are substantially more expensive than the primitive colliders.</span></span>

        Sphere < Capsule < Box <<< Mesh (Convex) < Mesh (non-Convex)

    <span data-ttu-id="bf55e-197">Дополнительные сведения см. в статье [с рекомендациями по обработке физики в Unity](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices).</span><span class="sxs-lookup"><span data-stu-id="bf55e-197">See [Unity Physics Best Practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) for more info</span></span>

2) <span data-ttu-id="bf55e-198">**Анимации**</span><span class="sxs-lookup"><span data-stu-id="bf55e-198">**Animations**</span></span>

    <span data-ttu-id="bf55e-199">Избавьтесь от анимации простоя, отключив компонент Animator (отключение объекта Game не дает такого эффекта).</span><span class="sxs-lookup"><span data-stu-id="bf55e-199">Disable idle animations by disabling the Animator component (disabling the game object won't have the same effect).</span></span> <span data-ttu-id="bf55e-200">Избегайте шаблонов разработки, в которых аниматор в цикле постоянно присваивает значение одному параметру.</span><span class="sxs-lookup"><span data-stu-id="bf55e-200">Avoid design patterns where an animator sits in a loop setting a value to the same thing.</span></span> <span data-ttu-id="bf55e-201">Такая техника влечет значительные издержки без видимого эффекта в приложении.</span><span class="sxs-lookup"><span data-stu-id="bf55e-201">There is considerable overhead for this technique, with no effect on the application.</span></span> [<span data-ttu-id="bf55e-202">Дополнительные сведения доступны здесь.</span><span class="sxs-lookup"><span data-stu-id="bf55e-202">Learn more here.</span></span>](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) <span data-ttu-id="bf55e-203">**Сложные алгоритмы**</span><span class="sxs-lookup"><span data-stu-id="bf55e-203">**Complex algorithms**</span></span>

    <span data-ttu-id="bf55e-204">Если приложение использует сложные алгоритмы, такие как обратная кинематика, поиск пути и т. д., попробуйте найти более простой подход или оптимизируйте соответствующие параметры по производительности.</span><span class="sxs-lookup"><span data-stu-id="bf55e-204">If your application is using complex algorithms such as inverse kinematics, path finding, etc, look to find a simpler approach or adjust relevant settings for their performance</span></span>

## <a name="cpu-to-gpu-performance-recommendations"></a><span data-ttu-id="bf55e-205">Рекомендации по производительности взаимодействия ЦП с GPU</span><span class="sxs-lookup"><span data-stu-id="bf55e-205">CPU-to-GPU performance recommendations</span></span>

<span data-ttu-id="bf55e-206">Как правило, производительность взаимодействия ЦП с GPU упирается в **вызовы отрисовки**, передаваемые на графическую плату.</span><span class="sxs-lookup"><span data-stu-id="bf55e-206">Generally, CPU-to-GPU performance comes down to the **draw calls** submitted to the graphics card.</span></span> <span data-ttu-id="bf55e-207">Чтобы повысить эту производительность, вызовы отрисовки следует стратегически **уменьшать** и (или) **реструктуризовать** до достижения оптимальных результатов.</span><span class="sxs-lookup"><span data-stu-id="bf55e-207">To improve performance, draw calls need to be strategically **a) reduced** or **b) restructured** for optimal results.</span></span> <span data-ttu-id="bf55e-208">Поскольку вызовы отрисовки сами по себе требуют много ресурсов, снижение их количества позволит сократить общий объем работы.</span><span class="sxs-lookup"><span data-stu-id="bf55e-208">Since draw calls themselves are resource-intensive, reducing them will reduce overall work required.</span></span> <span data-ttu-id="bf55e-209">Кроме того, изменения состояния между вызовами отрисовки требуют дорогостоящих операций по проверке и переводу в графическом драйвере, а значит реструктуризация вызовов отрисовки в приложении для ограничения изменений состояния (т. е.</span><span class="sxs-lookup"><span data-stu-id="bf55e-209">Further, state changes between draw calls requires costly validation and translation steps in the graphics driver and thus, restructuring of your application's draw calls to limit state changes (i.e</span></span> <span data-ttu-id="bf55e-210">разных материалов и т. д.) может повысить производительность.</span><span class="sxs-lookup"><span data-stu-id="bf55e-210">different materials, etc) can boost performance.</span></span>

<span data-ttu-id="bf55e-211">В документации по Unity есть отличная статья с обзорным и подробным описанием пакетной обработки вызовов на этой платформе.</span><span class="sxs-lookup"><span data-stu-id="bf55e-211">Unity has a great article that gives an overview and dives into batching draw calls for their platform.</span></span>
- [<span data-ttu-id="bf55e-212">Пакетная обработка вызовов отрисовки в Unity</span><span class="sxs-lookup"><span data-stu-id="bf55e-212">Unity Draw Call Batching</span></span>](https://docs.unity3d.com/Manual/DrawCallBatching.html)

#### <a name="single-pass-instanced-rendering"></a><span data-ttu-id="bf55e-213">Однопроходная отрисовка экземпляра</span><span class="sxs-lookup"><span data-stu-id="bf55e-213">Single pass instanced rendering</span></span>

<span data-ttu-id="bf55e-214">Однопроходная отрисовка экземпляра в Unity позволяет уменьшить число вызовов отрисовки для каждого глаза до одного экземпляра.</span><span class="sxs-lookup"><span data-stu-id="bf55e-214">Single Pass Instanced Rendering in Unity allows for draw calls for each eye to be reduced down to one instanced draw call.</span></span> <span data-ttu-id="bf55e-215">Благодаря согласованности кэша между двумя вызовами отрисовки будет заметно и некоторое улучшение производительности GPU.</span><span class="sxs-lookup"><span data-stu-id="bf55e-215">Due to cache coherency between two draw calls, there is also some performance improvement on the GPU as well.</span></span>

<span data-ttu-id="bf55e-216">Включение этой функции в проекте Unity</span><span class="sxs-lookup"><span data-stu-id="bf55e-216">To enable this feature in your Unity Project</span></span>
1)  <span data-ttu-id="bf55e-217">Откройте **Player XR Settings** (Параметры XR проигрывателя), выбрав элементы **Edit** > **Project Settings** > **Player** > **XR Settings** (Редактирование > Параметры проекта > Проигрыватель > Параметры XR)</span><span class="sxs-lookup"><span data-stu-id="bf55e-217">Open **Player XR Settings** (go to **Edit** > **Project Settings** > **Player** > **XR Settings**)</span></span>
2) <span data-ttu-id="bf55e-218">Выберите **Single Pass Instanced** (Однопроходный с экземпляром) в раскрывающемся меню **Stereo Rendering Method** (Метод стереоскопической отрисовки), установив также флажок **Virtual Reality Supported** (Поддержка виртуальной реальности)</span><span class="sxs-lookup"><span data-stu-id="bf55e-218">Select **Single Pass Instanced** from the **Stereo Rendering Method** drop-down menu (**Virtual Reality Supported** checkbox must be checked)</span></span>

<span data-ttu-id="bf55e-219">Ознакомьтесь со следующими статьями Unity, чтобы получить подробные сведения об этом подходе к отрисовке.</span><span class="sxs-lookup"><span data-stu-id="bf55e-219">Read the following articles from Unity for details with this rendering approach.</span></span>
- [<span data-ttu-id="bf55e-220">Максимизация производительности дополненной реальности и виртуальной реальности с помощью расширенной стереоскопической отрисовки</span><span class="sxs-lookup"><span data-stu-id="bf55e-220">How to maximize AR and VR performance with advanced stereo rendering</span></span>](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)
- [<span data-ttu-id="bf55e-221">Однопроходная отрисовка экземпляра</span><span class="sxs-lookup"><span data-stu-id="bf55e-221">Single Pass Instancing</span></span>](https://docs.unity3d.com/Manual/SinglePassInstancing.html) 

>[!NOTE]
> <span data-ttu-id="bf55e-222">Одна из распространенных проблем при однопроходной отрисовке с использованием экземпляра возникает в тех случаях, если уже существующие пользовательские шейдеры не поддерживают создание экземпляра.</span><span class="sxs-lookup"><span data-stu-id="bf55e-222">One common issue with Single Pass Instanced Rendering occurs if developers already have existing custom shaders not written for instancing.</span></span> <span data-ttu-id="bf55e-223">После включения этой возможности разработчики заметят, что некоторые игровые объекты отрисовываются только для одного глаза.</span><span class="sxs-lookup"><span data-stu-id="bf55e-223">After enabling this feature, developers may notice some GameObjects only render in one eye.</span></span> <span data-ttu-id="bf55e-224">Это связано с тем, что соответствующие пользовательские шейдеры не имеют нужных свойств для создания экземпляров.</span><span class="sxs-lookup"><span data-stu-id="bf55e-224">This is because the associated custom shaders do not have the appropriate properties for instancing.</span></span>
>
> <span data-ttu-id="bf55e-225">Действия для решения этой проблемы описаны в документе Unity [об однопроходной стереоскопической отрисовке для HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html).</span><span class="sxs-lookup"><span data-stu-id="bf55e-225">See [Single Pass Stereo Rendering for HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) from Unity for how to address this problem</span></span>

#### <a name="static-batching"></a><span data-ttu-id="bf55e-226">Пакетная обработка статических объектов</span><span class="sxs-lookup"><span data-stu-id="bf55e-226">Static batching</span></span>

<span data-ttu-id="bf55e-227">Unity поддерживает создание пакетов из нескольких статических объектов, что позволяет снизить число вызовов отрисовки для GPU.</span><span class="sxs-lookup"><span data-stu-id="bf55e-227">Unity is able to batch many static objects to reduce draw calls to the GPU.</span></span> <span data-ttu-id="bf55e-228">Пакетная обработка статических объектов будет нормально работать в Unity для большинства объектов [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html), которые **имеют одинаковый материал** и **имеют атрибут *Static*** (чтобы присвоить его, выберите объект в Unity и щелкните флажок в верхней правой части окна инспектора).</span><span class="sxs-lookup"><span data-stu-id="bf55e-228">Static Batching works for most [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) objects in Unity that **1) share the same material** and **2) are all marked as *Static*** (Select an object in Unity and click the checkbox in the top right of the inspector).</span></span> <span data-ttu-id="bf55e-229">Игровые объекты, имеющие атрибут *Static*, не могут перемещаться на протяжении всего периода работы приложения.</span><span class="sxs-lookup"><span data-stu-id="bf55e-229">GameObjects marked as *Static* cannot be moved throughout your application's runtime.</span></span> <span data-ttu-id="bf55e-230">Это означает, что пакетную обработку статических объектов трудно применить для HoloLens, поскольку здесь почти каждый объект должен быть перемещаемым, масштабируемым и т. д. Для иммерсивных гарнитур пакетная обработка статических объектов позволяет значительно сократить число вызовов отрисовки, а значит и повысить производительность.</span><span class="sxs-lookup"><span data-stu-id="bf55e-230">Thus, static batching can be difficult to leverage on HoloLens where virtually every object needs to be placed, moved, scaled, etc. For immersive headsets, static batching can dramatically reduce draw calls and thus improve performance.</span></span>

<span data-ttu-id="bf55e-231">Дополнительные сведения см. в разделе *о пакетной обработке статических объектов* в статье [Пакетная обработка вызовов отрисовки в Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html).</span><span class="sxs-lookup"><span data-stu-id="bf55e-231">Read *Static Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for more details.</span></span>

#### <a name="dynamic-batching"></a><span data-ttu-id="bf55e-232">Пакетная обработка динамических объектов</span><span class="sxs-lookup"><span data-stu-id="bf55e-232">Dynamic batching</span></span>

<span data-ttu-id="bf55e-233">Поскольку при разработке для HoloLens будет затруднительно объявлять объекты *статическими*, компенсировать этот недостаток можно применением пакетной обработки динамических объектов.</span><span class="sxs-lookup"><span data-stu-id="bf55e-233">Since it is problematic to mark objects as *Static* for HoloLens development, dynamic batching can be a great tool to compensate for this lacking feature.</span></span> <span data-ttu-id="bf55e-234">Конечно же, это будет работать и для иммерсивных гарнитур.</span><span class="sxs-lookup"><span data-stu-id="bf55e-234">Of course, it can also be useful on immersive headsets, as well.</span></span> <span data-ttu-id="bf55e-235">Однако пакетная обработка динамических объектов в Unity может быть сложной, поскольку игровые объекты должны иметь **одинаковые материалы** и **соответствовать множеству других критериев**.</span><span class="sxs-lookup"><span data-stu-id="bf55e-235">However, dynamic batching in Unity can be difficult to enable because GameObjects must **a) share the same Material** and **b) meet a long list of other criteria**.</span></span>

<span data-ttu-id="bf55e-236">Полный список этих требований см. в разделе *о пакетной обработке динамических объектов* в статье [Пакетная обработка вызовов отрисовки в Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html).</span><span class="sxs-lookup"><span data-stu-id="bf55e-236">Read *Dynamic Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for the full list.</span></span> <span data-ttu-id="bf55e-237">Чаще всего игровые объекты не удается объединить в пакет, поскольку для такой обработки данные о сетке не могут содержать более 300 вершин.</span><span class="sxs-lookup"><span data-stu-id="bf55e-237">Most commonly, GameObjects become invalid to be batched dynamically, because the associated mesh data can be no more than 300 vertices.</span></span>

#### <a name="other-techniques"></a><span data-ttu-id="bf55e-238">Другие методики</span><span class="sxs-lookup"><span data-stu-id="bf55e-238">Other techniques</span></span>

<span data-ttu-id="bf55e-239">Пакетная обработка возможна только в том случае, если несколько игровых объектов имеют один и тот же материал.</span><span class="sxs-lookup"><span data-stu-id="bf55e-239">Batching can only occur if multiple GameObjects are able to share the same material.</span></span> <span data-ttu-id="bf55e-240">Обычно это невозможно из-за того, что для каждого игрового объекта нужна уникальная текстура соответствующего материала.</span><span class="sxs-lookup"><span data-stu-id="bf55e-240">Typically, this will be blocked by the need for GameObjects to have a unique texture for their respective Material.</span></span> <span data-ttu-id="bf55e-241">Существует метод [текстурного атласа](https://en.wikipedia.org/wiki/Texture_atlas), в котором несколько текстур объединяются в одну большую текстуру.</span><span class="sxs-lookup"><span data-stu-id="bf55e-241">It is common to combine Textures into one big Texture, a method known as [Texture Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span></span>

<span data-ttu-id="bf55e-242">Более того, во всех случаях, где это возможно и оправдано, лучше объединять несколько сеток в один игровой объект.</span><span class="sxs-lookup"><span data-stu-id="bf55e-242">Furthermore, it is generally preferable to combine meshes into one GameObject where possible and reasonable.</span></span> <span data-ttu-id="bf55e-243">Каждый отрисовщик в Unity будет использовать собственные вызовы отрисовки, и этого можно избежать при одном отрисовщике для объединенной сетки.</span><span class="sxs-lookup"><span data-stu-id="bf55e-243">Each Renderer in Unity will have its associated draw call(s) versus submitting a combined mesh under one Renderer.</span></span>

>[!NOTE]
> <span data-ttu-id="bf55e-244">Изменение свойств в Renderer.material во время выполнения приводит к созданию копии материала, что может нарушить возможность пакетной обработки.</span><span class="sxs-lookup"><span data-stu-id="bf55e-244">Modifying properties of Renderer.material at runtime will create a copy of the Material and thus potentially break batching.</span></span> <span data-ttu-id="bf55e-245">Используйте Renderer.sharedMaterial для изменения свойств общего материала для нескольких игровых объектов.</span><span class="sxs-lookup"><span data-stu-id="bf55e-245">Use Renderer.sharedMaterial to modify shared material properties across GameObjects.</span></span>

## <a name="gpu-performance-recommendations"></a><span data-ttu-id="bf55e-246">Рекомендации по производительности GPU</span><span class="sxs-lookup"><span data-stu-id="bf55e-246">GPU performance recommendations</span></span>

<span data-ttu-id="bf55e-247">Дополнительные сведения об оптимизации отрисовки графических объектов в Unity см. [здесь](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games).</span><span class="sxs-lookup"><span data-stu-id="bf55e-247">Learn more about [optimizing graphics rendering in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span></span>

### <a name="optimize-depth-buffer-sharing"></a><span data-ttu-id="bf55e-248">Оптимизация совместного использования буфера глубины</span><span class="sxs-lookup"><span data-stu-id="bf55e-248">Optimize depth buffer sharing</span></span>

<span data-ttu-id="bf55e-249">Обычно лучше включить параметр **Depth buffer sharing** (Совместное использование буфера глубины) в разделе **Player XR Settings** (Параметры XR проигрывателя) для повышения [стабильности голограммы](Hologram-stability.md).</span><span class="sxs-lookup"><span data-stu-id="bf55e-249">It is generally recommended to enable **Depth buffer sharing** under **Player XR Settings** to optimize for [hologram stability](Hologram-stability.md).</span></span> <span data-ttu-id="bf55e-250">Но при включении повторного проецирования на поздней стадии на основе глубины, если задан этот параметр, мы рекомендуем выбрать **16-разрядный формат глубины**, а не **24-разрядный**.</span><span class="sxs-lookup"><span data-stu-id="bf55e-250">When enabling depth-based late-stage reprojection with this setting however, it is recommended to select **16-bit depth format** instead of **24-bit depth format**.</span></span> <span data-ttu-id="bf55e-251">16-разрядные буферы глубины существенно снизят нагрузку на пропускную способность (передачу данных) для буфера глубины, а значит и энергопотребление.</span><span class="sxs-lookup"><span data-stu-id="bf55e-251">The 16-bit depth buffers will drastically reduce the bandwidth (and thus power) associated with depth buffer traffic.</span></span> <span data-ttu-id="bf55e-252">Это позволит одновременно снизить энергопотребление и повысить производительность.</span><span class="sxs-lookup"><span data-stu-id="bf55e-252">This can be a big win both in power reduction and performance improvement.</span></span> <span data-ttu-id="bf55e-253">Но использование *16-разрядного формата глубины* может иметь два неприятных последствия.</span><span class="sxs-lookup"><span data-stu-id="bf55e-253">However, there are two possible negative outcomes by using *16-bit depth format*.</span></span>

<span data-ttu-id="bf55e-254">**Z-конфликт**</span><span class="sxs-lookup"><span data-stu-id="bf55e-254">**Z-Fighting**</span></span>

<span data-ttu-id="bf55e-255">Снижение четкости по глубине при 16-разрядном буфере повышает вероятность [Z-конфликтов](https://en.wikipedia.org/wiki/Z-fighting) по сравнению с 24-разрядными буферами.</span><span class="sxs-lookup"><span data-stu-id="bf55e-255">The reduced depth range fidelity makes [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) more likely to occur with 16-bit than 24-bit.</span></span> <span data-ttu-id="bf55e-256">Чтобы избежать таких артефактов, измените ближнюю и дальнюю отсекающие плоскости для [камеры Unity](https://docs.unity3d.com/Manual/class-Camera.html) с учетом снижения разрешения.</span><span class="sxs-lookup"><span data-stu-id="bf55e-256">To avoid these artifacts, modify the near/far clip planes of the [Unity camera](https://docs.unity3d.com/Manual/class-Camera.html) to account for the lower precision.</span></span> <span data-ttu-id="bf55e-257">Для приложений на основе HoloLens дальняя отсекающая плоскость в 50 м вместо стандартного для Unity значения 1000 м обычно полностью устраняет Z-конфликты.</span><span class="sxs-lookup"><span data-stu-id="bf55e-257">For HoloLens-based applications, a far clip plane of 50m instead of the Unity default 1000m can generally eliminate any z-fighting.</span></span>

<span data-ttu-id="bf55e-258">**Отключение буфера трафаретов**</span><span class="sxs-lookup"><span data-stu-id="bf55e-258">**Disabled Stencil Buffer**</span></span>

<span data-ttu-id="bf55e-259">Если Unity создает [текстуру отрисовки с 16-разрядной глубиной](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), буфер трафаретов не создается.</span><span class="sxs-lookup"><span data-stu-id="bf55e-259">When Unity creates a [Render Texture with 16-bit depth](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), there is no stencil buffer created.</span></span> <span data-ttu-id="bf55e-260">Согласно документации по Unity, выбор 24-разрядного формата глубины приводит к созданию 24-разрядного z-буфера и 8-разрядного буфера трафаретов (https://docs.unity3d.com/Manual/SL-Stencil.html) (если на устройстве применим 32-разрядный формат, что обычно справедливо для устройств HoloLens).</span><span class="sxs-lookup"><span data-stu-id="bf55e-260">Selecting 24-bit depth format, per Unity documentation, will create a 24-bit z-buffer, as well as an [8-bit stencil buffer] (https://docs.unity3d.com/Manual/SL-Stencil.html) (if 32-bit is applicable on a device, which is generally the case such as HoloLens).</span></span>

### <a name="avoid-full-screen-effects"></a><span data-ttu-id="bf55e-261">Отказ от полноэкранных эффектов</span><span class="sxs-lookup"><span data-stu-id="bf55e-261">Avoid full-screen effects</span></span>

<span data-ttu-id="bf55e-262">Некоторые техники для полного экрана могут быть достаточно дорогими из-за того, что их работа в каждом кадре исчисляется миллионами операций.</span><span class="sxs-lookup"><span data-stu-id="bf55e-262">Techniques that operate on the full screen can be quite expensive since their order of magnitude is millions of operations every frame.</span></span> <span data-ttu-id="bf55e-263">Поэтому мы рекомендуем отказаться от [эффектов постобработки](https://docs.unity3d.com/Manual/PostProcessingOverview.html), таких как сглаживание, свечение и т. п.</span><span class="sxs-lookup"><span data-stu-id="bf55e-263">Thus, it is recommended to avoid [post-processing effects](https://docs.unity3d.com/Manual/PostProcessingOverview.html) such as anti-aliasing, bloom, and more.</span></span>

### <a name="optimal-lighting-settings"></a><span data-ttu-id="bf55e-264">Оптимальные параметры освещения</span><span class="sxs-lookup"><span data-stu-id="bf55e-264">Optimal lighting settings</span></span>

<span data-ttu-id="bf55e-265">[Глобальное освещение в реальном времени](https://docs.unity3d.com/Manual/GIIntro.html) в Unity дает потрясающие визуальные результаты, но требует довольно дорогих вычислений.</span><span class="sxs-lookup"><span data-stu-id="bf55e-265">[Real-time Global Illumination](https://docs.unity3d.com/Manual/GIIntro.html) in Unity can provide outstanding visual results but involves quite expensive lighting calculations.</span></span> <span data-ttu-id="bf55e-266">Мы рекомендуем отключать глобальное освещение в реальном времени для всех сцен Unity. Для этого нужно в разделе **Window** > **Rendering** > **Lighting Settings** (Окно > Отрисовка > Параметры освещения) снять флажок **Real-time Global Illumination** (Глобальное освещение в реальном времени).</span><span class="sxs-lookup"><span data-stu-id="bf55e-266">It is recommended to disable Realtime Global Illumination for every Unity scene file via **Window** > **Rendering** > **Lighting Settings** > Uncheck **Real-time Global Illumination**.</span></span>

<span data-ttu-id="bf55e-267">Более того, мы рекомендуем отключить все тени, так как они создают дополнительные дорогие вызовы GPU из сцены Unity.</span><span class="sxs-lookup"><span data-stu-id="bf55e-267">Furthermore, it is recommended to disable all shadow casting as these also add expensive GPU passes onto a Unity scene.</span></span> <span data-ttu-id="bf55e-268">Тени можно отключать отдельно для каждого источника света или глобально через параметры качества.</span><span class="sxs-lookup"><span data-stu-id="bf55e-268">Shadows can be disable per light but can also be controlled holistically via Quality settings.</span></span>

<span data-ttu-id="bf55e-269">Выберите **Edit** > **Project Settings** (Редактировать > Свойства проекта), затем категорию **Quality** (Качество) и укажите вариант **Low Quality** (Низкое качество) для платформы UWP.</span><span class="sxs-lookup"><span data-stu-id="bf55e-269">**Edit** > **Project Settings**, then select the **Quality** category > Select **Low Quality** for the UWP Platform.</span></span> <span data-ttu-id="bf55e-270">Можно также отдельно указать для свойства **Shadows** (Тени) значение **Disable Shadows** (Отключить тени).</span><span class="sxs-lookup"><span data-stu-id="bf55e-270">One can also just set the **Shadows** property to **Disable Shadows**.</span></span>

### <a name="reduce-poly-count"></a><span data-ttu-id="bf55e-271">Уменьшение количества многоугольников</span><span class="sxs-lookup"><span data-stu-id="bf55e-271">Reduce poly count</span></span>

<span data-ttu-id="bf55e-272">Количество многоугольников можно снизить следующими способами:</span><span class="sxs-lookup"><span data-stu-id="bf55e-272">Polygon count is usually reduced by either</span></span>
1) <span data-ttu-id="bf55e-273">Удаление объектов из сцены.</span><span class="sxs-lookup"><span data-stu-id="bf55e-273">Removing objects from a scene</span></span>
2) <span data-ttu-id="bf55e-274">Прореживание ресурсов, которое позволяет снизить количество многоугольников для некоторой сетки.</span><span class="sxs-lookup"><span data-stu-id="bf55e-274">Asset decimation which reduces the number of polygons for a given mesh</span></span>
3) <span data-ttu-id="bf55e-275">Внедрение в приложение [системы уровня детализации](https://docs.unity3d.com/Manual/LevelOfDetail.html), которая отрисовывает более далекие объекты в виде той же геометрической фигуры с меньшим числом многоугольников.</span><span class="sxs-lookup"><span data-stu-id="bf55e-275">Implementing a [Level of Detail (LOD) System](https://docs.unity3d.com/Manual/LevelOfDetail.html) into your application which renders far away objects with lower-polygon version of the same geometry</span></span>

### <a name="understanding-shaders-in-unity"></a><span data-ttu-id="bf55e-276">Общие сведения о шейдерах в Unity</span><span class="sxs-lookup"><span data-stu-id="bf55e-276">Understanding shaders in Unity</span></span>

<span data-ttu-id="bf55e-277">Для сравнения производительности шейдеров можно использовать упрощенную оценку среднего числа операций, выполняемых каждым из них в среде выполнения.</span><span class="sxs-lookup"><span data-stu-id="bf55e-277">An easy approximation to compare shaders in performance is to identify the average number of operations each executes at runtime.</span></span> <span data-ttu-id="bf55e-278">В Unity это выполнить очень легко.</span><span class="sxs-lookup"><span data-stu-id="bf55e-278">This can be done easily in Unity.</span></span>

1) <span data-ttu-id="bf55e-279">Выберите нужный ресурс шейдера или материал, затем в верхнем правом углу окна Inspector (Инспектор) выберите значок шестеренки и действие **Select Shader** (Выбрать шейдер).</span><span class="sxs-lookup"><span data-stu-id="bf55e-279">Select your shader asset or select a material, then in the top right corner of the inspector window, select the gear icon followed by **"Select Shader"**</span></span>

    ![Выбор шейдера в Unity](images/Select-shader-unity.png)
2) <span data-ttu-id="bf55e-281">После выбора ресурса шейдера нажмите кнопку **Compile and show code** (Компилировать и показать код) в окне Inspector (Инспектор).</span><span class="sxs-lookup"><span data-stu-id="bf55e-281">With the shader asset selected, click the **"Compile and show code"** button under the inspector window</span></span>

    ![Компиляция кода шейдера в Unity](images/compile-shader-code-unity.PNG)

3) <span data-ttu-id="bf55e-283">После компиляции найдите раздел статистики в области результатов, где отображается число разных операций для вершинных и пиксельных шейдеров (учтите, что пиксельные шейдеры часто называют фрагментными).</span><span class="sxs-lookup"><span data-stu-id="bf55e-283">After compiling, look for the statistics section in the results with the number of different operations for both the vertex and pixel shader (Note: pixel shaders are often also called fragment shaders)</span></span>

    ![Работа стандартного шейдера Unity](images/unity-standard-shader-compilation.png)

#### <a name="optimize-pixel-shaders"></a><span data-ttu-id="bf55e-285">Оптимизация пиксельных шейдеров</span><span class="sxs-lookup"><span data-stu-id="bf55e-285">Optimize pixel shaders</span></span>

<span data-ttu-id="bf55e-286">Изучая результаты статистики, полученные описанным выше методом, вы можете заметить, что [фрагментный шейдер](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) в среднем выполняет больше операций, чем [вершинный шейдер](https://en.wikipedia.org/wiki/Shader#Vertex_shaders).</span><span class="sxs-lookup"><span data-stu-id="bf55e-286">Looking at the compiled statistic results using the method above, the [fragment shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) will generally execute more operations than the [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders), on average.</span></span> <span data-ttu-id="bf55e-287">Фрагментный шейдер, также именуемый пиксельным шейдером, выполняется отдельно для каждого пикселя на экране, а вершинный шейдер выполняется только для вершин всех сеток, отрисовываемых на экране.</span><span class="sxs-lookup"><span data-stu-id="bf55e-287">The fragment shader, also known as the pixel shader, is executed per pixel on the screen output while the vertex shader is only executed per-vertex of all meshes being drawn to the screen.</span></span> 

<span data-ttu-id="bf55e-288">Таким образом, фрагментные шейдеры не только выполняют больше операций, чем вершинные (из-за сложных вычислений освещения) но и почти всегда применяются к более крупному набору данных.</span><span class="sxs-lookup"><span data-stu-id="bf55e-288">Thus, not only do fragment shaders have more instructions than vertex shaders because of all the lighting calculations, fragment shaders are almost always executed on a larger dataset.</span></span> <span data-ttu-id="bf55e-289">Например, при размере экрана 2000 на 2000 пикселей фрагментный шейдер будет выполнен 2000 × 2000 = 4 000 000 раз.</span><span class="sxs-lookup"><span data-stu-id="bf55e-289">For example, if the screen output is a 2k by 2k image, then the fragment shader can get executed 2,000\*2,000 = 4,000,000 times.</span></span> <span data-ttu-id="bf55e-290">При отрисовке для двух глаз это число удваивается, так как работают сразу два экрана.</span><span class="sxs-lookup"><span data-stu-id="bf55e-290">If rendering two eyes, this number doubles since there are two screens.</span></span> <span data-ttu-id="bf55e-291">Если приложение смешанной реальности использует несколько проходов, полноэкранные эффекты постобработки или отрисовку нескольких сеток в пределах одного пикселя, это количество еще значительно увеличится.</span><span class="sxs-lookup"><span data-stu-id="bf55e-291">If a mixed reality application has multiple passes, full-screen post-processing effects, or rendering multiple meshes to the same pixel, this number will increase dramatically.</span></span> 

<span data-ttu-id="bf55e-292">Таким образом, снижение числа операций во фрагментных шейдерах обычно значительно больше влияет на производительность, чем аналогичная оптимизация в вершинном шейдере.</span><span class="sxs-lookup"><span data-stu-id="bf55e-292">Therefore, reducing the number of operations in the fragment shader can generally give far greater performance gains over optimizations in the vertex shader.</span></span>

#### <a name="unity-standard-shader-alternatives"></a><span data-ttu-id="bf55e-293">Альтернативы стандартному шейдеру Unity</span><span class="sxs-lookup"><span data-stu-id="bf55e-293">Unity Standard shader alternatives</span></span>

<span data-ttu-id="bf55e-294">Вместо отрисовки на основе физических параметров или другого шейдера высокого качества, попробуйте применить более производительный и более дешевый шейдер.</span><span class="sxs-lookup"><span data-stu-id="bf55e-294">Instead of using a physically based rendering (PBR) or another high-quality shader, look at utilizing a more performant and cheaper shader.</span></span> <span data-ttu-id="bf55e-295">В [наборе средств для смешанной реальности](https://github.com/Microsoft/MixedRealityToolkit-Unity) предоставляется [стандартный шейдер MRTK](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html), который оптимизирован для проектов смешанной реальности.</span><span class="sxs-lookup"><span data-stu-id="bf55e-295">The [Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) provides the [MRTK standard shader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) that has been optimized for mixed reality projects.</span></span>

<span data-ttu-id="bf55e-296">В Unity также доступны упрощенные версии шейдеров (без освещенности, с освещенностью вершин, диффузный и т. д.), которые работают значительно быстрее стандартного шейдера Unity.</span><span class="sxs-lookup"><span data-stu-id="bf55e-296">Unity also provides an unlit, vertex lit, diffuse, and other simplified shader options that are significantly faster compared to the Unity Standard shader.</span></span> <span data-ttu-id="bf55e-297">Дополнительные сведения см. в статье об [использовании и производительности встроенных шейдеров](https://docs.unity3d.com/Manual/shader-Performance.html).</span><span class="sxs-lookup"><span data-stu-id="bf55e-297">See [Usage and Performance of Built-in Shaders](https://docs.unity3d.com/Manual/shader-Performance.html) for more detailed information.</span></span>

#### <a name="shader-preloading"></a><span data-ttu-id="bf55e-298">Предварительная загрузка шейдера</span><span class="sxs-lookup"><span data-stu-id="bf55e-298">Shader preloading</span></span>

<span data-ttu-id="bf55e-299">*Предварительная загрузка шейдера* и некоторые другие приемы позволяют оптимизировать [время загрузки шейдера](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span><span class="sxs-lookup"><span data-stu-id="bf55e-299">Use *Shader preloading* and other tricks to optimize [shader load time](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span></span> <span data-ttu-id="bf55e-300">В частности, предварительная загрузка шейдера позволяет избежать задержек, связанных с компиляцией шейдера во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="bf55e-300">In particular, shader preloading means you won't see any hitches due to runtime shader compilation.</span></span>

### <a name="limit-overdraw"></a><span data-ttu-id="bf55e-301">Ограничение перерисовки</span><span class="sxs-lookup"><span data-stu-id="bf55e-301">Limit overdraw</span></span>

<span data-ttu-id="bf55e-302">В Unity можно отобразить перерисовку сцены, переключившись на [**меню режима отрисовки**](https://docs.unity3d.com/Manual/ViewModes.html) в верхнем левом углу **представления сцены** и выбрав параметр **Overdraw** (Перерисовка).</span><span class="sxs-lookup"><span data-stu-id="bf55e-302">In Unity, one can display overdraw for their scene, by toggling the [**draw mode menu**](https://docs.unity3d.com/Manual/ViewModes.html) in the top-left corner of the **Scene view** and selecting **Overdraw**.</span></span>

<span data-ttu-id="bf55e-303">Обычно перерисовка устраняется предварительным выбором объектов до того, как они будут отправлены в GPU.</span><span class="sxs-lookup"><span data-stu-id="bf55e-303">Generally, overdraw can be mitigated by culling objects ahead of time before they are sent to the GPU.</span></span> <span data-ttu-id="bf55e-304">Unity предоставляет подробные сведения о реализации [отбрасывания загораживаемых объектов](https://docs.unity3d.com/Manual/OcclusionCulling.html) для этой платформы.</span><span class="sxs-lookup"><span data-stu-id="bf55e-304">Unity provides details on implementing [Occlusion Culling](https://docs.unity3d.com/Manual/OcclusionCulling.html) for their engine.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="bf55e-305">Рекомендации по использованию памяти</span><span class="sxs-lookup"><span data-stu-id="bf55e-305">Memory recommendations</span></span>

<span data-ttu-id="bf55e-306">Операции выделения и освобождения памяти в больших объемах могут значительно снижать производительность голографического приложения, что приведет к нестабильному поведению, замиранию кадров и другим неприятным эффектам.</span><span class="sxs-lookup"><span data-stu-id="bf55e-306">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application, resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="bf55e-307">При разработке в Unity особенно важно понимать особенности использования памяти, так как управление памятью здесь реализовано через сборщик мусора.</span><span class="sxs-lookup"><span data-stu-id="bf55e-307">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="garbage-collection"></a><span data-ttu-id="bf55e-308">Сбор мусора</span><span class="sxs-lookup"><span data-stu-id="bf55e-308">Garbage collection</span></span>

<span data-ttu-id="bf55e-309">Голографические приложения тратят вычислительное время процессора на сбор мусора, когда он активируется для анализа объектов, вышедших из поля зрения в процессе выполнения и требующих удаления из памяти, чтобы использовать ее повторно.</span><span class="sxs-lookup"><span data-stu-id="bf55e-309">Holographic apps will lose processing compute time to the garbage collector (GC) when the GC is activated to analyze objects that are no longer in scope during execution and their memory needs to be released, so it can be made available for re-use.</span></span> <span data-ttu-id="bf55e-310">Постоянные операции выделения и освобождения памяти обычно требуют более частого вызова сборщика мусора, что ухудшает производительность и взаимодействие с пользователем.</span><span class="sxs-lookup"><span data-stu-id="bf55e-310">Constant allocations and de-allocations will generally require the garbage collector to run more frequently, thus hurting performance and user experience.</span></span>

<span data-ttu-id="bf55e-311">Unity предоставляет отличный ресурс, на котором подробно описана работа сборщика мусора и собраны рекомендации по повышению эффективности работы с памятью в коде.</span><span class="sxs-lookup"><span data-stu-id="bf55e-311">Unity has provided an excellent page that explains in detail how the garbage collector works and tips to write more efficient code in regards to memory management.</span></span>
- [<span data-ttu-id="bf55e-312">Оптимизация сбора мусора в играх на Unity</span><span class="sxs-lookup"><span data-stu-id="bf55e-312">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)

<span data-ttu-id="bf55e-313">При разработке в Unity одной из самых распространенных ошибок, которые приводят к избыточному сбору мусора, является отсутствие кэша для ссылок на компоненты и классы.</span><span class="sxs-lookup"><span data-stu-id="bf55e-313">One of the most common practices that leads to excessive garbage collection is not caching references to components and classes in Unity development.</span></span> <span data-ttu-id="bf55e-314">Все ссылки следует собирать в методе Start() или Awake() и всегда использовать повторно из кэша в функциях Update() и LateUpdate().</span><span class="sxs-lookup"><span data-stu-id="bf55e-314">Any references should be captured during Start() or Awake() and re-used in later functions such as Update() or LateUpdate().</span></span>

<span data-ttu-id="bf55e-315">Еще немного советов.</span><span class="sxs-lookup"><span data-stu-id="bf55e-315">Other quick tips:</span></span>
- <span data-ttu-id="bf55e-316">Используйте класс C# [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) для динамического создания сложных строк в процессе выполнения.</span><span class="sxs-lookup"><span data-stu-id="bf55e-316">Use the [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# class to dynamically build complex strings at runtime</span></span>
- <span data-ttu-id="bf55e-317">Удалите все вызовы Debug.Log(), когда в них отпадет необходимость, иначе они будут по-прежнему выполняться в рабочих версиях приложения.</span><span class="sxs-lookup"><span data-stu-id="bf55e-317">Remove calls to Debug.Log() when no longer needed, as they still execute in all build versions of an app</span></span>
- <span data-ttu-id="bf55e-318">Если голографическое приложение часто требует большого объема памяти, попробуйте вызывать [ _**System.GC.Collect()**_ ](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) на этапах загрузки, например при отображении экрана загрузки или перехода между сценами.</span><span class="sxs-lookup"><span data-stu-id="bf55e-318">If your holographic app generally requires lots of memory, consider calling  [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) during loading phases such as when presenting a loading or transition screen</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="bf55e-319">Использование пулов объектов</span><span class="sxs-lookup"><span data-stu-id="bf55e-319">Object pooling</span></span>

<span data-ttu-id="bf55e-320">Использование пулов объектов — это распространенный метод для снижения затрат на постоянное выделение или освобождение памяти для объектов.</span><span class="sxs-lookup"><span data-stu-id="bf55e-320">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="bf55e-321">Для этого выделяется большой пул идентичных объектов, из которого извлекаются для повторного использования доступные и неактивные экземпляры. Это эффективнее, чем постоянный процесс создания и уничтожения объектов.</span><span class="sxs-lookup"><span data-stu-id="bf55e-321">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="bf55e-322">Пулы объектов отлично подходят для многократно используемых компонентов с переменными периодами жизни в приложении.</span><span class="sxs-lookup"><span data-stu-id="bf55e-322">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

- [<span data-ttu-id="bf55e-323">Руководство по использованию пулов объектов в Unity</span><span class="sxs-lookup"><span data-stu-id="bf55e-323">Object Pooling Tutorial in Unity</span></span>](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a><span data-ttu-id="bf55e-324">Производительность при запуске</span><span class="sxs-lookup"><span data-stu-id="bf55e-324">Startup performance</span></span>

<span data-ttu-id="bf55e-325">Возможно, вам лучше начать работу приложения с небольшой сцены, а затем загружать остальную часть с помощью *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* .</span><span class="sxs-lookup"><span data-stu-id="bf55e-325">You should consider starting your app with a smaller scene, then using *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* to load the rest of the scene.</span></span> <span data-ttu-id="bf55e-326">Это позволит приложению максимально быстро перейти к интерактивному состоянию.</span><span class="sxs-lookup"><span data-stu-id="bf55e-326">This allows your app to get to an interactive state as fast as possible.</span></span> <span data-ttu-id="bf55e-327">Учитывайте, что при активации новой сцены создается пиковая нагрузка на ЦП, что может привести к задержкам или дрожанию отображаемого содержимого.</span><span class="sxs-lookup"><span data-stu-id="bf55e-327">Be aware that there may be a large CPU spike while the new scene is being activated and that any rendered content might stutter or hitch.</span></span> <span data-ttu-id="bf55e-328">Для обхода этой проблемы можно установить для параметра загружаемой сцены AsyncOperation.allowSceneActivation значение False, затем дождаться полной загрузки сцены, очистить экран и вернуть этому параметру значение True для завершения активации сцены.</span><span class="sxs-lookup"><span data-stu-id="bf55e-328">One way to work around this is to set the AsyncOperation.allowSceneActivation property to "false" on the scene being loaded, wait for the scene to load, clear the screen to black, and then set it back to "true" to complete the scene activation.</span></span>

<span data-ttu-id="bf55e-329">Не забывайте, что в процессе загрузки сцены пользователю будет отображаться голографический стартовый экран.</span><span class="sxs-lookup"><span data-stu-id="bf55e-329">Remember that while the startup scene is loading, the holographic splash screen will be displayed to the user.</span></span>

## <a name="see-also"></a><span data-ttu-id="bf55e-330">См. также статью</span><span class="sxs-lookup"><span data-stu-id="bf55e-330">See also</span></span>
- [<span data-ttu-id="bf55e-331">Оптимизация отрисовки графических объектов в играх на Unity</span><span class="sxs-lookup"><span data-stu-id="bf55e-331">Optimizing graphics rendering in Unity games</span></span>](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)
- [<span data-ttu-id="bf55e-332">Оптимизация сбора мусора в играх на Unity</span><span class="sxs-lookup"><span data-stu-id="bf55e-332">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)
- <span data-ttu-id="bf55e-333">[Советы и рекомендации по физике (Unity)](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span><span class="sxs-lookup"><span data-stu-id="bf55e-333">[Physics Best Practices [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span></span>
- <span data-ttu-id="bf55e-334">[Оптимизация скриптов (Unity)](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span><span class="sxs-lookup"><span data-stu-id="bf55e-334">[Optimizing Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span></span>
