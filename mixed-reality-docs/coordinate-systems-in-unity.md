---
title: Системы координат в Unity
description: Узнайте, как создавать посторонние, ориентированные, масштабируемые и крупномасштабные возможности смешанной реальности в Unity.
author: thetuvix
ms.author: alexturn
ms.date: 02/24/2019
ms.topic: article
keywords: система координат, пространственный система координат, только ориентация, установленный масштаб, фиксированное масштабирование, свободное пространство, масштаб, мир, 360 градусов, установленный, зафиксированный, комната, мир, масштаб, положение, ориентация, Unity, привязка, пространственный якорь, прикрепление, универсальная блокировка Блокировка мира, Блокировка текста, блокировка тела, отслеживание потерь, локатабилити, границы, перецентрирование
ms.openlocfilehash: 36d74488b23587e5c89b40faf97921a10be7473b
ms.sourcegitcommit: 915d3cc63a5571ba22ac4608589f3eca8da1bc81
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/24/2019
ms.locfileid: "63525961"
---
# <a name="coordinate-systems-in-unity"></a>Системы координат в Unity

Windows Mixed Reality поддерживает приложения в [различных масштабах](coordinate-systems.md), начиная с приложений с ориентацией на страницы и до крупномасштабных приложений. В HoloLens вы можете создавать приложения для мирового уровня, которые позволяют пользователям проходить более чем за 5 метров, изучая целый ряд здания и выходят за рамки.

Первым шагом в создании смешанной реальности в Unity является определение того, для чего будет работать [масштабирование](coordinate-systems.md) приложения.

## <a name="building-an-orientation-only-or-seated-scale-experience"></a>Создание интерфейса, поддерживающего только ориентацию, или с возможностями масштабирования

**Имен** *UnityEngine. XR*<br>
**Тип** *ксрдевице*

Чтобы создать интерфейс с **поддержкой ориентации** или **режима**, необходимо задать для Unity стационарный тип пространства отслеживания. Этот параметр задает мировую систему координат Unity для отслеживания [стационарной рамки ссылки](coordinate-systems.md#spatial-coordinate-systems). В режиме нестационарного отслеживания содержимое, помещенное в редактор непосредственно перед расположением по умолчанию камеры (переадресация — Z), будет отображаться перед пользователем при запуске приложения.

```cs
XRDevice.SetTrackingSpaceType(TrackingSpaceType.Stationary);
```

**Имен** *UnityEngine. XR*<br>
**Тип** *инпуттраккинг*

Для чистой **ориентации** , такой как видео-средство просмотра 360 (если позиционированные головные обновления насмарку иллюзию), можно установить [XR. Инпуттраккинг. Дисаблепоситионалтраккинг](https://docs.unity3d.com/ScriptReference/XR.InputTracking-disablePositionalTracking.html) имеет значение true:

```cs
InputTracking.disablePositionalTracking = true;
```

Для **работы с возможностями масштабирования**, чтобы пользователь мог позже изменить центр исходного места, можно вызвать [XR. Метод Инпуттраккинг. recenter](https://docs.unity3d.com/ScriptReference/XR.InputTracking.Recenter.html) :

```cs
InputTracking.Recenter();
```

## <a name="building-a-standing-scale-or-room-scale-experience"></a>Создание фиксированного масштаба или возможностей для масштабирования комнаты

**Имен** *UnityEngine. XR*<br>
**Тип** *ксрдевице*

Для работы с фиксированным масштабированием или **комнатным масштабированием**необходимо разместить содержимое относительно основания. Вы указываете на этаж пользователя с помощью **[пространственного этапа](coordinate-systems.md#spatial-coordinate-systems)** , который представляет определенное пользователем происхождение на уровне пола и дополнительную границу комнаты, настраивается во время первого запуска.

Чтобы убедиться, что Unity работает со своей мировой системой координат на уровне пола, можно задать для Unity тип пространства отслеживания Румскале и убедиться, что набор выполнен правильно:

```cs
if (XRDevice.SetTrackingSpaceType(TrackingSpaceType.RoomScale))
{
    // RoomScale mode was set successfully.  App can now assume that y=0 in Unity world coordinate represents the floor.
}
else
{
    // RoomScale mode was not set successfully.  App cannot make assumptions about where the floor plane is.
}
```
* Если Сеттраккингспацетипе возвращает значение true, Unity успешно переключил свою систему координат мира для мониторинга промежуточного [кадра ссылки](coordinate-systems.md#spatial-coordinate-systems).
* Если Сеттраккингспацетипе возвращает значение false, Unity не смог переключиться на промежуточный кадр ссылки, скорее всего потому, что пользователь не настроил даже этаж в своей среде. Это не является распространенным, но может произойти, если этап был настроен в другой комнате и устройство было перемещено в текущую комнату без настройки нового этапа пользователем.

После того как приложение успешно установит тип пространства отслеживания Румскале, на этаж будут отображаться содержимое, помещенное на плоскости y = 0. Источник в точке (0, 0, 0) будет определять конкретное место в этаже, где пользователь стояли во время настройки комнаты, с параметром-Z, представляющим Направление переадресации во время установки.

**Имен** *UnityEngine. экспериментальный. XR*<br>
**Тип** *Границ*

В коде скрипта можно вызвать метод Трижетжеометри, так как тип UnityEngine. экспериментальный. XR. граничное используется для получения граничного многоугольника, указывая тип границы Траккедареа. Если пользователь определил границу (вы получаете список вершин), вы узнаете, как можно обеспечить пользователю **возможности масштабирования комнаты** , где он может пройти по создаваемой сцене.

Обратите внимание, что система автоматически визуализирует границу, когда пользователь его приближает. Приложению не нужно использовать этот многоугольник для отрисовки самой границы. Тем не менее можно выбрать размещение объектов сцены с помощью этого многоугольника, чтобы гарантировать, что пользователь сможет физически достичь этих объектов без переноса.

```cs
var vertices = new List<Vector3>();
if (UnityEngine.Experimental.XR.Boundary.TryGetGeometry(vertices, Boundary.Type.TrackedArea))
{
    // Lay out your app's content within the boundary polygon, to ensure that users can reach it without teleporting.
}
```

## <a name="building-a-world-scale-experience"></a>Создание возможностей для мирового масштабирования

**Имен** *UnityEngine. XR. WSA*<br>
**Тип** *ворлданчор*

Для полноценного **крупномасштабного взаимодействия** в HoloLens, который позволяет пользователям рыскающего более 5 метров, вам потребуются новые методы, кроме тех, которые используются для работы с масштабом комнаты. Одной из ключевых методик, которую вы будете использовать, является создание [пространственной привязки](coordinate-systems.md#spatial-anchors) для блокировки кластера голограмм, точно на месте физического мира, независимо от того, на каком расстояние перемещен пользователь, а затем [снова находит эти голограммы в последующих сеансах](coordinate-systems.md#spatial-anchor-persistence).

В Unity вы создаете пространственное привязку, добавив компонент Unity **ворлданчор** в GameObject.

### <a name="adding-a-world-anchor"></a>Добавление универсальной привязки

Чтобы добавить привязку к мировому объекту<WorldAnchor>, вызовите метод AddComponent () для игрового объекта с преобразованием, которое необходимо привязать в реальном мире.

```cs
WorldAnchor anchor = gameObject.AddComponent<WorldAnchor>();
```

Вот и все! Этот объект игры теперь будет привязан к его текущему расположению в физическом мире. Вы можете увидеть, что его координаты Unity могут немного измениться с течением времени, чтобы обеспечить физическое выравнивание. Используйте [сохраняемость](persistence-in-unity.md) для повторного нахождения этого привязанного расположения в следующем сеансе приложения.

### <a name="removing-a-world-anchor"></a>Удаление универсальной привязки

Если вы больше не хотите, чтобы GameObject заблокировались в физическом расположении и не планировали перемещать его, то можно просто вызвать Destroy в компоненте «Универсальная привязка».

```cs
Destroy(gameObject.GetComponent<WorldAnchor>());
```

Если вы хотите переместить GameObject этот кадр, необходимо вызвать Дестройиммедиате.

```cs
DestroyImmediate(gameObject.GetComponent<WorldAnchor>());
```

### <a name="moving-a-world-anchored-gameobject"></a>Перемещение привязанного GameObject по всему миру

GameObject нельзя переместить, пока на нем есть универсальная привязка. Если вам нужно переместить GameObject этот кадр, сделайте следующее:
1. Дестройиммедиате компонент «мировая привязка»
2. Перемещение GameObject
3. Добавьте новый компонент универсальной привязки к GameObject.

```cs
DestroyImmediate(gameObject.GetComponent<WorldAnchor>());
gameObject.transform.position = new Vector3(0, 0, 2);
WorldAnchor anchor = gameObject.AddComponent<WorldAnchor>();
```

### <a name="handling-locatability-changes"></a>Обработка изменений Локатабилити

Ворлданчор не может быть размещаемые в физическом мире на момент времени. В таком случае Unity не будет обновлять преобразование привязанного объекта. Это также можно изменить во время работы приложения. Сбой при обработке изменения в локатабилити приведет к тому, что объект не будет отображаться в правильном физическом расположении в мире.

Чтобы получать уведомления об изменениях локатабилити:
1. Подпишитесь на событие Онтраккингчанжед
2. Обработайте событие

Событие **онтраккингчанжед** будет вызываться при каждом изменении базовой пространственной привязки между состояниями размещаемые и not размещаемые.

```cs
anchor.OnTrackingChanged += Anchor_OnTrackingChanged;
```

Затем обработайте событие:

```cs
private void Anchor_OnTrackingChanged(WorldAnchor self, bool located)
{
    // This simply activates/deactivates this object and all children when tracking changes
    self.gameObject.SetActiveRecursively(located);
}
```

Иногда привязки размещаются немедленно. В этом случае для этого свойства объекта привязки будет задано значение true, если функция AddComponent<WorldAnchor>() возвращает. В результате событие Онтраккингчанжед не будет активировано. Чистый шаблон будет вызывать обработчик Онтраккингчанжед с начальным состоянием после присоединения привязки.

```cs
Anchor_OnTrackingChanged(anchor, anchor.isLocated);
```

## <a name="sharing-anchors-across-devices"></a>Совместное использование привязок на разных устройствах

<a href="https://docs.microsoft.com/azure/spatial-anchors/overview" target="_blank">Пространственные привязки Azure</a> можно использовать для создания надежной облачной привязки на основе локальной ворлданчор, которую приложение может разместить на нескольких устройствах HoloLens, iOS и Android.  При совместном использовании общей пространственной привязки на нескольких устройствах каждый пользователь может видеть содержимое, отображаемое относительно этой привязки в том же физическом расположении.  Это позволяет обмениваться опытом в режиме реального времени.

Чтобы приступить к созданию общих интерфейсов в Unity, ознакомьтесь с пошаговыми руководствами Unity по 5-минутной <a href="https://docs.microsoft.com/azure/spatial-anchors/unity-overview" target="_blank">пространственной привязке Azure</a>.

После завершения работы с пространственными привязками Azure можно <a href="https://docs.microsoft.com/azure/spatial-anchors/concepts/create-locate-anchors-unity" target="_blank">создавать и искать привязки в Unity</a>.

## <a name="see-also"></a>См. также
* [Масштабирование работы](coordinate-systems.md#mixed-reality-experience-scales)
* [Пространственный этап](coordinate-systems.md#stage-frame-of-reference)
* [Потеря слежения в Unity](tracking-loss-in-unity.md)
* [Пространственные привязки](spatial-anchors.md)
* [Сохраняемость в Unity](persistence-in-unity.md)
* [Общий доступ в Unity](shared-experiences-in-unity.md)
* <a href="https://docs.microsoft.com/azure/spatial-anchors" target="_blank">Пространственные привязки Azure</a>
* <a href="https://docs.microsoft.com/dotnet/api/Microsoft.Azure.SpatialAnchors" target="_blank">Пакет SDK для пространственных привязок Azure для Unity</a>